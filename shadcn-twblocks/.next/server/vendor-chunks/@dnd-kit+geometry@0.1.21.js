"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dnd-kit+geometry@0.1.21";
exports.ids = ["vendor-chunks/@dnd-kit+geometry@0.1.21"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@dnd-kit+geometry@0.1.21/node_modules/@dnd-kit/geometry/dist/index.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dnd-kit+geometry@0.1.21/node_modules/@dnd-kit/geometry/dist/index.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Axes: () => (/* binding */ Axes),\n/* harmony export */   Axis: () => (/* binding */ Axis),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   Rectangle: () => (/* binding */ Rectangle),\n/* harmony export */   exceedsDistance: () => (/* binding */ exceedsDistance)\n/* harmony export */ });\n/* harmony import */ var _dnd_kit_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dnd-kit/state */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+state@0.1.21/node_modules/@dnd-kit/state/dist/index.mjs\");\n/* harmony import */ var _dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dnd-kit/state */ \"(ssr)/./node_modules/.pnpm/@preact+signals-core@1.12.1/node_modules/@preact/signals-core/dist/signals-core.mjs\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __pow = Math.pow;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __decoratorStart = (base) => {\n  var _a2;\n  return [, , , __create((_a2 = base == null ? void 0 : base[__knownSymbol(\"metadata\")]) != null ? _a2 : null)];\n};\nvar __decoratorStrings = [\"class\", \"method\", \"getter\", \"setter\", \"accessor\", \"field\", \"value\", \"get\", \"set\"];\nvar __expectFn = (fn) => fn !== void 0 && typeof fn !== \"function\" ? __typeError(\"Function expected\") : fn;\nvar __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError(\"Already initialized\") : fns.push(__expectFn(fn || null)) });\nvar __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol(\"metadata\"), array[3]);\nvar __runInitializers = (array, flags, self, value) => {\n  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);\n  return value;\n};\nvar __decorateElement = (array, flags, name, decorators, target, extra) => {\n  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);\n  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];\n  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);\n  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {\n    return __privateGet(this, extra);\n  }, set [name](x) {\n    return __privateSet(this, extra, x);\n  } }, name));\n  k ? p && k < 4 && __name(extra, (k > 2 ? \"set \" : k > 1 ? \"get \" : \"\") + name) : __name(target, name);\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);\n    if (k) {\n      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };\n      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];\n      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;\n    }\n    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;\n    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);\n    else if (typeof it !== \"object\" || it === null) __typeError(\"Object expected\");\n    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);\n  }\n  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the \"in\" operator on this value') : member.has(obj);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/point/Point.ts\nvar Point = class _Point {\n  /**\n   * @param {number} Coordinate of the point on the horizontal axis\n   * @param {number} Coordinate of the point on the vertical axis\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Returns the delta between this point and another point.\n   *\n   * @param {Point} a - A point\n   * @param {Point} b - Another point\n   */\n  static delta(a, b) {\n    return new _Point(a.x - b.x, a.y - b.y);\n  }\n  /**\n   * Returns the distance (hypotenuse) between this point and another point.\n   *\n   * @param {Point} a - A point\n   * @param {Point} b - Another point\n   */\n  static distance(a, b) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n  /**\n   * Returns true if both points are equal.\n   *\n   * @param {Point} a - A point\n   * @param {Point} b - Another point\n   */\n  static equals(a, b) {\n    return a.x === b.x && a.y === b.y;\n  }\n  static from({ x, y }) {\n    return new _Point(x, y);\n  }\n};\n\n// src/shapes/Rectangle.ts\nvar Rectangle = class _Rectangle {\n  constructor(left, top, width, height) {\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n    this.scale = {\n      x: 1,\n      y: 1\n    };\n  }\n  get inverseScale() {\n    return {\n      x: 1 / this.scale.x,\n      y: 1 / this.scale.y\n    };\n  }\n  translate(x, y) {\n    const { top, left, width, height, scale } = this;\n    const newShape = new _Rectangle(left + x, top + y, width, height);\n    newShape.scale = __spreadValues({}, scale);\n    return newShape;\n  }\n  get boundingRectangle() {\n    const { width, height, left, top, right, bottom } = this;\n    return { width, height, left, top, right, bottom };\n  }\n  get center() {\n    const { left, top, right, bottom } = this;\n    return new Point((left + right) / 2, (top + bottom) / 2);\n  }\n  get area() {\n    const { width, height } = this;\n    return width * height;\n  }\n  equals(shape) {\n    if (!(shape instanceof _Rectangle)) {\n      return false;\n    }\n    const { left, top, width, height } = this;\n    return left === shape.left && top === shape.top && width === shape.width && height === shape.height;\n  }\n  containsPoint(point) {\n    const { top, left, bottom, right } = this;\n    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;\n  }\n  intersectionArea(shape) {\n    if (shape instanceof _Rectangle) {\n      return rectangleRectangleIntersection(this, shape);\n    }\n    return 0;\n  }\n  intersectionRatio(shape) {\n    const { area } = this;\n    const intersectionArea = this.intersectionArea(shape);\n    const intersectionRatio = intersectionArea / (shape.area + area - intersectionArea);\n    return intersectionRatio;\n  }\n  get bottom() {\n    const { top, height } = this;\n    return top + height;\n  }\n  get right() {\n    const { left, width } = this;\n    return left + width;\n  }\n  get aspectRatio() {\n    const { width, height } = this;\n    return width / height;\n  }\n  get corners() {\n    return [\n      { x: this.left, y: this.top },\n      { x: this.right, y: this.top },\n      { x: this.left, y: this.bottom },\n      { x: this.right, y: this.bottom }\n    ];\n  }\n  static from({ top, left, width, height }) {\n    return new _Rectangle(left, top, width, height);\n  }\n  static delta(a, b, alignment = { x: \"center\", y: \"center\" }) {\n    const getCoordinate = (rect, axis) => {\n      const align = alignment[axis];\n      const start = axis === \"x\" ? rect.left : rect.top;\n      const size = axis === \"x\" ? rect.width : rect.height;\n      if (align == \"start\") return start;\n      if (align == \"end\") return start + size;\n      return start + size / 2;\n    };\n    return Point.delta(\n      { x: getCoordinate(a, \"x\"), y: getCoordinate(a, \"y\") },\n      { x: getCoordinate(b, \"x\"), y: getCoordinate(b, \"y\") }\n    );\n  }\n  static intersectionRatio(a, b) {\n    return _Rectangle.from(a).intersectionRatio(_Rectangle.from(b));\n  }\n};\nfunction rectangleRectangleIntersection(a, b) {\n  const top = Math.max(b.top, a.top);\n  const left = Math.max(b.left, a.left);\n  const right = Math.min(b.left + b.width, a.left + a.width);\n  const bottom = Math.min(b.top + b.height, a.top + a.height);\n  const width = right - left;\n  const height = bottom - top;\n  if (left < right && top < bottom) {\n    const intersectionArea = width * height;\n    return intersectionArea;\n  }\n  return 0;\n}\n\n// src/position/position.ts\n\nvar _direction_dec, _delta_dec, _a, _timestamp, _init;\nvar Position = class extends (_a = _dnd_kit_state__WEBPACK_IMPORTED_MODULE_0__.ValueHistory, _delta_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_0__.derived], _direction_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_0__.derived], _a) {\n  constructor(initialValue) {\n    const point = Point.from(initialValue);\n    super(point, (a, b) => Point.equals(a, b));\n    __runInitializers(_init, 5, this);\n    __privateAdd(this, _timestamp, 0);\n    this.velocity = { x: 0, y: 0 };\n  }\n  get delta() {\n    return Point.delta(this.current, this.initial);\n  }\n  get direction() {\n    const { current, previous } = this;\n    if (!previous) return null;\n    const delta = {\n      x: current.x - previous.x,\n      y: current.y - previous.y\n    };\n    if (!delta.x && !delta.y) {\n      return null;\n    }\n    if (Math.abs(delta.x) > Math.abs(delta.y)) {\n      return delta.x > 0 ? \"right\" : \"left\";\n    }\n    return delta.y > 0 ? \"down\" : \"up\";\n  }\n  get current() {\n    return super.current;\n  }\n  set current(coordinates) {\n    const { current } = this;\n    const point = Point.from(coordinates);\n    const delta = {\n      x: point.x - current.x,\n      y: point.y - current.y\n    };\n    const timestamp = Date.now();\n    const timeDelta = timestamp - __privateGet(this, _timestamp);\n    const velocity = (delta2) => Math.round(delta2 / timeDelta * 100);\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      __privateSet(this, _timestamp, timestamp);\n      this.velocity = {\n        x: velocity(delta.x),\n        y: velocity(delta.y)\n      };\n      super.current = point;\n    });\n  }\n  reset(coordinates = this.defaultValue) {\n    super.reset(Point.from(coordinates));\n    this.velocity = { x: 0, y: 0 };\n  }\n};\n_init = __decoratorStart(_a);\n_timestamp = new WeakMap();\n__decorateElement(_init, 2, \"delta\", _delta_dec, Position);\n__decorateElement(_init, 2, \"direction\", _direction_dec, Position);\n__decoratorMetadata(_init, Position);\n\n// src/distance/distance.ts\nfunction exceedsDistance({ x, y }, distance) {\n  const dx = Math.abs(x);\n  const dy = Math.abs(y);\n  if (typeof distance === \"number\") {\n    return Math.sqrt(__pow(dx, 2) + __pow(dy, 2)) > distance;\n  }\n  if (\"x\" in distance && \"y\" in distance) {\n    return dx > distance.x && dy > distance.y;\n  }\n  if (\"x\" in distance) {\n    return dx > distance.x;\n  }\n  if (\"y\" in distance) {\n    return dy > distance.y;\n  }\n  return false;\n}\n\n// src/types/axis.ts\nvar Axis = /* @__PURE__ */ ((Axis2) => {\n  Axis2[\"Horizontal\"] = \"x\";\n  Axis2[\"Vertical\"] = \"y\";\n  return Axis2;\n})(Axis || {});\nvar Axes = Object.values(Axis);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGRuZC1raXQrZ2VvbWV0cnlAMC4xLjIxL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9nZW9tZXRyeS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdKQUF3SjtBQUN6TjtBQUNBO0FBQ0Esa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUMsK0NBQStDO0FBQy9DO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiwrQkFBK0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQTBDO0FBQ3RELGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQkFBMkI7QUFDbkMsUUFBUSw0QkFBNEI7QUFDcEMsUUFBUSw4QkFBOEI7QUFDdEMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQW9EO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLG1DQUFtQyx3REFBWSxnQkFBZ0IsbURBQU8scUJBQXFCLG1EQUFPO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsWUFBWTtBQUNiO0FBUUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mZWRlcmljb2pvcmdlYm9uZWx0b3p6aS9EZXNrdG9wL1dvcmsvcHVjay9jb2RlL2Vjb3N5c3RlbS9wdWNrLWNvbmZpZ3Mvc2hhZGNuLXR3YmxvY2tzL25vZGVfbW9kdWxlcy8ucG5wbS9AZG5kLWtpdCtnZW9tZXRyeUAwLjEuMjEvbm9kZV9tb2R1bGVzL0BkbmQta2l0L2dlb21ldHJ5L2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2tub3duU3ltYm9sID0gKG5hbWUsIHN5bWJvbCkgPT4gKHN5bWJvbCA9IFN5bWJvbFtuYW1lXSkgPyBzeW1ib2wgOiBTeW1ib2wuZm9yKFwiU3ltYm9sLlwiICsgbmFtZSk7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX3BvdyA9IE1hdGgucG93O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbnZhciBfX2RlY29yYXRvclN0YXJ0ID0gKGJhc2UpID0+IHtcbiAgdmFyIF9hMjtcbiAgcmV0dXJuIFssICwgLCBfX2NyZWF0ZSgoX2EyID0gYmFzZSA9PSBudWxsID8gdm9pZCAwIDogYmFzZVtfX2tub3duU3ltYm9sKFwibWV0YWRhdGFcIildKSAhPSBudWxsID8gX2EyIDogbnVsbCldO1xufTtcbnZhciBfX2RlY29yYXRvclN0cmluZ3MgPSBbXCJjbGFzc1wiLCBcIm1ldGhvZFwiLCBcImdldHRlclwiLCBcInNldHRlclwiLCBcImFjY2Vzc29yXCIsIFwiZmllbGRcIiwgXCJ2YWx1ZVwiLCBcImdldFwiLCBcInNldFwiXTtcbnZhciBfX2V4cGVjdEZuID0gKGZuKSA9PiBmbiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiID8gX190eXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKSA6IGZuO1xudmFyIF9fZGVjb3JhdG9yQ29udGV4dCA9IChraW5kLCBuYW1lLCBkb25lLCBtZXRhZGF0YSwgZm5zKSA9PiAoeyBraW5kOiBfX2RlY29yYXRvclN0cmluZ3Nba2luZF0sIG5hbWUsIG1ldGFkYXRhLCBhZGRJbml0aWFsaXplcjogKGZuKSA9PiBkb25lLl8gPyBfX3R5cGVFcnJvcihcIkFscmVhZHkgaW5pdGlhbGl6ZWRcIikgOiBmbnMucHVzaChfX2V4cGVjdEZuKGZuIHx8IG51bGwpKSB9KTtcbnZhciBfX2RlY29yYXRvck1ldGFkYXRhID0gKGFycmF5LCB0YXJnZXQpID0+IF9fZGVmTm9ybWFsUHJvcCh0YXJnZXQsIF9fa25vd25TeW1ib2woXCJtZXRhZGF0YVwiKSwgYXJyYXlbM10pO1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKGFycmF5LCBmbGFncywgc2VsZiwgdmFsdWUpID0+IHtcbiAgZm9yICh2YXIgaSA9IDAsIGZucyA9IGFycmF5W2ZsYWdzID4+IDFdLCBuID0gZm5zICYmIGZucy5sZW5ndGg7IGkgPCBuOyBpKyspIGZsYWdzICYgMSA/IGZuc1tpXS5jYWxsKHNlbGYpIDogdmFsdWUgPSBmbnNbaV0uY2FsbChzZWxmLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kZWNvcmF0ZUVsZW1lbnQgPSAoYXJyYXksIGZsYWdzLCBuYW1lLCBkZWNvcmF0b3JzLCB0YXJnZXQsIGV4dHJhKSA9PiB7XG4gIHZhciBmbiwgaXQsIGRvbmUsIGN0eCwgYWNjZXNzLCBrID0gZmxhZ3MgJiA3LCBzID0gISEoZmxhZ3MgJiA4KSwgcCA9ICEhKGZsYWdzICYgMTYpO1xuICB2YXIgaiA9IGsgPiAzID8gYXJyYXkubGVuZ3RoICsgMSA6IGsgPyBzID8gMSA6IDIgOiAwLCBrZXkgPSBfX2RlY29yYXRvclN0cmluZ3NbayArIDVdO1xuICB2YXIgaW5pdGlhbGl6ZXJzID0gayA+IDMgJiYgKGFycmF5W2ogLSAxXSA9IFtdKSwgZXh0cmFJbml0aWFsaXplcnMgPSBhcnJheVtqXSB8fCAoYXJyYXlbal0gPSBbXSk7XG4gIHZhciBkZXNjID0gayAmJiAoIXAgJiYgIXMgJiYgKHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGUpLCBrIDwgNSAmJiAoayA+IDMgfHwgIXApICYmIF9fZ2V0T3duUHJvcERlc2MoayA8IDQgPyB0YXJnZXQgOiB7IGdldCBbbmFtZV0oKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBleHRyYSk7XG4gIH0sIHNldCBbbmFtZV0oeCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVTZXQodGhpcywgZXh0cmEsIHgpO1xuICB9IH0sIG5hbWUpKTtcbiAgayA/IHAgJiYgayA8IDQgJiYgX19uYW1lKGV4dHJhLCAoayA+IDIgPyBcInNldCBcIiA6IGsgPiAxID8gXCJnZXQgXCIgOiBcIlwiKSArIG5hbWUpIDogX19uYW1lKHRhcmdldCwgbmFtZSk7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY3R4ID0gX19kZWNvcmF0b3JDb250ZXh0KGssIG5hbWUsIGRvbmUgPSB7fSwgYXJyYXlbM10sIGV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICBpZiAoaykge1xuICAgICAgY3R4LnN0YXRpYyA9IHMsIGN0eC5wcml2YXRlID0gcCwgYWNjZXNzID0gY3R4LmFjY2VzcyA9IHsgaGFzOiBwID8gKHgpID0+IF9fcHJpdmF0ZUluKHRhcmdldCwgeCkgOiAoeCkgPT4gbmFtZSBpbiB4IH07XG4gICAgICBpZiAoayBeIDMpIGFjY2Vzcy5nZXQgPSBwID8gKHgpID0+IChrIF4gMSA/IF9fcHJpdmF0ZUdldCA6IF9fcHJpdmF0ZU1ldGhvZCkoeCwgdGFyZ2V0LCBrIF4gNCA/IGV4dHJhIDogZGVzYy5nZXQpIDogKHgpID0+IHhbbmFtZV07XG4gICAgICBpZiAoayA+IDIpIGFjY2Vzcy5zZXQgPSBwID8gKHgsIHkpID0+IF9fcHJpdmF0ZVNldCh4LCB0YXJnZXQsIHksIGsgXiA0ID8gZXh0cmEgOiBkZXNjLnNldCkgOiAoeCwgeSkgPT4geFtuYW1lXSA9IHk7XG4gICAgfVxuICAgIGl0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGsgPyBrIDwgNCA/IHAgPyBleHRyYSA6IGRlc2Nba2V5XSA6IGsgPiA0ID8gdm9pZCAwIDogeyBnZXQ6IGRlc2MuZ2V0LCBzZXQ6IGRlc2Muc2V0IH0gOiB0YXJnZXQsIGN0eCksIGRvbmUuXyA9IDE7XG4gICAgaWYgKGsgXiA0IHx8IGl0ID09PSB2b2lkIDApIF9fZXhwZWN0Rm4oaXQpICYmIChrID4gNCA/IGluaXRpYWxpemVycy51bnNoaWZ0KGl0KSA6IGsgPyBwID8gZXh0cmEgPSBpdCA6IGRlc2Nba2V5XSA9IGl0IDogdGFyZ2V0ID0gaXQpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBpdCAhPT0gXCJvYmplY3RcIiB8fCBpdCA9PT0gbnVsbCkgX190eXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgZWxzZSBfX2V4cGVjdEZuKGZuID0gaXQuZ2V0KSAmJiAoZGVzYy5nZXQgPSBmbiksIF9fZXhwZWN0Rm4oZm4gPSBpdC5zZXQpICYmIChkZXNjLnNldCA9IGZuKSwgX19leHBlY3RGbihmbiA9IGl0LmluaXQpICYmIGluaXRpYWxpemVycy51bnNoaWZ0KGZuKTtcbiAgfVxuICByZXR1cm4gayB8fCBfX2RlY29yYXRvck1ldGFkYXRhKGFycmF5LCB0YXJnZXQpLCBkZXNjICYmIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIGRlc2MpLCBwID8gayBeIDQgPyBleHRyYSA6IGRlc2MgOiB0YXJnZXQ7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4gbWVtYmVyLmhhcyhvYmopIHx8IF9fdHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbnZhciBfX3ByaXZhdGVJbiA9IChtZW1iZXIsIG9iaikgPT4gT2JqZWN0KG9iaikgIT09IG9iaiA/IF9fdHlwZUVycm9yKCdDYW5ub3QgdXNlIHRoZSBcImluXCIgb3BlcmF0b3Igb24gdGhpcyB2YWx1ZScpIDogbWVtYmVyLmhhcyhvYmopO1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSk7XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4gbWVtYmVyLmhhcyhvYmopID8gX190eXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLCBtZXRob2QpO1xuXG4vLyBzcmMvcG9pbnQvUG9pbnQudHNcbnZhciBQb2ludCA9IGNsYXNzIF9Qb2ludCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gQ29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgb24gdGhlIGhvcml6b250YWwgYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gQ29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgb24gdGhlIHZlcnRpY2FsIGF4aXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlbHRhIGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludH0gYSAtIEEgcG9pbnRcbiAgICogQHBhcmFtIHtQb2ludH0gYiAtIEFub3RoZXIgcG9pbnRcbiAgICovXG4gIHN0YXRpYyBkZWx0YShhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBfUG9pbnQoYS54IC0gYi54LCBhLnkgLSBiLnkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaHlwb3RlbnVzZSkgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1BvaW50fSBhIC0gQSBwb2ludFxuICAgKiBAcGFyYW0ge1BvaW50fSBiIC0gQW5vdGhlciBwb2ludFxuICAgKi9cbiAgc3RhdGljIGRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5oeXBvdChhLnggLSBiLngsIGEueSAtIGIueSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHBvaW50cyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnR9IGEgLSBBIHBvaW50XG4gICAqIEBwYXJhbSB7UG9pbnR9IGIgLSBBbm90aGVyIHBvaW50XG4gICAqL1xuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG4gIH1cbiAgc3RhdGljIGZyb20oeyB4LCB5IH0pIHtcbiAgICByZXR1cm4gbmV3IF9Qb2ludCh4LCB5KTtcbiAgfVxufTtcblxuLy8gc3JjL3NoYXBlcy9SZWN0YW5nbGUudHNcbnZhciBSZWN0YW5nbGUgPSBjbGFzcyBfUmVjdGFuZ2xlIHtcbiAgY29uc3RydWN0b3IobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zY2FsZSA9IHtcbiAgICAgIHg6IDEsXG4gICAgICB5OiAxXG4gICAgfTtcbiAgfVxuICBnZXQgaW52ZXJzZVNjYWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAxIC8gdGhpcy5zY2FsZS54LFxuICAgICAgeTogMSAvIHRoaXMuc2NhbGUueVxuICAgIH07XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCwgc2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3U2hhcGUgPSBuZXcgX1JlY3RhbmdsZShsZWZ0ICsgeCwgdG9wICsgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbmV3U2hhcGUuc2NhbGUgPSBfX3NwcmVhZFZhbHVlcyh7fSwgc2NhbGUpO1xuICAgIHJldHVybiBuZXdTaGFwZTtcbiAgfVxuICBnZXQgYm91bmRpbmdSZWN0YW5nbGUoKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20gfSA9IHRoaXM7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH07XG4gIH1cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICBjb25zdCB7IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFBvaW50KChsZWZ0ICsgcmlnaHQpIC8gMiwgKHRvcCArIGJvdHRvbSkgLyAyKTtcbiAgfVxuICBnZXQgYXJlYSgpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xuICB9XG4gIGVxdWFscyhzaGFwZSkge1xuICAgIGlmICghKHNoYXBlIGluc3RhbmNlb2YgX1JlY3RhbmdsZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGxlZnQgPT09IHNoYXBlLmxlZnQgJiYgdG9wID09PSBzaGFwZS50b3AgJiYgd2lkdGggPT09IHNoYXBlLndpZHRoICYmIGhlaWdodCA9PT0gc2hhcGUuaGVpZ2h0O1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9ID0gdGhpcztcbiAgICByZXR1cm4gdG9wIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBib3R0b20gJiYgbGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmlnaHQ7XG4gIH1cbiAgaW50ZXJzZWN0aW9uQXJlYShzaGFwZSkge1xuICAgIGlmIChzaGFwZSBpbnN0YW5jZW9mIF9SZWN0YW5nbGUpIHtcbiAgICAgIHJldHVybiByZWN0YW5nbGVSZWN0YW5nbGVJbnRlcnNlY3Rpb24odGhpcywgc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBpbnRlcnNlY3Rpb25SYXRpbyhzaGFwZSkge1xuICAgIGNvbnN0IHsgYXJlYSB9ID0gdGhpcztcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25BcmVhID0gdGhpcy5pbnRlcnNlY3Rpb25BcmVhKHNoYXBlKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25SYXRpbyA9IGludGVyc2VjdGlvbkFyZWEgLyAoc2hhcGUuYXJlYSArIGFyZWEgLSBpbnRlcnNlY3Rpb25BcmVhKTtcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uUmF0aW87XG4gIH1cbiAgZ2V0IGJvdHRvbSgpIHtcbiAgICBjb25zdCB7IHRvcCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgIHJldHVybiB0b3AgKyBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIGNvbnN0IHsgbGVmdCwgd2lkdGggfSA9IHRoaXM7XG4gICAgcmV0dXJuIGxlZnQgKyB3aWR0aDtcbiAgfVxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgIHJldHVybiB3aWR0aCAvIGhlaWdodDtcbiAgfVxuICBnZXQgY29ybmVycygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiB0aGlzLmxlZnQsIHk6IHRoaXMudG9wIH0sXG4gICAgICB7IHg6IHRoaXMucmlnaHQsIHk6IHRoaXMudG9wIH0sXG4gICAgICB7IHg6IHRoaXMubGVmdCwgeTogdGhpcy5ib3R0b20gfSxcbiAgICAgIHsgeDogdGhpcy5yaWdodCwgeTogdGhpcy5ib3R0b20gfVxuICAgIF07XG4gIH1cbiAgc3RhdGljIGZyb20oeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSkge1xuICAgIHJldHVybiBuZXcgX1JlY3RhbmdsZShsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHN0YXRpYyBkZWx0YShhLCBiLCBhbGlnbm1lbnQgPSB7IHg6IFwiY2VudGVyXCIsIHk6IFwiY2VudGVyXCIgfSkge1xuICAgIGNvbnN0IGdldENvb3JkaW5hdGUgPSAocmVjdCwgYXhpcykgPT4ge1xuICAgICAgY29uc3QgYWxpZ24gPSBhbGlnbm1lbnRbYXhpc107XG4gICAgICBjb25zdCBzdGFydCA9IGF4aXMgPT09IFwieFwiID8gcmVjdC5sZWZ0IDogcmVjdC50b3A7XG4gICAgICBjb25zdCBzaXplID0gYXhpcyA9PT0gXCJ4XCIgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQ7XG4gICAgICBpZiAoYWxpZ24gPT0gXCJzdGFydFwiKSByZXR1cm4gc3RhcnQ7XG4gICAgICBpZiAoYWxpZ24gPT0gXCJlbmRcIikgcmV0dXJuIHN0YXJ0ICsgc2l6ZTtcbiAgICAgIHJldHVybiBzdGFydCArIHNpemUgLyAyO1xuICAgIH07XG4gICAgcmV0dXJuIFBvaW50LmRlbHRhKFxuICAgICAgeyB4OiBnZXRDb29yZGluYXRlKGEsIFwieFwiKSwgeTogZ2V0Q29vcmRpbmF0ZShhLCBcInlcIikgfSxcbiAgICAgIHsgeDogZ2V0Q29vcmRpbmF0ZShiLCBcInhcIiksIHk6IGdldENvb3JkaW5hdGUoYiwgXCJ5XCIpIH1cbiAgICApO1xuICB9XG4gIHN0YXRpYyBpbnRlcnNlY3Rpb25SYXRpbyhhLCBiKSB7XG4gICAgcmV0dXJuIF9SZWN0YW5nbGUuZnJvbShhKS5pbnRlcnNlY3Rpb25SYXRpbyhfUmVjdGFuZ2xlLmZyb20oYikpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVjdGFuZ2xlUmVjdGFuZ2xlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgY29uc3QgdG9wID0gTWF0aC5tYXgoYi50b3AsIGEudG9wKTtcbiAgY29uc3QgbGVmdCA9IE1hdGgubWF4KGIubGVmdCwgYS5sZWZ0KTtcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1pbihiLmxlZnQgKyBiLndpZHRoLCBhLmxlZnQgKyBhLndpZHRoKTtcbiAgY29uc3QgYm90dG9tID0gTWF0aC5taW4oYi50b3AgKyBiLmhlaWdodCwgYS50b3AgKyBhLmhlaWdodCk7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uQXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICAgIHJldHVybiBpbnRlcnNlY3Rpb25BcmVhO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBzcmMvcG9zaXRpb24vcG9zaXRpb24udHNcbmltcG9ydCB7IGJhdGNoLCBkZXJpdmVkLCBWYWx1ZUhpc3RvcnkgfSBmcm9tIFwiQGRuZC1raXQvc3RhdGVcIjtcbnZhciBfZGlyZWN0aW9uX2RlYywgX2RlbHRhX2RlYywgX2EsIF90aW1lc3RhbXAsIF9pbml0O1xudmFyIFBvc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyAoX2EgPSBWYWx1ZUhpc3RvcnksIF9kZWx0YV9kZWMgPSBbZGVyaXZlZF0sIF9kaXJlY3Rpb25fZGVjID0gW2Rlcml2ZWRdLCBfYSkge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUpIHtcbiAgICBjb25zdCBwb2ludCA9IFBvaW50LmZyb20oaW5pdGlhbFZhbHVlKTtcbiAgICBzdXBlcihwb2ludCwgKGEsIGIpID0+IFBvaW50LmVxdWFscyhhLCBiKSk7XG4gICAgX19ydW5Jbml0aWFsaXplcnMoX2luaXQsIDUsIHRoaXMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdGltZXN0YW1wLCAwKTtcbiAgICB0aGlzLnZlbG9jaXR5ID0geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgZ2V0IGRlbHRhKCkge1xuICAgIHJldHVybiBQb2ludC5kZWx0YSh0aGlzLmN1cnJlbnQsIHRoaXMuaW5pdGlhbCk7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICBjb25zdCB7IGN1cnJlbnQsIHByZXZpb3VzIH0gPSB0aGlzO1xuICAgIGlmICghcHJldmlvdXMpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgeDogY3VycmVudC54IC0gcHJldmlvdXMueCxcbiAgICAgIHk6IGN1cnJlbnQueSAtIHByZXZpb3VzLnlcbiAgICB9O1xuICAgIGlmICghZGVsdGEueCAmJiAhZGVsdGEueSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhkZWx0YS54KSA+IE1hdGguYWJzKGRlbHRhLnkpKSB7XG4gICAgICByZXR1cm4gZGVsdGEueCA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhLnkgPiAwID8gXCJkb3duXCIgOiBcInVwXCI7XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmN1cnJlbnQ7XG4gIH1cbiAgc2V0IGN1cnJlbnQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHRoaXM7XG4gICAgY29uc3QgcG9pbnQgPSBQb2ludC5mcm9tKGNvb3JkaW5hdGVzKTtcbiAgICBjb25zdCBkZWx0YSA9IHtcbiAgICAgIHg6IHBvaW50LnggLSBjdXJyZW50LngsXG4gICAgICB5OiBwb2ludC55IC0gY3VycmVudC55XG4gICAgfTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVEZWx0YSA9IHRpbWVzdGFtcCAtIF9fcHJpdmF0ZUdldCh0aGlzLCBfdGltZXN0YW1wKTtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IChkZWx0YTIpID0+IE1hdGgucm91bmQoZGVsdGEyIC8gdGltZURlbHRhICogMTAwKTtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3RpbWVzdGFtcCwgdGltZXN0YW1wKTtcbiAgICAgIHRoaXMudmVsb2NpdHkgPSB7XG4gICAgICAgIHg6IHZlbG9jaXR5KGRlbHRhLngpLFxuICAgICAgICB5OiB2ZWxvY2l0eShkZWx0YS55KVxuICAgICAgfTtcbiAgICAgIHN1cGVyLmN1cnJlbnQgPSBwb2ludDtcbiAgICB9KTtcbiAgfVxuICByZXNldChjb29yZGluYXRlcyA9IHRoaXMuZGVmYXVsdFZhbHVlKSB7XG4gICAgc3VwZXIucmVzZXQoUG9pbnQuZnJvbShjb29yZGluYXRlcykpO1xuICAgIHRoaXMudmVsb2NpdHkgPSB7IHg6IDAsIHk6IDAgfTtcbiAgfVxufTtcbl9pbml0ID0gX19kZWNvcmF0b3JTdGFydChfYSk7XG5fdGltZXN0YW1wID0gbmV3IFdlYWtNYXAoKTtcbl9fZGVjb3JhdGVFbGVtZW50KF9pbml0LCAyLCBcImRlbHRhXCIsIF9kZWx0YV9kZWMsIFBvc2l0aW9uKTtcbl9fZGVjb3JhdGVFbGVtZW50KF9pbml0LCAyLCBcImRpcmVjdGlvblwiLCBfZGlyZWN0aW9uX2RlYywgUG9zaXRpb24pO1xuX19kZWNvcmF0b3JNZXRhZGF0YShfaW5pdCwgUG9zaXRpb24pO1xuXG4vLyBzcmMvZGlzdGFuY2UvZGlzdGFuY2UudHNcbmZ1bmN0aW9uIGV4Y2VlZHNEaXN0YW5jZSh7IHgsIHkgfSwgZGlzdGFuY2UpIHtcbiAgY29uc3QgZHggPSBNYXRoLmFicyh4KTtcbiAgY29uc3QgZHkgPSBNYXRoLmFicyh5KTtcbiAgaWYgKHR5cGVvZiBkaXN0YW5jZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoX19wb3coZHgsIDIpICsgX19wb3coZHksIDIpKSA+IGRpc3RhbmNlO1xuICB9XG4gIGlmIChcInhcIiBpbiBkaXN0YW5jZSAmJiBcInlcIiBpbiBkaXN0YW5jZSkge1xuICAgIHJldHVybiBkeCA+IGRpc3RhbmNlLnggJiYgZHkgPiBkaXN0YW5jZS55O1xuICB9XG4gIGlmIChcInhcIiBpbiBkaXN0YW5jZSkge1xuICAgIHJldHVybiBkeCA+IGRpc3RhbmNlLng7XG4gIH1cbiAgaWYgKFwieVwiIGluIGRpc3RhbmNlKSB7XG4gICAgcmV0dXJuIGR5ID4gZGlzdGFuY2UueTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy90eXBlcy9heGlzLnRzXG52YXIgQXhpcyA9IC8qIEBfX1BVUkVfXyAqLyAoKEF4aXMyKSA9PiB7XG4gIEF4aXMyW1wiSG9yaXpvbnRhbFwiXSA9IFwieFwiO1xuICBBeGlzMltcIlZlcnRpY2FsXCJdID0gXCJ5XCI7XG4gIHJldHVybiBBeGlzMjtcbn0pKEF4aXMgfHwge30pO1xudmFyIEF4ZXMgPSBPYmplY3QudmFsdWVzKEF4aXMpO1xuZXhwb3J0IHtcbiAgQXhlcyxcbiAgQXhpcyxcbiAgUG9pbnQsXG4gIFBvc2l0aW9uLFxuICBSZWN0YW5nbGUsXG4gIGV4Y2VlZHNEaXN0YW5jZVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@dnd-kit+geometry@0.1.21/node_modules/@dnd-kit/geometry/dist/index.mjs\n");

/***/ })

};
;