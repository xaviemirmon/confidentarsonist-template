"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dnd-kit+dom@0.1.21";
exports.ids = ["vendor-chunks/@dnd-kit+dom@0.1.21"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Accessibility: () => (/* binding */ Accessibility),\n/* harmony export */   AutoScroller: () => (/* binding */ AutoScroller),\n/* harmony export */   Cursor: () => (/* binding */ Cursor),\n/* harmony export */   DragDropManager: () => (/* binding */ DragDropManager),\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   Droppable: () => (/* binding */ Droppable),\n/* harmony export */   Feedback: () => (/* binding */ Feedback),\n/* harmony export */   KeyboardSensor: () => (/* binding */ KeyboardSensor),\n/* harmony export */   PointerSensor: () => (/* binding */ PointerSensor),\n/* harmony export */   PreventSelection: () => (/* binding */ PreventSelection),\n/* harmony export */   ScrollListener: () => (/* binding */ ScrollListener),\n/* harmony export */   Scroller: () => (/* binding */ Scroller),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset)\n/* harmony export */ });\n/* harmony import */ var _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dnd-kit/abstract */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+abstract@0.1.21/node_modules/@dnd-kit/abstract/index.js\");\n/* harmony import */ var _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dnd-kit/dom/utilities */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/utilities.js\");\n/* harmony import */ var _dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/state */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+state@0.1.21/node_modules/@dnd-kit/state/dist/index.mjs\");\n/* harmony import */ var _dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dnd-kit/state */ \"(ssr)/./node_modules/.pnpm/@preact+signals-core@1.12.1/node_modules/@preact/signals-core/dist/signals-core.mjs\");\n/* harmony import */ var _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dnd-kit/geometry */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+geometry@0.1.21/node_modules/@dnd-kit/geometry/dist/index.mjs\");\n/* harmony import */ var _dnd_kit_collision__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dnd-kit/collision */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+collision@0.1.21/node_modules/@dnd-kit/collision/dist/index.js\");\n\n\n\n\n\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __decoratorStart = (base) => {\n  var _a4;\n  return [, , , __create((_a4 = base == null ? void 0 : base[__knownSymbol(\"metadata\")]) != null ? _a4 : null)];\n};\nvar __decoratorStrings = [\"class\", \"method\", \"getter\", \"setter\", \"accessor\", \"field\", \"value\", \"get\", \"set\"];\nvar __expectFn = (fn) => fn !== void 0 && typeof fn !== \"function\" ? __typeError(\"Function expected\") : fn;\nvar __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError(\"Already initialized\") : fns.push(__expectFn(fn || null)) });\nvar __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol(\"metadata\"), array[3]);\nvar __runInitializers = (array, flags, self, value) => {\n  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);\n  return value;\n};\nvar __decorateElement = (array, flags, name, decorators, target, extra) => {\n  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);\n  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];\n  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);\n  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {\n    return __privateGet(this, extra);\n  }, set [name](x) {\n    return __privateSet(this, extra, x);\n  } }, name));\n  k ? p && k < 4 && __name(extra, (k > 2 ? \"set \" : k > 1 ? \"get \" : \"\") + name) : __name(target, name);\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);\n    if (k) {\n      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };\n      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];\n      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;\n    }\n    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;\n    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);\n    else if (typeof it !== \"object\" || it === null) __typeError(\"Object expected\");\n    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);\n  }\n  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the \"in\" operator on this value') : member.has(obj);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/core/plugins/accessibility/defaults.ts\nvar defaultAttributes = {\n  role: \"button\",\n  roleDescription: \"draggable\"};\nvar defaultDescriptionIdPrefix = `dnd-kit-description`;\nvar defaultAnnouncementIdPrefix = `dnd-kit-announcement`;\nvar defaultScreenReaderInstructions = {\n  draggable: `To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item in a given direction. Press space again to drop the item in its new position, or press escape to cancel.`\n};\nvar defaultAnnouncements = {\n  dragstart({ operation: { source } }) {\n    if (!source) return;\n    return `Picked up draggable item ${source.id}.`;\n  },\n  dragover({ operation: { source, target } }) {\n    if (!source || source.id === (target == null ? void 0 : target.id)) return;\n    if (target) {\n      return `Draggable item ${source.id} was moved over droppable target ${target.id}.`;\n    }\n    return `Draggable item ${source.id} is no longer over a droppable target.`;\n  },\n  dragend({ operation: { source, target }, canceled }) {\n    if (!source) return;\n    if (canceled) {\n      return `Dragging was cancelled. Draggable item ${source.id} was dropped.`;\n    }\n    if (target) {\n      return `Draggable item ${source.id} was dropped over droppable target ${target.id}`;\n    }\n    return `Draggable item ${source.id} was dropped.`;\n  }\n};\n\n// src/core/plugins/accessibility/utilities.ts\nfunction isFocusable(element) {\n  const tagName = element.tagName.toLowerCase();\n  return [\"input\", \"select\", \"textarea\", \"a\", \"button\"].includes(tagName);\n}\n\n// src/core/plugins/accessibility/HiddenText.ts\nfunction createHiddenText(id, value) {\n  const element = document.createElement(\"div\");\n  element.id = id;\n  element.style.setProperty(\"display\", \"none\");\n  element.textContent = value;\n  return element;\n}\n\n// src/core/plugins/accessibility/LiveRegion.ts\nfunction createLiveRegion(id) {\n  const element = document.createElement(\"div\");\n  element.id = id;\n  element.setAttribute(\"role\", \"status\");\n  element.setAttribute(\"aria-live\", \"polite\");\n  element.setAttribute(\"aria-atomic\", \"true\");\n  element.style.setProperty(\"position\", \"fixed\");\n  element.style.setProperty(\"width\", \"1px\");\n  element.style.setProperty(\"height\", \"1px\");\n  element.style.setProperty(\"margin\", \"-1px\");\n  element.style.setProperty(\"border\", \"0\");\n  element.style.setProperty(\"padding\", \"0\");\n  element.style.setProperty(\"overflow\", \"hidden\");\n  element.style.setProperty(\"clip\", \"rect(0 0 0 0)\");\n  element.style.setProperty(\"clip-path\", \"inset(100%)\");\n  element.style.setProperty(\"white-space\", \"nowrap\");\n  return element;\n}\n\n// src/core/plugins/accessibility/Accessibility.ts\nvar debouncedEvents = [\"dragover\", \"dragmove\"];\nvar Accessibility = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(manager, options) {\n    super(manager);\n    const {\n      id,\n      idPrefix: {\n        description: descriptionPrefix = defaultDescriptionIdPrefix,\n        announcement: announcementPrefix = defaultAnnouncementIdPrefix\n      } = {},\n      announcements = defaultAnnouncements,\n      screenReaderInstructions = defaultScreenReaderInstructions,\n      debounce: debounceMs = 500\n    } = options != null ? options : {};\n    const descriptionId = id ? `${descriptionPrefix}-${id}` : (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.generateUniqueId)(descriptionPrefix);\n    const announcementId = id ? `${announcementPrefix}-${id}` : (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.generateUniqueId)(announcementPrefix);\n    let hiddenTextElement;\n    let liveRegionElement;\n    let liveRegionTextNode;\n    let latestAnnouncement;\n    const updateAnnouncement = (value = latestAnnouncement) => {\n      if (!liveRegionTextNode || !value) return;\n      if ((liveRegionTextNode == null ? void 0 : liveRegionTextNode.nodeValue) !== value) {\n        liveRegionTextNode.nodeValue = value;\n      }\n    };\n    const scheduleUpdateAnnouncement = () => _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.scheduler.schedule(updateAnnouncement);\n    const debouncedUpdateAnnouncement = debounce(\n      scheduleUpdateAnnouncement,\n      debounceMs\n    );\n    const eventListeners = Object.entries(announcements).map(\n      ([eventName, getAnnouncement]) => {\n        return this.manager.monitor.addEventListener(\n          eventName,\n          (event, manager2) => {\n            const element = liveRegionTextNode;\n            if (!element) return;\n            const announcement = getAnnouncement == null ? void 0 : getAnnouncement(event, manager2);\n            if (announcement && element.nodeValue !== announcement) {\n              latestAnnouncement = announcement;\n              if (debouncedEvents.includes(eventName)) {\n                debouncedUpdateAnnouncement();\n              } else {\n                scheduleUpdateAnnouncement();\n                debouncedUpdateAnnouncement.cancel();\n              }\n            }\n          }\n        );\n      }\n    );\n    const initialize = () => {\n      let elements = [];\n      if (!(hiddenTextElement == null ? void 0 : hiddenTextElement.isConnected)) {\n        hiddenTextElement = createHiddenText(\n          descriptionId,\n          screenReaderInstructions.draggable\n        );\n        elements.push(hiddenTextElement);\n      }\n      if (!(liveRegionElement == null ? void 0 : liveRegionElement.isConnected)) {\n        liveRegionElement = createLiveRegion(announcementId);\n        liveRegionTextNode = document.createTextNode(\"\");\n        liveRegionElement.appendChild(liveRegionTextNode);\n        elements.push(liveRegionElement);\n      }\n      if (elements.length > 0) {\n        document.body.append(...elements);\n      }\n    };\n    const mutations = /* @__PURE__ */ new Set();\n    function executeMutations() {\n      for (const operation of mutations) {\n        operation();\n      }\n    }\n    this.registerEffect(() => {\n      var _a4;\n      mutations.clear();\n      for (const draggable of this.manager.registry.draggables.value) {\n        const activator = (_a4 = draggable.handle) != null ? _a4 : draggable.element;\n        if (activator) {\n          if (!hiddenTextElement || !liveRegionElement) {\n            mutations.add(initialize);\n          }\n          if ((!isFocusable(activator) || (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isSafari)()) && !activator.hasAttribute(\"tabindex\")) {\n            mutations.add(() => activator.setAttribute(\"tabindex\", \"0\"));\n          }\n          if (!activator.hasAttribute(\"role\") && !(activator.tagName.toLowerCase() === \"button\")) {\n            mutations.add(\n              () => activator.setAttribute(\"role\", defaultAttributes.role)\n            );\n          }\n          if (!activator.hasAttribute(\"aria-roledescription\")) {\n            mutations.add(\n              () => activator.setAttribute(\n                \"aria-roledescription\",\n                defaultAttributes.roleDescription\n              )\n            );\n          }\n          if (!activator.hasAttribute(\"aria-describedby\")) {\n            mutations.add(\n              () => activator.setAttribute(\"aria-describedby\", descriptionId)\n            );\n          }\n          for (const key of [\"aria-pressed\", \"aria-grabbed\"]) {\n            const value = String(draggable.isDragging);\n            if (activator.getAttribute(key) !== value) {\n              mutations.add(() => activator.setAttribute(key, value));\n            }\n          }\n          const disabled = String(draggable.disabled);\n          if (activator.getAttribute(\"aria-disabled\") !== disabled) {\n            mutations.add(\n              () => activator.setAttribute(\"aria-disabled\", disabled)\n            );\n          }\n        }\n      }\n      if (mutations.size > 0) {\n        _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.scheduler.schedule(executeMutations);\n      }\n    });\n    this.destroy = () => {\n      super.destroy();\n      hiddenTextElement == null ? void 0 : hiddenTextElement.remove();\n      liveRegionElement == null ? void 0 : liveRegionElement.remove();\n      eventListeners.forEach((unsubscribe) => unsubscribe());\n    };\n  }\n};\nfunction debounce(fn, wait) {\n  let timeout;\n  const debounced = () => {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, wait);\n  };\n  debounced.cancel = () => clearTimeout(timeout);\n  return debounced;\n}\nvar Cursor = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(manager, options) {\n    super(manager, options);\n    this.manager = manager;\n    const doc = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.computed)(\n      () => {\n        var _a4;\n        return (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)((_a4 = this.manager.dragOperation.source) == null ? void 0 : _a4.element);\n      }\n    );\n    this.destroy = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.effect)(() => {\n      var _a4;\n      const { dragOperation } = this.manager;\n      const { cursor = \"grabbing\", nonce } = (_a4 = this.options) != null ? _a4 : {};\n      if (dragOperation.status.initialized) {\n        const document2 = doc.value;\n        const style = document2.createElement(\"style\");\n        if (nonce) {\n          style.setAttribute(\"nonce\", nonce);\n        }\n        style.textContent = `* { cursor: ${cursor} !important; }`;\n        document2.head.appendChild(style);\n        return () => style.remove();\n      }\n    });\n  }\n};\n\n// src/core/plugins/feedback/constants.ts\nvar ATTR_PREFIX = \"data-dnd-\";\nvar DROPPING_ATTRIBUTE = `${ATTR_PREFIX}dropping`;\nvar CSS_PREFIX = \"--dnd-\";\nvar ATTRIBUTE = `${ATTR_PREFIX}dragging`;\nvar PLACEHOLDER_ATTRIBUTE = `${ATTR_PREFIX}placeholder`;\nvar IGNORED_ATTRIBUTES = [\n  ATTRIBUTE,\n  PLACEHOLDER_ATTRIBUTE,\n  \"popover\",\n  \"aria-pressed\",\n  \"aria-grabbing\"\n];\nvar IGNORED_STYLES = [\"view-transition-name\"];\nvar CSS_RULES = `\n  :root [${ATTRIBUTE}] {\n    position: fixed !important;\n    pointer-events: none !important;\n    touch-action: none;\n    z-index: calc(infinity);\n    will-change: translate;\n    top: var(${CSS_PREFIX}top, 0px) !important;\n    left: var(${CSS_PREFIX}left, 0px) !important;\n    right: unset !important;\n    bottom: unset !important;\n    width: var(${CSS_PREFIX}width, auto);\n    max-width: var(${CSS_PREFIX}width, auto);\n    height: var(${CSS_PREFIX}height, auto);\n    max-height: var(${CSS_PREFIX}height, auto);\n    transition: var(${CSS_PREFIX}transition) !important;\n  }\n\n  :root [${PLACEHOLDER_ATTRIBUTE}] {\n    transition: none;\n  }\n\n  :root [${PLACEHOLDER_ATTRIBUTE}='hidden'] {\n    visibility: hidden;\n  }\n\n  [${ATTRIBUTE}] * {\n    pointer-events: none !important;\n  }\n\n  [${ATTRIBUTE}]:not([${DROPPING_ATTRIBUTE}]) {\n    translate: var(${CSS_PREFIX}translate) !important;\n  }\n\n  [${ATTRIBUTE}][style*='${CSS_PREFIX}scale'] {\n    scale: var(${CSS_PREFIX}scale) !important;\n    transform-origin: var(${CSS_PREFIX}transform-origin) !important;\n  }\n\n  @layer {\n    :where([${ATTRIBUTE}][popover]) {\n      overflow: visible;\n      background: unset;\n      border: unset;\n      margin: unset;\n      padding: unset;\n      color: inherit;\n\n      &:is(input, button) {\n        border: revert;\n        background: revert;\n      }\n    }\n  }\n  [${ATTRIBUTE}]::backdrop, [${ATTR_PREFIX}overlay]:not([${ATTRIBUTE}]) {\n    display: none;\n    visibility: hidden;\n  }\n`.replace(/\\n+/g, \" \").replace(/\\s+/g, \" \").trim();\nfunction createPlaceholder(source, type = \"hidden\") {\n  return (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => {\n    const { element, manager } = source;\n    if (!element || !manager) return;\n    const containedDroppables = findContainedDroppables(\n      element,\n      manager.registry.droppables\n    );\n    const cleanup = [];\n    const placeholder = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(element);\n    const { remove } = placeholder;\n    proxyDroppableElements(containedDroppables, placeholder, cleanup);\n    configurePlaceholder(placeholder, type);\n    placeholder.remove = () => {\n      cleanup.forEach((fn) => fn());\n      remove.call(placeholder);\n    };\n    return placeholder;\n  });\n}\nfunction findContainedDroppables(element, droppables) {\n  const containedDroppables = /* @__PURE__ */ new Map();\n  for (const droppable of droppables) {\n    if (!droppable.element) continue;\n    if (element === droppable.element || element.contains(droppable.element)) {\n      const identifierAttribute = `${ATTR_PREFIX}${(0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.generateUniqueId)(\"dom-id\")}`;\n      droppable.element.setAttribute(identifierAttribute, \"\");\n      containedDroppables.set(droppable, identifierAttribute);\n    }\n  }\n  return containedDroppables;\n}\nfunction proxyDroppableElements(containedDroppables, placeholder, cleanup) {\n  for (const [droppable, identifierAttribute] of containedDroppables) {\n    if (!droppable.element) continue;\n    const selector = `[${identifierAttribute}]`;\n    const clonedElement = placeholder.matches(selector) ? placeholder : placeholder.querySelector(selector);\n    droppable.element.removeAttribute(identifierAttribute);\n    if (!clonedElement) continue;\n    const originalElement = droppable.element;\n    droppable.proxy = clonedElement;\n    clonedElement.removeAttribute(identifierAttribute);\n    _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ProxiedElements.set(originalElement, clonedElement);\n    cleanup.push(() => {\n      _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ProxiedElements.delete(originalElement);\n      droppable.proxy = void 0;\n    });\n  }\n}\nfunction configurePlaceholder(placeholder, type = \"hidden\") {\n  placeholder.setAttribute(\"inert\", \"true\");\n  placeholder.setAttribute(\"tab-index\", \"-1\");\n  placeholder.setAttribute(\"aria-hidden\", \"true\");\n  placeholder.setAttribute(PLACEHOLDER_ATTRIBUTE, type);\n}\nfunction isSameFrame(element, target) {\n  if (element === target) return true;\n  return (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getFrameElement)(element) === (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getFrameElement)(target);\n}\nfunction preventPopoverClose(event) {\n  const { target } = event;\n  if (\"newState\" in event && event.newState === \"closed\" && (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isElement)(target) && target.hasAttribute(\"popover\")) {\n    requestAnimationFrame(() => (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.showPopover)(target));\n  }\n}\nfunction isTableRow(element) {\n  return element.tagName === \"TR\";\n}\n\n// src/core/plugins/feedback/Feedback.ts\nvar styleSheetRegistry = /* @__PURE__ */ new Map();\nvar _overlay_dec, _a, _init, _overlay, _Feedback_instances, render_fn, injectStyles_fn;\nvar _Feedback = class _Feedback extends (_a = _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin, _overlay_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _a) {\n  constructor(manager, options) {\n    super(manager, options);\n    __privateAdd(this, _Feedback_instances);\n    __privateAdd(this, _overlay, __runInitializers(_init, 8, this)), __runInitializers(_init, 11, this);\n    this.state = {\n      initial: {},\n      current: {}\n    };\n    this.registerEffect(__privateMethod(this, _Feedback_instances, injectStyles_fn));\n    this.registerEffect(__privateMethod(this, _Feedback_instances, render_fn));\n  }\n  destroy() {\n    super.destroy();\n    for (const [doc, registration] of styleSheetRegistry.entries()) {\n      if (registration.instances.has(this)) {\n        registration.instances.delete(this);\n        if (registration.instances.size === 0) {\n          registration.cleanup();\n          styleSheetRegistry.delete(doc);\n        }\n      }\n    }\n  }\n};\n_init = __decoratorStart(_a);\n_overlay = new WeakMap();\n_Feedback_instances = new WeakSet();\nrender_fn = function() {\n  var _a4, _b2, _c3;\n  const { state, manager, options } = this;\n  const { dragOperation } = manager;\n  const { position, source, status } = dragOperation;\n  if (status.idle) {\n    state.current = {};\n    state.initial = {};\n    return;\n  }\n  if (!source) return;\n  const { element, feedback } = source;\n  if (!element || feedback === \"none\" || !status.initialized || status.initializing) {\n    return;\n  }\n  const { initial } = state;\n  const feedbackElement = (_a4 = this.overlay) != null ? _a4 : element;\n  const frameTransform = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getFrameTransform)(feedbackElement);\n  const elementFrameTransform = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getFrameTransform)(element);\n  const crossFrame = !isSameFrame(element, feedbackElement);\n  const shape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(element, {\n    frameTransform: crossFrame ? elementFrameTransform : null,\n    ignoreTransforms: !crossFrame\n  });\n  const scaleDelta = {\n    x: elementFrameTransform.scaleX / frameTransform.scaleX,\n    y: elementFrameTransform.scaleY / frameTransform.scaleY\n  };\n  let { width, height, top, left } = shape;\n  if (crossFrame) {\n    width = width / scaleDelta.x;\n    height = height / scaleDelta.y;\n  }\n  let elementMutationObserver;\n  let documentMutationObserver;\n  const styles = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.Styles(feedbackElement);\n  const {\n    transition,\n    translate,\n    boxSizing,\n    paddingBlockStart,\n    paddingBlockEnd,\n    paddingInlineStart,\n    paddingInlineEnd,\n    borderInlineStartWidth,\n    borderInlineEndWidth,\n    borderBlockStartWidth,\n    borderBlockEndWidth\n  } = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getComputedStyles)(element);\n  const clone = feedback === \"clone\";\n  const contentBox = boxSizing === \"content-box\";\n  const widthOffset = contentBox ? parseInt(paddingInlineStart) + parseInt(paddingInlineEnd) + parseInt(borderInlineStartWidth) + parseInt(borderInlineEndWidth) : 0;\n  const heightOffset = contentBox ? parseInt(paddingBlockStart) + parseInt(paddingBlockEnd) + parseInt(borderBlockStartWidth) + parseInt(borderBlockEndWidth) : 0;\n  const placeholder = feedback !== \"move\" && !this.overlay ? createPlaceholder(source, clone ? \"clone\" : \"hidden\") : null;\n  const isKeyboardOperation = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(\n    () => (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isKeyboardEvent)(manager.dragOperation.activatorEvent)\n  );\n  if (translate !== \"none\") {\n    const parsedTranslate = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.parseTranslate)(translate);\n    if (parsedTranslate && !initial.translate) {\n      initial.translate = parsedTranslate;\n    }\n  }\n  if (!initial.transformOrigin) {\n    const current = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => position.current);\n    initial.transformOrigin = {\n      x: (current.x - left * frameTransform.scaleX - frameTransform.x) / (width * frameTransform.scaleX),\n      y: (current.y - top * frameTransform.scaleY - frameTransform.y) / (height * frameTransform.scaleY)\n    };\n  }\n  const { transformOrigin } = initial;\n  const relativeTop = top * frameTransform.scaleY + frameTransform.y;\n  const relativeLeft = left * frameTransform.scaleX + frameTransform.x;\n  if (!initial.coordinates) {\n    initial.coordinates = {\n      x: relativeLeft,\n      y: relativeTop\n    };\n    if (scaleDelta.x !== 1 || scaleDelta.y !== 1) {\n      const { scaleX, scaleY } = elementFrameTransform;\n      const { x: tX2, y: tY2 } = transformOrigin;\n      initial.coordinates.x += (width * scaleX - width) * tX2;\n      initial.coordinates.y += (height * scaleY - height) * tY2;\n    }\n  }\n  if (!initial.dimensions) {\n    initial.dimensions = { width, height };\n  }\n  if (!initial.frameTransform) {\n    initial.frameTransform = frameTransform;\n  }\n  const coordinatesDelta = {\n    x: initial.coordinates.x - relativeLeft,\n    y: initial.coordinates.y - relativeTop\n  };\n  const sizeDelta = {\n    width: (initial.dimensions.width * initial.frameTransform.scaleX - width * frameTransform.scaleX) * transformOrigin.x,\n    height: (initial.dimensions.height * initial.frameTransform.scaleY - height * frameTransform.scaleY) * transformOrigin.y\n  };\n  const delta = {\n    x: coordinatesDelta.x / frameTransform.scaleX + sizeDelta.width,\n    y: coordinatesDelta.y / frameTransform.scaleY + sizeDelta.height\n  };\n  const projected = {\n    left: left + delta.x,\n    top: top + delta.y\n  };\n  feedbackElement.setAttribute(ATTRIBUTE, \"true\");\n  const transform = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => dragOperation.transform);\n  const initialTranslate = (_b2 = initial.translate) != null ? _b2 : { x: 0, y: 0 };\n  const tX = transform.x * frameTransform.scaleX + initialTranslate.x;\n  const tY = transform.y * frameTransform.scaleY + initialTranslate.y;\n  const translateString = `${tX}px ${tY}px 0`;\n  const transitionString = transition ? `${transition}, translate 0ms linear` : \"\";\n  styles.set(\n    {\n      width: width - widthOffset,\n      height: height - heightOffset,\n      top: projected.top,\n      left: projected.left,\n      translate: translateString,\n      transition: transitionString,\n      scale: crossFrame ? `${scaleDelta.x} ${scaleDelta.y}` : \"\",\n      \"transform-origin\": `${transformOrigin.x * 100}% ${transformOrigin.y * 100}%`\n    },\n    CSS_PREFIX\n  );\n  if (placeholder) {\n    element.insertAdjacentElement(\"afterend\", placeholder);\n    if (options == null ? void 0 : options.rootElement) {\n      const root = typeof options.rootElement === \"function\" ? options.rootElement(source) : options.rootElement;\n      root.appendChild(element);\n    }\n  }\n  if ((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.supportsPopover)(feedbackElement)) {\n    if (!feedbackElement.hasAttribute(\"popover\")) {\n      feedbackElement.setAttribute(\"popover\", \"manual\");\n    }\n    (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.showPopover)(feedbackElement);\n    feedbackElement.addEventListener(\"beforetoggle\", preventPopoverClose);\n  }\n  const resizeObserver = new ResizeObserver(() => {\n    if (!placeholder) return;\n    const placeholderShape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(placeholder, {\n      frameTransform,\n      ignoreTransforms: true\n    });\n    const origin = transformOrigin != null ? transformOrigin : { x: 1, y: 1 };\n    const dX = (width - placeholderShape.width) * origin.x + delta.x;\n    const dY = (height - placeholderShape.height) * origin.y + delta.y;\n    styles.set(\n      {\n        width: placeholderShape.width - widthOffset,\n        height: placeholderShape.height - heightOffset,\n        top: top + dY,\n        left: left + dX\n      },\n      CSS_PREFIX\n    );\n    elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();\n    if (isTableRow(element) && isTableRow(placeholder)) {\n      const cells = Array.from(element.cells);\n      const placeholderCells = Array.from(placeholder.cells);\n      for (const [index, cell] of cells.entries()) {\n        const placeholderCell = placeholderCells[index];\n        cell.style.width = `${placeholderCell.offsetWidth}px`;\n      }\n    }\n    dragOperation.shape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(feedbackElement);\n  });\n  const initialShape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(feedbackElement);\n  (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => dragOperation.shape = initialShape);\n  const feedbackWindow = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getWindow)(feedbackElement);\n  const handleWindowResize = (event) => {\n    this.manager.actions.stop({ event });\n  };\n  if (isKeyboardOperation) {\n    feedbackWindow.addEventListener(\"resize\", handleWindowResize);\n  }\n  if ((0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => source.status) === \"idle\") {\n    requestAnimationFrame(() => source.status = \"dragging\");\n  }\n  if (placeholder) {\n    resizeObserver.observe(placeholder);\n    elementMutationObserver = new MutationObserver((mutations) => {\n      let hasChildrenMutations = false;\n      for (const mutation of mutations) {\n        if (mutation.target !== element) {\n          hasChildrenMutations = true;\n          continue;\n        }\n        if (mutation.type !== \"attributes\") {\n          continue;\n        }\n        const attributeName = mutation.attributeName;\n        if (attributeName.startsWith(\"aria-\") || IGNORED_ATTRIBUTES.includes(attributeName)) {\n          continue;\n        }\n        const attributeValue = element.getAttribute(attributeName);\n        if (attributeName === \"style\") {\n          if ((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.supportsStyle)(element) && (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.supportsStyle)(placeholder)) {\n            const styles2 = element.style;\n            for (const key of Array.from(placeholder.style)) {\n              if (styles2.getPropertyValue(key) === \"\") {\n                placeholder.style.removeProperty(key);\n              }\n            }\n            for (const key of Array.from(styles2)) {\n              if (IGNORED_STYLES.includes(key) || key.startsWith(CSS_PREFIX)) {\n                continue;\n              }\n              const value = styles2.getPropertyValue(key);\n              placeholder.style.setProperty(key, value);\n            }\n          }\n        } else if (attributeValue !== null) {\n          placeholder.setAttribute(attributeName, attributeValue);\n        } else {\n          placeholder.removeAttribute(attributeName);\n        }\n      }\n      if (hasChildrenMutations && clone) {\n        placeholder.innerHTML = element.innerHTML;\n      }\n    });\n    elementMutationObserver.observe(element, {\n      attributes: true,\n      subtree: true,\n      childList: true\n    });\n    documentMutationObserver = new MutationObserver((entries) => {\n      for (const entry of entries) {\n        if (entry.addedNodes.length === 0) continue;\n        for (const node of Array.from(entry.addedNodes)) {\n          if (node.contains(element) && element.nextElementSibling !== placeholder) {\n            element.insertAdjacentElement(\"afterend\", placeholder);\n            (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.showPopover)(feedbackElement);\n            return;\n          }\n          if (node.contains(placeholder) && placeholder.previousElementSibling !== element) {\n            placeholder.insertAdjacentElement(\"beforebegin\", element);\n            (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.showPopover)(feedbackElement);\n            return;\n          }\n        }\n      }\n    });\n    documentMutationObserver.observe(element.ownerDocument.body, {\n      childList: true,\n      subtree: true\n    });\n  }\n  const id = (_c3 = manager.dragOperation.source) == null ? void 0 : _c3.id;\n  const restoreFocus = () => {\n    var _a5;\n    if (!isKeyboardOperation || id == null) {\n      return;\n    }\n    const draggable = manager.registry.draggables.get(id);\n    const element2 = (_a5 = draggable == null ? void 0 : draggable.handle) != null ? _a5 : draggable == null ? void 0 : draggable.element;\n    if ((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element2)) {\n      element2.focus();\n    }\n  };\n  const cleanup = () => {\n    elementMutationObserver == null ? void 0 : elementMutationObserver.disconnect();\n    documentMutationObserver == null ? void 0 : documentMutationObserver.disconnect();\n    resizeObserver.disconnect();\n    feedbackWindow.removeEventListener(\"resize\", handleWindowResize);\n    if ((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.supportsPopover)(feedbackElement)) {\n      feedbackElement.removeEventListener(\n        \"beforetoggle\",\n        preventPopoverClose\n      );\n      feedbackElement.removeAttribute(\"popover\");\n    }\n    feedbackElement.removeAttribute(ATTRIBUTE);\n    styles.reset();\n    source.status = \"idle\";\n    const moved = state.current.translate != null;\n    if (placeholder && (moved || placeholder.parentElement !== feedbackElement.parentElement) && feedbackElement.isConnected) {\n      placeholder.replaceWith(feedbackElement);\n    }\n    placeholder == null ? void 0 : placeholder.remove();\n  };\n  const cleanupEffects = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.effects)(\n    // Update transform on move\n    () => {\n      var _a5;\n      const { transform: transform2, status: status2 } = dragOperation;\n      if (!transform2.x && !transform2.y && !state.current.translate) {\n        return;\n      }\n      if (status2.dragging) {\n        const initialTranslate2 = (_a5 = initial.translate) != null ? _a5 : { x: 0, y: 0 };\n        const translate2 = {\n          x: transform2.x / frameTransform.scaleX + initialTranslate2.x,\n          y: transform2.y / frameTransform.scaleY + initialTranslate2.y\n        };\n        const previousTranslate = state.current.translate;\n        const modifiers = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => dragOperation.modifiers);\n        const currentShape = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => {\n          var _a6;\n          return (_a6 = dragOperation.shape) == null ? void 0 : _a6.current;\n        });\n        const translateTransition = isKeyboardOperation ? \"250ms cubic-bezier(0.25, 1, 0.5, 1)\" : \"0ms linear\";\n        styles.set(\n          {\n            transition: `${transition}, translate ${translateTransition}`,\n            translate: `${translate2.x}px ${translate2.y}px 0`\n          },\n          CSS_PREFIX\n        );\n        elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();\n        if (currentShape && currentShape !== initialShape && previousTranslate && !modifiers.length) {\n          const delta2 = _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.Point.delta(translate2, previousTranslate);\n          dragOperation.shape = _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.Rectangle.from(\n            currentShape.boundingRectangle\n          ).translate(\n            // Need to take into account frame transform when optimistically updating shape\n            delta2.x * frameTransform.scaleX,\n            delta2.y * frameTransform.scaleY\n          );\n        } else {\n          dragOperation.shape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(feedbackElement);\n        }\n        state.current.translate = translate2;\n      }\n    },\n    // Drop animation\n    function() {\n      if (dragOperation.status.dropped) {\n        this.dispose();\n        source.status = \"dropping\";\n        let translate2 = state.current.translate;\n        const moved = translate2 != null;\n        if (!translate2 && element !== feedbackElement) {\n          translate2 = {\n            x: 0,\n            y: 0\n          };\n        }\n        if (!translate2) {\n          cleanup();\n          return;\n        }\n        const dropAnimation = () => {\n          var _a5, _b3;\n          {\n            (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.showPopover)(feedbackElement);\n            const [, animation] = (_a5 = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getFinalKeyframe)(\n              feedbackElement,\n              (keyframe) => \"translate\" in keyframe\n            )) != null ? _a5 : [];\n            animation == null ? void 0 : animation.pause();\n            const target = placeholder != null ? placeholder : element;\n            const options2 = {\n              frameTransform: isSameFrame(feedbackElement, target) ? null : void 0\n            };\n            const current = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(feedbackElement, options2);\n            const currentTranslate = (_b3 = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.parseTranslate)((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getComputedStyles)(feedbackElement).translate)) != null ? _b3 : translate2;\n            const final = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(target, options2);\n            const delta2 = _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.Rectangle.delta(current, final, source.alignment);\n            const finalTranslate = {\n              x: currentTranslate.x - delta2.x,\n              y: currentTranslate.y - delta2.y\n            };\n            const heightKeyframes = Math.round(current.intrinsicHeight) !== Math.round(final.intrinsicHeight) ? {\n              minHeight: [\n                `${current.intrinsicHeight}px`,\n                `${final.intrinsicHeight}px`\n              ],\n              maxHeight: [\n                `${current.intrinsicHeight}px`,\n                `${final.intrinsicHeight}px`\n              ]\n            } : {};\n            const widthKeyframes = Math.round(current.intrinsicWidth) !== Math.round(final.intrinsicWidth) ? {\n              minWidth: [\n                `${current.intrinsicWidth}px`,\n                `${final.intrinsicWidth}px`\n              ],\n              maxWidth: [\n                `${current.intrinsicWidth}px`,\n                `${final.intrinsicWidth}px`\n              ]\n            } : {};\n            styles.set({ transition }, CSS_PREFIX);\n            feedbackElement.setAttribute(DROPPING_ATTRIBUTE, \"\");\n            elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();\n            (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.animateTransform)({\n              element: feedbackElement,\n              keyframes: __spreadProps(__spreadValues(__spreadValues({}, heightKeyframes), widthKeyframes), {\n                translate: [\n                  `${currentTranslate.x}px ${currentTranslate.y}px 0`,\n                  `${finalTranslate.x}px ${finalTranslate.y}px 0`\n                ]\n              }),\n              options: {\n                duration: moved || feedbackElement !== element ? 250 : 0,\n                easing: \"ease\"\n              }\n            }).then(() => {\n              feedbackElement.removeAttribute(DROPPING_ATTRIBUTE);\n              animation == null ? void 0 : animation.finish();\n              cleanup();\n              requestAnimationFrame(restoreFocus);\n            });\n          }\n        };\n        manager.renderer.rendering.then(dropAnimation);\n      }\n    }\n  );\n  return () => {\n    cleanup();\n    cleanupEffects();\n  };\n};\ninjectStyles_fn = function() {\n  var _a4, _b2, _c3;\n  const { status, source, target } = this.manager.dragOperation;\n  const { nonce } = (_a4 = this.options) != null ? _a4 : {};\n  if (status.initializing) {\n    const sourceDocument = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)((_b2 = source == null ? void 0 : source.element) != null ? _b2 : null);\n    const targetDocument = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)((_c3 = target == null ? void 0 : target.element) != null ? _c3 : null);\n    const documents = /* @__PURE__ */ new Set([sourceDocument, targetDocument]);\n    for (const doc of documents) {\n      let registration = styleSheetRegistry.get(doc);\n      if (!registration) {\n        const style = document.createElement(\"style\");\n        style.textContent = CSS_RULES;\n        if (nonce) {\n          style.setAttribute(\"nonce\", nonce);\n        }\n        doc.head.prepend(style);\n        const mutationObserver = new MutationObserver((entries) => {\n          for (const entry of entries) {\n            if (entry.type === \"childList\") {\n              const removedNodes = Array.from(entry.removedNodes);\n              if (removedNodes.length > 0 && removedNodes.includes(style)) {\n                doc.head.prepend(style);\n              }\n            }\n          }\n        });\n        mutationObserver.observe(doc.head, { childList: true });\n        registration = {\n          cleanup: () => {\n            mutationObserver.disconnect();\n            style.remove();\n          },\n          instances: /* @__PURE__ */ new Set()\n        };\n        styleSheetRegistry.set(doc, registration);\n      }\n      registration.instances.add(this);\n    }\n  }\n};\n__decorateElement(_init, 4, \"overlay\", _overlay_dec, _Feedback, _overlay);\n__decoratorMetadata(_init, _Feedback);\n_Feedback.configure = (0,_dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.configurator)(_Feedback);\nvar Feedback = _Feedback;\nvar LOCKED = true;\nvar UNLOCKED = false;\nvar _dec, _a2, _dec2, _b, _init2, __b, __a;\n_b = (_dec2 = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Forward), _a2 = (_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Reverse);\nvar ScrollLock = class {\n  constructor() {\n    __privateAdd(this, __b, __runInitializers(_init2, 8, this, LOCKED)), __runInitializers(_init2, 11, this);\n    __privateAdd(this, __a, __runInitializers(_init2, 12, this, LOCKED)), __runInitializers(_init2, 15, this);\n  }\n  isLocked(direction) {\n    if (direction === _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Idle) {\n      return false;\n    }\n    if (direction == null) {\n      return this[_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Forward] === LOCKED && this[_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Reverse] === LOCKED;\n    }\n    return this[direction] === LOCKED;\n  }\n  unlock(direction) {\n    if (direction === _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Idle) {\n      return;\n    }\n    this[direction] = UNLOCKED;\n  }\n};\n_init2 = __decoratorStart(null);\n__b = new WeakMap();\n__a = new WeakMap();\n__decorateElement(_init2, 4, _b, _dec2, ScrollLock, __b);\n__decorateElement(_init2, 4, _a2, _dec, ScrollLock, __a);\n__decoratorMetadata(_init2, ScrollLock);\n\n// src/core/plugins/scrolling/ScrollIntent.ts\nvar DIRECTIONS = [_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Forward, _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Reverse];\nvar ScrollIntent = class {\n  constructor() {\n    this.x = new ScrollLock();\n    this.y = new ScrollLock();\n  }\n  isLocked() {\n    return this.x.isLocked() && this.y.isLocked();\n  }\n};\nvar ScrollIntentTracker = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(manager) {\n    super(manager);\n    const scrollIntent = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.signal)(new ScrollIntent());\n    let previousDelta = null;\n    this.signal = scrollIntent;\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.effect)(() => {\n      const { status } = manager.dragOperation;\n      if (!status.initialized) {\n        previousDelta = null;\n        scrollIntent.value = new ScrollIntent();\n        return;\n      }\n      const { delta } = manager.dragOperation.position;\n      if (previousDelta) {\n        const directions = {\n          x: getDirection(delta.x, previousDelta.x),\n          y: getDirection(delta.y, previousDelta.y)\n        };\n        const intent = scrollIntent.peek();\n        (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.batch)(() => {\n          for (const axis of _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.Axes) {\n            for (const direction of DIRECTIONS) {\n              if (directions[axis] === direction) {\n                intent[axis].unlock(direction);\n              }\n            }\n          }\n          scrollIntent.value = intent;\n        });\n      }\n      previousDelta = delta;\n    });\n  }\n  get current() {\n    return this.signal.peek();\n  }\n};\nfunction getDirection(a, b) {\n  return Math.sign(a - b);\n}\n\n// src/core/plugins/scrolling/Scroller.ts\nvar _autoScrolling_dec, _a3, _init3, _autoScrolling, _meta, _scroll;\nvar Scroller = class extends (_a3 = _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.CorePlugin, _autoScrolling_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _a3) {\n  constructor(manager) {\n    super(manager);\n    __privateAdd(this, _autoScrolling, __runInitializers(_init3, 8, this, false)), __runInitializers(_init3, 11, this);\n    __privateAdd(this, _meta);\n    __privateAdd(this, _scroll, () => {\n      if (!__privateGet(this, _meta)) {\n        return;\n      }\n      const { element, by } = __privateGet(this, _meta);\n      if (by.y) element.scrollTop += by.y;\n      if (by.x) element.scrollLeft += by.x;\n    });\n    this.scroll = (options) => {\n      var _a4;\n      if (this.disabled) {\n        return false;\n      }\n      const elements = this.getScrollableElements();\n      if (!elements) {\n        __privateSet(this, _meta, void 0);\n        return false;\n      }\n      const { position } = this.manager.dragOperation;\n      const currentPosition = position == null ? void 0 : position.current;\n      if (currentPosition) {\n        const { by } = options != null ? options : {};\n        const intent = by ? {\n          x: getScrollIntent(by.x),\n          y: getScrollIntent(by.y)\n        } : void 0;\n        const scrollIntent = intent ? void 0 : this.scrollIntentTracker.current;\n        if (scrollIntent == null ? void 0 : scrollIntent.isLocked()) {\n          return false;\n        }\n        for (const scrollableElement of elements) {\n          const elementCanScroll = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.canScroll)(scrollableElement, by);\n          if (elementCanScroll.x || elementCanScroll.y) {\n            const { speed, direction } = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.detectScrollIntent)(\n              scrollableElement,\n              currentPosition,\n              intent\n            );\n            if (scrollIntent) {\n              for (const axis of _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.Axes) {\n                if (scrollIntent[axis].isLocked(direction[axis])) {\n                  speed[axis] = 0;\n                  direction[axis] = 0;\n                }\n              }\n            }\n            if (direction.x || direction.y) {\n              const { x, y } = by != null ? by : direction;\n              const scrollLeftBy = x * speed.x;\n              const scrollTopBy = y * speed.y;\n              if (scrollLeftBy || scrollTopBy) {\n                const previousScrollBy = (_a4 = __privateGet(this, _meta)) == null ? void 0 : _a4.by;\n                if (this.autoScrolling && previousScrollBy) {\n                  const scrollIntentMismatch = previousScrollBy.x && !scrollLeftBy || previousScrollBy.y && !scrollTopBy;\n                  if (scrollIntentMismatch) continue;\n                }\n                __privateSet(this, _meta, {\n                  element: scrollableElement,\n                  by: {\n                    x: scrollLeftBy,\n                    y: scrollTopBy\n                  }\n                });\n                _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.scheduler.schedule(__privateGet(this, _scroll));\n                return true;\n              }\n            }\n          }\n        }\n      }\n      __privateSet(this, _meta, void 0);\n      return false;\n    };\n    let previousElementFromPoint = null;\n    let previousScrollableElements = null;\n    const elementFromPoint = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.computed)(() => {\n      const { position, source } = manager.dragOperation;\n      if (!position) {\n        return null;\n      }\n      const element = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getElementFromPoint)(\n        (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)(source == null ? void 0 : source.element),\n        position.current\n      );\n      if (element) {\n        previousElementFromPoint = element;\n      }\n      return element != null ? element : previousElementFromPoint;\n    });\n    const scrollableElements = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.computed)(() => {\n      const element = elementFromPoint.value;\n      const { documentElement } = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)(element);\n      if (!element || element === documentElement) {\n        const { target } = manager.dragOperation;\n        const targetElement = target == null ? void 0 : target.element;\n        if (targetElement) {\n          const elements = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getScrollableAncestors)(targetElement, {\n            excludeElement: false\n          });\n          previousScrollableElements = elements;\n          return elements;\n        }\n      }\n      if (element) {\n        const elements = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getScrollableAncestors)(element, {\n          excludeElement: false\n        });\n        if (this.autoScrolling && previousScrollableElements && elements.size < (previousScrollableElements == null ? void 0 : previousScrollableElements.size)) {\n          return previousScrollableElements;\n        }\n        previousScrollableElements = elements;\n        return elements;\n      }\n      previousScrollableElements = null;\n      return null;\n    }, _dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.deepEqual);\n    this.getScrollableElements = () => {\n      return scrollableElements.value;\n    };\n    this.scrollIntentTracker = new ScrollIntentTracker(manager);\n    this.destroy = manager.monitor.addEventListener(\"dragmove\", (event) => {\n      if (this.disabled || event.defaultPrevented || !(0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isKeyboardEvent)(manager.dragOperation.activatorEvent) || !event.by) {\n        return;\n      }\n      if (this.scroll({ by: event.by })) {\n        event.preventDefault();\n      }\n    });\n  }\n};\n_init3 = __decoratorStart(_a3);\n_autoScrolling = new WeakMap();\n_meta = new WeakMap();\n_scroll = new WeakMap();\n__decorateElement(_init3, 4, \"autoScrolling\", _autoScrolling_dec, Scroller, _autoScrolling);\n__decoratorMetadata(_init3, Scroller);\nfunction getScrollIntent(value) {\n  if (value > 0) {\n    return _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Forward;\n  }\n  if (value < 0) {\n    return _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Reverse;\n  }\n  return _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.ScrollDirection.Idle;\n}\n\n// src/utilities/scheduling/scheduler.ts\nvar Scheduler = class {\n  constructor(scheduler5) {\n    this.scheduler = scheduler5;\n    this.pending = false;\n    this.tasks = /* @__PURE__ */ new Set();\n    this.resolvers = /* @__PURE__ */ new Set();\n    this.flush = () => {\n      const { tasks, resolvers } = this;\n      this.pending = false;\n      this.tasks = /* @__PURE__ */ new Set();\n      this.resolvers = /* @__PURE__ */ new Set();\n      for (const task of tasks) {\n        task();\n      }\n      for (const resolve of resolvers) {\n        resolve();\n      }\n    };\n  }\n  schedule(task) {\n    this.tasks.add(task);\n    if (!this.pending) {\n      this.pending = true;\n      this.scheduler(this.flush);\n    }\n    return new Promise((resolve) => this.resolvers.add(resolve));\n  }\n};\nvar scheduler3 = new Scheduler((callback) => {\n  if (typeof requestAnimationFrame === \"function\") {\n    requestAnimationFrame(callback);\n  } else {\n    callback();\n  }\n});\n\n// src/core/plugins/scrolling/AutoScroller.ts\nvar AUTOSCROLL_INTERVAL = 10;\nvar AutoScroller = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(manager, _options) {\n    super(manager);\n    const scroller = manager.registry.plugins.get(Scroller);\n    if (!scroller) {\n      throw new Error(\"AutoScroller plugin depends on Scroller plugin\");\n    }\n    this.destroy = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.effect)(() => {\n      if (this.disabled) {\n        return;\n      }\n      const { position: _, status } = manager.dragOperation;\n      if (status.dragging) {\n        const canScroll2 = scroller.scroll();\n        if (canScroll2) {\n          scroller.autoScrolling = true;\n          const interval = setInterval(\n            () => scheduler3.schedule(scroller.scroll),\n            AUTOSCROLL_INTERVAL\n          );\n          return () => {\n            clearInterval(interval);\n          };\n        } else {\n          scroller.autoScrolling = false;\n        }\n      }\n    });\n  }\n};\nvar listenerOptions = {\n  capture: true,\n  passive: true\n};\nvar _timeout;\nvar ScrollListener = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.CorePlugin {\n  constructor(manager) {\n    super(manager);\n    __privateAdd(this, _timeout);\n    this.handleScroll = () => {\n      if (__privateGet(this, _timeout) == null) {\n        __privateSet(this, _timeout, setTimeout(() => {\n          this.manager.collisionObserver.forceUpdate(false);\n          __privateSet(this, _timeout, void 0);\n        }, 50));\n      }\n    };\n    const { dragOperation } = this.manager;\n    this.destroy = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.effect)(() => {\n      var _a4, _b2, _c3;\n      const enabled = dragOperation.status.dragging;\n      if (enabled) {\n        const root = (_c3 = (_b2 = (_a4 = dragOperation.source) == null ? void 0 : _a4.element) == null ? void 0 : _b2.ownerDocument) != null ? _c3 : document;\n        root.addEventListener(\"scroll\", this.handleScroll, listenerOptions);\n        return () => {\n          root.removeEventListener(\n            \"scroll\",\n            this.handleScroll,\n            listenerOptions\n          );\n        };\n      }\n    });\n  }\n};\n_timeout = new WeakMap();\nvar PreventSelection = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(manager, options) {\n    super(manager, options);\n    this.manager = manager;\n    this.destroy = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.effect)(() => {\n      var _a4;\n      const { dragOperation } = this.manager;\n      const { nonce } = (_a4 = this.options) != null ? _a4 : {};\n      if (dragOperation.status.initialized) {\n        const style = document.createElement(\"style\");\n        if (nonce) {\n          style.setAttribute(\"nonce\", nonce);\n        }\n        style.textContent = `* { user-select: none !important; -webkit-user-select: none !important; }`;\n        document.head.appendChild(style);\n        removeSelection();\n        document.addEventListener(\"selectionchange\", removeSelection, {\n          capture: true\n        });\n        return () => {\n          document.removeEventListener(\"selectionchange\", removeSelection, {\n            capture: true\n          });\n          style.remove();\n        };\n      }\n    });\n  }\n};\nfunction removeSelection() {\n  var _a4;\n  (_a4 = document.getSelection()) == null ? void 0 : _a4.removeAllRanges();\n}\nvar defaults = Object.freeze({\n  offset: 10,\n  keyboardCodes: {\n    start: [\"Space\", \"Enter\"],\n    cancel: [\"Escape\"],\n    end: [\"Space\", \"Enter\", \"Tab\"],\n    up: [\"ArrowUp\"],\n    down: [\"ArrowDown\"],\n    left: [\"ArrowLeft\"],\n    right: [\"ArrowRight\"]\n  },\n  shouldActivate(args) {\n    var _a4;\n    const { event, source } = args;\n    const target = (_a4 = source.handle) != null ? _a4 : source.element;\n    return event.target === target;\n  }\n});\nvar _cleanupFunctions;\nvar _KeyboardSensor = class _KeyboardSensor extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Sensor {\n  constructor(manager, options) {\n    super(manager);\n    this.manager = manager;\n    this.options = options;\n    __privateAdd(this, _cleanupFunctions, []);\n    this.listeners = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.Listeners();\n    this.handleSourceKeyDown = (event, source, options) => {\n      if (this.disabled || event.defaultPrevented) {\n        return;\n      }\n      if (!(0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isElement)(event.target)) {\n        return;\n      }\n      if (source.disabled) {\n        return;\n      }\n      const {\n        keyboardCodes = defaults.keyboardCodes,\n        shouldActivate = defaults.shouldActivate\n      } = options != null ? options : {};\n      if (!keyboardCodes.start.includes(event.code)) {\n        return;\n      }\n      if (!this.manager.dragOperation.status.idle) {\n        return;\n      }\n      if (shouldActivate({ event, source, manager: this.manager })) {\n        this.handleStart(event, source, options);\n      }\n    };\n  }\n  bind(source, options = this.options) {\n    const unbind = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.effect)(() => {\n      var _a4;\n      const target = (_a4 = source.handle) != null ? _a4 : source.element;\n      const listener = (event) => {\n        if ((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isKeyboardEvent)(event)) {\n          this.handleSourceKeyDown(event, source, options);\n        }\n      };\n      if (target) {\n        target.addEventListener(\"keydown\", listener);\n        return () => {\n          target.removeEventListener(\"keydown\", listener);\n        };\n      }\n    });\n    return unbind;\n  }\n  handleStart(event, source, options) {\n    const { element } = source;\n    if (!element) {\n      throw new Error(\"Source draggable does not have an associated element\");\n    }\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.scrollIntoViewIfNeeded)(element);\n    const { center } = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(element);\n    const controller = this.manager.actions.start({\n      event,\n      coordinates: {\n        x: center.x,\n        y: center.y\n      },\n      source\n    });\n    if (controller.signal.aborted) return this.cleanup();\n    this.sideEffects();\n    const sourceDocument = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)(element);\n    const listeners = [\n      this.listeners.bind(sourceDocument, [\n        {\n          type: \"keydown\",\n          listener: (event2) => this.handleKeyDown(event2, source, options),\n          options: { capture: true }\n        }\n      ])\n    ];\n    __privateGet(this, _cleanupFunctions).push(...listeners);\n  }\n  handleKeyDown(event, _source, options) {\n    const { keyboardCodes = defaults.keyboardCodes } = options != null ? options : {};\n    if (isKeycode(event, [...keyboardCodes.end, ...keyboardCodes.cancel])) {\n      event.preventDefault();\n      const canceled = isKeycode(event, keyboardCodes.cancel);\n      this.handleEnd(event, canceled);\n      return;\n    }\n    if (isKeycode(event, keyboardCodes.up)) {\n      this.handleMove(\"up\", event);\n    } else if (isKeycode(event, keyboardCodes.down)) {\n      this.handleMove(\"down\", event);\n    }\n    if (isKeycode(event, keyboardCodes.left)) {\n      this.handleMove(\"left\", event);\n    } else if (isKeycode(event, keyboardCodes.right)) {\n      this.handleMove(\"right\", event);\n    }\n  }\n  handleEnd(event, canceled) {\n    this.manager.actions.stop({\n      event,\n      canceled\n    });\n    this.cleanup();\n  }\n  handleMove(direction, event) {\n    var _a4, _b2;\n    const { shape } = this.manager.dragOperation;\n    const factor = event.shiftKey ? 5 : 1;\n    let by = {\n      x: 0,\n      y: 0\n    };\n    let offset = (_b2 = (_a4 = this.options) == null ? void 0 : _a4.offset) != null ? _b2 : defaults.offset;\n    if (typeof offset === \"number\") {\n      offset = { x: offset, y: offset };\n    }\n    if (!shape) {\n      return;\n    }\n    switch (direction) {\n      case \"up\":\n        by = { x: 0, y: -offset.y * factor };\n        break;\n      case \"down\":\n        by = { x: 0, y: offset.y * factor };\n        break;\n      case \"left\":\n        by = { x: -offset.x * factor, y: 0 };\n        break;\n      case \"right\":\n        by = { x: offset.x * factor, y: 0 };\n        break;\n    }\n    if (by.x || by.y) {\n      event.preventDefault();\n      this.manager.actions.move({\n        event,\n        by\n      });\n    }\n  }\n  sideEffects() {\n    const autoScroller = this.manager.registry.plugins.get(AutoScroller);\n    if ((autoScroller == null ? void 0 : autoScroller.disabled) === false) {\n      autoScroller.disable();\n      __privateGet(this, _cleanupFunctions).push(() => {\n        autoScroller.enable();\n      });\n    }\n  }\n  cleanup() {\n    __privateGet(this, _cleanupFunctions).forEach((cleanup) => cleanup());\n    __privateSet(this, _cleanupFunctions, []);\n  }\n  destroy() {\n    this.cleanup();\n    this.listeners.clear();\n  }\n};\n_cleanupFunctions = new WeakMap();\n_KeyboardSensor.configure = (0,_dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.configurator)(_KeyboardSensor);\n_KeyboardSensor.defaults = defaults;\nvar KeyboardSensor = _KeyboardSensor;\nfunction isKeycode(event, codes) {\n  return codes.includes(event.code);\n}\nvar defaults2 = Object.freeze({\n  activationConstraints(event, source) {\n    var _a4;\n    const { pointerType, target } = event;\n    if (pointerType === \"mouse\" && (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isElement)(target) && (source.handle === target || ((_a4 = source.handle) == null ? void 0 : _a4.contains(target)))) {\n      return void 0;\n    }\n    if (pointerType === \"touch\") {\n      return {\n        delay: { value: 250, tolerance: 5 }\n      };\n    }\n    if ((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isTextInput)(target) && !event.defaultPrevented) {\n      return {\n        delay: { value: 200, tolerance: 0 }\n      };\n    }\n    return {\n      delay: { value: 200, tolerance: 10 },\n      distance: { value: 5 }\n    };\n  }\n});\nvar _cleanup, _clearTimeout;\nvar _PointerSensor = class _PointerSensor extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Sensor {\n  constructor(manager, options) {\n    super(manager);\n    this.manager = manager;\n    this.options = options;\n    __privateAdd(this, _cleanup, /* @__PURE__ */ new Set());\n    __privateAdd(this, _clearTimeout);\n    this.listeners = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.Listeners();\n    this.latest = {\n      event: void 0,\n      coordinates: void 0\n    };\n    this.handleMove = () => {\n      const { event, coordinates: to } = this.latest;\n      if (!event || !to) {\n        return;\n      }\n      this.manager.actions.move({ event, to });\n    };\n    this.handleCancel = this.handleCancel.bind(this);\n    this.handlePointerUp = this.handlePointerUp.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n  }\n  activationConstraints(event, source) {\n    var _a4;\n    const { activationConstraints = defaults2.activationConstraints } = (_a4 = this.options) != null ? _a4 : {};\n    const constraints = typeof activationConstraints === \"function\" ? activationConstraints(event, source) : activationConstraints;\n    return constraints;\n  }\n  bind(source, options = this.options) {\n    const unbind = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.effect)(() => {\n      var _a4;\n      const controller = new AbortController();\n      const { signal: signal3 } = controller;\n      const listener = (event) => {\n        if ((0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isPointerEvent)(event)) {\n          this.handlePointerDown(event, source, options);\n        }\n      };\n      let targets = [(_a4 = source.handle) != null ? _a4 : source.element];\n      if (options == null ? void 0 : options.activatorElements) {\n        if (Array.isArray(options.activatorElements)) {\n          targets = options.activatorElements;\n        } else {\n          targets = options.activatorElements(source);\n        }\n      }\n      for (const target of targets) {\n        if (!target) continue;\n        patchWindow(target.ownerDocument.defaultView);\n        target.addEventListener(\"pointerdown\", listener, { signal: signal3 });\n      }\n      return () => controller.abort();\n    });\n    return unbind;\n  }\n  handlePointerDown(event, source, options = {}) {\n    if (this.disabled || !event.isPrimary || event.button !== 0 || !(0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isElement)(event.target) || source.disabled || isCapturedBySensor(event) || !this.manager.dragOperation.status.idle) {\n      return;\n    }\n    const { target } = event;\n    const isNativeDraggable = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(target) && target.draggable && target.getAttribute(\"draggable\") === \"true\";\n    const offset = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getFrameTransform)(source.element);\n    this.initialCoordinates = {\n      x: event.clientX * offset.scaleX + offset.x,\n      y: event.clientY * offset.scaleY + offset.y\n    };\n    const constraints = this.activationConstraints(event, source);\n    event.sensor = this;\n    if (!(constraints == null ? void 0 : constraints.delay) && !(constraints == null ? void 0 : constraints.distance)) {\n      this.handleStart(source, event);\n    } else {\n      const { delay } = constraints;\n      if (delay) {\n        const timeout = setTimeout(\n          () => this.handleStart(source, event),\n          delay.value\n        );\n        __privateSet(this, _clearTimeout, () => {\n          clearTimeout(timeout);\n          __privateSet(this, _clearTimeout, void 0);\n        });\n      }\n    }\n    const ownerDocument = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)(event.target);\n    const unbindListeners = this.listeners.bind(ownerDocument, [\n      {\n        type: \"pointermove\",\n        listener: (event2) => this.handlePointerMove(event2, source)\n      },\n      {\n        type: \"pointerup\",\n        listener: this.handlePointerUp,\n        options: {\n          capture: true\n        }\n      },\n      {\n        // Cancel activation if there is a competing Drag and Drop interaction\n        type: \"dragstart\",\n        listener: isNativeDraggable ? this.handleCancel : preventDefault,\n        options: {\n          capture: true\n        }\n      }\n    ]);\n    const cleanup = () => {\n      var _a4;\n      unbindListeners();\n      (_a4 = __privateGet(this, _clearTimeout)) == null ? void 0 : _a4.call(this);\n      this.initialCoordinates = void 0;\n    };\n    __privateGet(this, _cleanup).add(cleanup);\n  }\n  handlePointerMove(event, source) {\n    const coordinates = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const offset = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getFrameTransform)(source.element);\n    coordinates.x = coordinates.x * offset.scaleX + offset.x;\n    coordinates.y = coordinates.y * offset.scaleY + offset.y;\n    if (this.manager.dragOperation.status.dragging) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.latest.event = event;\n      this.latest.coordinates = coordinates;\n      _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.scheduler.schedule(this.handleMove);\n      return;\n    }\n    if (!this.initialCoordinates) {\n      return;\n    }\n    const delta = {\n      x: coordinates.x - this.initialCoordinates.x,\n      y: coordinates.y - this.initialCoordinates.y\n    };\n    const constraints = this.activationConstraints(event, source);\n    const { distance, delay } = constraints != null ? constraints : {};\n    if (distance) {\n      if (distance.tolerance != null && (0,_dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.exceedsDistance)(delta, distance.tolerance)) {\n        return this.handleCancel(event);\n      }\n      if ((0,_dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.exceedsDistance)(delta, distance.value)) {\n        return this.handleStart(source, event);\n      }\n    }\n    if (delay) {\n      if ((0,_dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_4__.exceedsDistance)(delta, delay.tolerance)) {\n        return this.handleCancel(event);\n      }\n    }\n  }\n  handlePointerUp(event) {\n    const { status } = this.manager.dragOperation;\n    if (!status.idle) {\n      event.preventDefault();\n      event.stopPropagation();\n      const canceled = !status.initialized;\n      this.manager.actions.stop({ event, canceled });\n    }\n    this.cleanup();\n  }\n  handleKeyDown(event) {\n    if (event.key === \"Escape\") {\n      event.preventDefault();\n      this.handleCancel(event);\n    }\n  }\n  handleStart(source, event) {\n    var _a4;\n    const { manager, initialCoordinates } = this;\n    (_a4 = __privateGet(this, _clearTimeout)) == null ? void 0 : _a4.call(this);\n    if (!initialCoordinates || !manager.dragOperation.status.idle) {\n      return;\n    }\n    if (event.defaultPrevented) {\n      return;\n    }\n    const controller = manager.actions.start({\n      coordinates: initialCoordinates,\n      event,\n      source\n    });\n    if (controller.signal.aborted) return this.cleanup();\n    event.preventDefault();\n    const ownerDocument = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.getDocument)(event.target);\n    const pointerCaptureTarget = ownerDocument.body;\n    pointerCaptureTarget.setPointerCapture(event.pointerId);\n    const unbind = this.listeners.bind(ownerDocument, [\n      {\n        // Prevent scrolling on touch devices\n        type: \"touchmove\",\n        listener: preventDefault,\n        options: {\n          passive: false\n        }\n      },\n      {\n        // Prevent click events\n        type: \"click\",\n        listener: preventDefault\n      },\n      {\n        type: \"contextmenu\",\n        listener: preventDefault\n      },\n      {\n        type: \"keydown\",\n        listener: this.handleKeyDown\n      },\n      {\n        type: \"lostpointercapture\",\n        listener: (event2) => {\n          if (event2.target !== pointerCaptureTarget) return;\n          this.handlePointerUp(event2);\n        }\n      }\n    ]);\n    __privateGet(this, _cleanup).add(unbind);\n  }\n  handleCancel(event) {\n    const { dragOperation } = this.manager;\n    if (dragOperation.status.initialized) {\n      this.manager.actions.stop({ event, canceled: true });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    this.latest = {\n      event: void 0,\n      coordinates: void 0\n    };\n    __privateGet(this, _cleanup).forEach((cleanup) => cleanup());\n    __privateGet(this, _cleanup).clear();\n  }\n  destroy() {\n    this.cleanup();\n    this.listeners.clear();\n  }\n};\n_cleanup = new WeakMap();\n_clearTimeout = new WeakMap();\n_PointerSensor.configure = (0,_dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.configurator)(_PointerSensor);\n_PointerSensor.defaults = defaults2;\nvar PointerSensor = _PointerSensor;\nfunction isCapturedBySensor(event) {\n  return \"sensor\" in event;\n}\nfunction preventDefault(event) {\n  event.preventDefault();\n}\nfunction noop() {\n}\nvar windows = /* @__PURE__ */ new WeakSet();\nfunction patchWindow(window) {\n  if (!window || windows.has(window)) {\n    return;\n  }\n  window.addEventListener(\"touchmove\", noop, {\n    capture: false,\n    passive: false\n  });\n  windows.add(window);\n}\n\n// src/core/manager/manager.ts\nvar defaultPreset = {\n  modifiers: [],\n  plugins: [Accessibility, AutoScroller, Cursor, Feedback, PreventSelection],\n  sensors: [PointerSensor, KeyboardSensor]\n};\nvar DragDropManager = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.DragDropManager {\n  constructor(input = {}) {\n    const {\n      plugins = defaultPreset.plugins,\n      sensors = defaultPreset.sensors,\n      modifiers = []\n    } = input;\n    super(__spreadProps(__spreadValues({}, input), {\n      plugins: [ScrollListener, Scroller, ...plugins],\n      sensors,\n      modifiers\n    }));\n  }\n};\nvar _feedback_dec, _element_dec, _handle_dec, _c, _init4, _handle, _element, _feedback;\nvar Draggable = class extends (_c = _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Draggable, _handle_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _element_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _feedback_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _c) {\n  constructor(_a4, manager) {\n    var _b2 = _a4, {\n      element,\n      effects: effects2 = () => [],\n      handle,\n      feedback = \"default\"\n    } = _b2, input = __objRest(_b2, [\n      \"element\",\n      \"effects\",\n      \"handle\",\n      \"feedback\"\n    ]);\n    super(\n      __spreadValues({\n        effects: () => [\n          ...effects2(),\n          () => {\n            var _a5, _b3;\n            const { manager: manager2 } = this;\n            if (!manager2) return;\n            const sensors = (_b3 = (_a5 = this.sensors) == null ? void 0 : _a5.map(_dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.descriptor)) != null ? _b3 : [\n              ...manager2.sensors\n            ];\n            const unbindFunctions = sensors.map((entry) => {\n              const sensorInstance = entry instanceof _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Sensor ? entry : manager2.registry.register(entry.plugin);\n              const options = entry instanceof _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Sensor ? void 0 : entry.options;\n              const unbind = sensorInstance.bind(this, options);\n              return unbind;\n            });\n            return function cleanup() {\n              unbindFunctions.forEach((unbind) => unbind());\n            };\n          }\n        ]\n      }, input),\n      manager\n    );\n    __privateAdd(this, _handle, __runInitializers(_init4, 8, this)), __runInitializers(_init4, 11, this);\n    __privateAdd(this, _element, __runInitializers(_init4, 12, this)), __runInitializers(_init4, 15, this);\n    __privateAdd(this, _feedback, __runInitializers(_init4, 16, this)), __runInitializers(_init4, 19, this);\n    this.element = element;\n    this.handle = handle;\n    this.feedback = feedback;\n  }\n};\n_init4 = __decoratorStart(_c);\n_handle = new WeakMap();\n_element = new WeakMap();\n_feedback = new WeakMap();\n__decorateElement(_init4, 4, \"handle\", _handle_dec, Draggable, _handle);\n__decorateElement(_init4, 4, \"element\", _element_dec, Draggable, _element);\n__decorateElement(_init4, 4, \"feedback\", _feedback_dec, Draggable, _feedback);\n__decoratorMetadata(_init4, Draggable);\nvar _proxy_dec, _element_dec2, _c2, _init5, _element2, _d, element_get, element_set, _Droppable_instances, _proxy;\nvar Droppable = class extends (_c2 = _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Droppable, _element_dec2 = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _proxy_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_2__.reactive], _c2) {\n  constructor(_a4, manager) {\n    var _b2 = _a4, { element, effects: effects2 = () => [] } = _b2, input = __objRest(_b2, [\"element\", \"effects\"]);\n    const { collisionDetector = _dnd_kit_collision__WEBPACK_IMPORTED_MODULE_5__.defaultCollisionDetection } = input;\n    const updateShape = (boundingClientRect) => {\n      const { manager: manager2, element: element2 } = this;\n      if (!element2 || boundingClientRect === null) {\n        this.shape = void 0;\n        return void 0;\n      }\n      if (!manager2) return;\n      const updatedShape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.DOMRectangle(element2);\n      const shape = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.untracked)(() => this.shape);\n      if (updatedShape && (shape == null ? void 0 : shape.equals(updatedShape))) {\n        return shape;\n      }\n      this.shape = updatedShape;\n      return updatedShape;\n    };\n    const observePosition = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_3__.signal)(false);\n    super(\n      __spreadProps(__spreadValues({}, input), {\n        collisionDetector,\n        effects: () => [\n          ...effects2(),\n          () => {\n            const { element: element2, manager: manager2 } = this;\n            if (!manager2) return;\n            const { dragOperation } = manager2;\n            const { source } = dragOperation;\n            observePosition.value = Boolean(\n              source && dragOperation.status.initialized && element2 && !this.disabled && this.accepts(source)\n            );\n          },\n          () => {\n            const { element: element2 } = this;\n            if (observePosition.value && element2) {\n              const positionObserver = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_1__.PositionObserver(\n                element2,\n                updateShape\n              );\n              return () => {\n                positionObserver.disconnect();\n                this.shape = void 0;\n              };\n            }\n          },\n          () => {\n            var _a5;\n            if ((_a5 = this.manager) == null ? void 0 : _a5.dragOperation.status.initialized) {\n              return () => {\n                this.shape = void 0;\n              };\n            }\n          }\n        ]\n      }),\n      manager\n    );\n    __privateAdd(this, _Droppable_instances);\n    __privateAdd(this, _element2, __runInitializers(_init5, 8, this)), __runInitializers(_init5, 11, this);\n    __privateAdd(this, _proxy, __runInitializers(_init5, 12, this)), __runInitializers(_init5, 15, this);\n    this.element = element;\n    this.refreshShape = () => updateShape();\n  }\n  set element(element) {\n    __privateSet(this, _Droppable_instances, element, element_set);\n  }\n  get element() {\n    var _a4;\n    return (_a4 = this.proxy) != null ? _a4 : __privateGet(this, _Droppable_instances, element_get);\n  }\n};\n_init5 = __decoratorStart(_c2);\n_element2 = new WeakMap();\n_Droppable_instances = new WeakSet();\n_proxy = new WeakMap();\n_d = __decorateElement(_init5, 20, \"#element\", _element_dec2, _Droppable_instances, _element2), element_get = _d.get, element_set = _d.set;\n__decorateElement(_init5, 4, \"proxy\", _proxy_dec, Droppable, _proxy);\n__decoratorMetadata(_init5, Droppable);\n\n\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGRuZC1raXQrZG9tQDAuMS4yMS9ub2RlX21vZHVsZXMvQGRuZC1raXQvZG9tL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUw7QUFDMlY7QUFDcGE7QUFDOUI7QUFDYjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdKQUF3SjtBQUN6TjtBQUNBO0FBQ0Esa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUMsK0NBQStDO0FBQy9DO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiwrQkFBK0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLFVBQVU7QUFDckM7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRCxHQUFHO0FBQ0gsYUFBYSxhQUFhLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0EsK0JBQStCLFdBQVcsa0NBQWtDLFVBQVU7QUFDdEY7QUFDQSw2QkFBNkIsV0FBVztBQUN4QyxHQUFHO0FB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QUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdEQUFXLG1CQUFtQixvREFBUSxpQkFBaUIsb0RBQVE7QUFDcEc7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdELFlBQVksb0JBQW9CLHlFQUF5QixHQUFHO0FBQzVEO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnRUFBWTtBQUMzQyxvQkFBb0IseURBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFNO0FBQ2xDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLDJDQUEyQyxvRUFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEw7QUFDMUw7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZlZGVyaWNvam9yZ2Vib25lbHRvenppL0Rlc2t0b3AvV29yay9wdWNrL2NvZGUvZWNvc3lzdGVtL3B1Y2stY29uZmlncy9zaGFkY24tdHdibG9ja3Mvbm9kZV9tb2R1bGVzLy5wbnBtL0BkbmQta2l0K2RvbUAwLjEuMjEvbm9kZV9tb2R1bGVzL0BkbmQta2l0L2RvbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWd1cmF0b3IsIFNlbnNvciwgUGx1Z2luLCBDb3JlUGx1Z2luLCBEcmFnRHJvcE1hbmFnZXIgYXMgRHJhZ0Ryb3BNYW5hZ2VyJDEsIERyYWdnYWJsZSBhcyBEcmFnZ2FibGUkMSwgRHJvcHBhYmxlIGFzIERyb3BwYWJsZSQxLCBkZXNjcmlwdG9yIH0gZnJvbSAnQGRuZC1raXQvYWJzdHJhY3QnO1xuaW1wb3J0IHsgU2Nyb2xsRGlyZWN0aW9uLCBMaXN0ZW5lcnMsIGlzRWxlbWVudCwgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCwgRE9NUmVjdGFuZ2xlLCBnZXREb2N1bWVudCwgaXNIVE1MRWxlbWVudCwgZ2V0RnJhbWVUcmFuc2Zvcm0sIHNjaGVkdWxlciwgaXNUZXh0SW5wdXQsIGlzS2V5Ym9hcmRFdmVudCwgaXNQb2ludGVyRXZlbnQsIGNhblNjcm9sbCwgZGV0ZWN0U2Nyb2xsSW50ZW50LCBnZXRFbGVtZW50RnJvbVBvaW50LCBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzLCBnZW5lcmF0ZVVuaXF1ZUlkLCBpc1NhZmFyaSwgU3R5bGVzLCBnZXRDb21wdXRlZFN0eWxlcywgcGFyc2VUcmFuc2xhdGUsIHN1cHBvcnRzUG9wb3Zlciwgc2hvd1BvcG92ZXIsIGdldFdpbmRvdywgc3VwcG9ydHNTdHlsZSwgZ2V0RnJhbWVFbGVtZW50LCBjbG9uZUVsZW1lbnQsIGdldEZpbmFsS2V5ZnJhbWUsIGFuaW1hdGVUcmFuc2Zvcm0sIFByb3hpZWRFbGVtZW50cywgUG9zaXRpb25PYnNlcnZlciB9IGZyb20gJ0BkbmQta2l0L2RvbS91dGlsaXRpZXMnO1xuaW1wb3J0IHsgZWZmZWN0LCBjb21wdXRlZCwgZGVlcEVxdWFsLCBzaWduYWwsIGJhdGNoLCB1bnRyYWNrZWQsIGVmZmVjdHMsIHJlYWN0aXZlIH0gZnJvbSAnQGRuZC1raXQvc3RhdGUnO1xuaW1wb3J0IHsgZXhjZWVkc0Rpc3RhbmNlLCBBeGVzLCBQb2ludCwgUmVjdGFuZ2xlIH0gZnJvbSAnQGRuZC1raXQvZ2VvbWV0cnknO1xuaW1wb3J0IHsgZGVmYXVsdENvbGxpc2lvbkRldGVjdGlvbiB9IGZyb20gJ0BkbmQta2l0L2NvbGxpc2lvbic7XG5cbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2tub3duU3ltYm9sID0gKG5hbWUsIHN5bWJvbCkgPT4gKHN5bWJvbCA9IFN5bWJvbFtuYW1lXSkgPyBzeW1ib2wgOiBTeW1ib2wuZm9yKFwiU3ltYm9sLlwiICsgbmFtZSk7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fZGVjb3JhdG9yU3RhcnQgPSAoYmFzZSkgPT4ge1xuICB2YXIgX2E0O1xuICByZXR1cm4gWywgLCAsIF9fY3JlYXRlKChfYTQgPSBiYXNlID09IG51bGwgPyB2b2lkIDAgOiBiYXNlW19fa25vd25TeW1ib2woXCJtZXRhZGF0YVwiKV0pICE9IG51bGwgPyBfYTQgOiBudWxsKV07XG59O1xudmFyIF9fZGVjb3JhdG9yU3RyaW5ncyA9IFtcImNsYXNzXCIsIFwibWV0aG9kXCIsIFwiZ2V0dGVyXCIsIFwic2V0dGVyXCIsIFwiYWNjZXNzb3JcIiwgXCJmaWVsZFwiLCBcInZhbHVlXCIsIFwiZ2V0XCIsIFwic2V0XCJdO1xudmFyIF9fZXhwZWN0Rm4gPSAoZm4pID0+IGZuICE9PSB2b2lkIDAgJiYgdHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIgPyBfX3R5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpIDogZm47XG52YXIgX19kZWNvcmF0b3JDb250ZXh0ID0gKGtpbmQsIG5hbWUsIGRvbmUsIG1ldGFkYXRhLCBmbnMpID0+ICh7IGtpbmQ6IF9fZGVjb3JhdG9yU3RyaW5nc1traW5kXSwgbmFtZSwgbWV0YWRhdGEsIGFkZEluaXRpYWxpemVyOiAoZm4pID0+IGRvbmUuXyA/IF9fdHlwZUVycm9yKFwiQWxyZWFkeSBpbml0aWFsaXplZFwiKSA6IGZucy5wdXNoKF9fZXhwZWN0Rm4oZm4gfHwgbnVsbCkpIH0pO1xudmFyIF9fZGVjb3JhdG9yTWV0YWRhdGEgPSAoYXJyYXksIHRhcmdldCkgPT4gX19kZWZOb3JtYWxQcm9wKHRhcmdldCwgX19rbm93blN5bWJvbChcIm1ldGFkYXRhXCIpLCBhcnJheVszXSk7XG52YXIgX19ydW5Jbml0aWFsaXplcnMgPSAoYXJyYXksIGZsYWdzLCBzZWxmLCB2YWx1ZSkgPT4ge1xuICBmb3IgKHZhciBpID0gMCwgZm5zID0gYXJyYXlbZmxhZ3MgPj4gMV0sIG4gPSBmbnMgJiYgZm5zLmxlbmd0aDsgaSA8IG47IGkrKykgZmxhZ3MgJiAxID8gZm5zW2ldLmNhbGwoc2VsZikgOiB2YWx1ZSA9IGZuc1tpXS5jYWxsKHNlbGYsIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2RlY29yYXRlRWxlbWVudCA9IChhcnJheSwgZmxhZ3MsIG5hbWUsIGRlY29yYXRvcnMsIHRhcmdldCwgZXh0cmEpID0+IHtcbiAgdmFyIGZuLCBpdCwgZG9uZSwgY3R4LCBhY2Nlc3MsIGsgPSBmbGFncyAmIDcsIHMgPSAhIShmbGFncyAmIDgpLCBwID0gISEoZmxhZ3MgJiAxNik7XG4gIHZhciBqID0gayA+IDMgPyBhcnJheS5sZW5ndGggKyAxIDogayA/IHMgPyAxIDogMiA6IDAsIGtleSA9IF9fZGVjb3JhdG9yU3RyaW5nc1trICsgNV07XG4gIHZhciBpbml0aWFsaXplcnMgPSBrID4gMyAmJiAoYXJyYXlbaiAtIDFdID0gW10pLCBleHRyYUluaXRpYWxpemVycyA9IGFycmF5W2pdIHx8IChhcnJheVtqXSA9IFtdKTtcbiAgdmFyIGRlc2MgPSBrICYmICghcCAmJiAhcyAmJiAodGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZSksIGsgPCA1ICYmIChrID4gMyB8fCAhcCkgJiYgX19nZXRPd25Qcm9wRGVzYyhrIDwgNCA/IHRhcmdldCA6IHsgZ2V0IFtuYW1lXSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIGV4dHJhKTtcbiAgfSwgc2V0IFtuYW1lXSh4KSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZVNldCh0aGlzLCBleHRyYSwgeCk7XG4gIH0gfSwgbmFtZSkpO1xuICBrID8gcCAmJiBrIDwgNCAmJiBfX25hbWUoZXh0cmEsIChrID4gMiA/IFwic2V0IFwiIDogayA+IDEgPyBcImdldCBcIiA6IFwiXCIpICsgbmFtZSkgOiBfX25hbWUodGFyZ2V0LCBuYW1lKTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjdHggPSBfX2RlY29yYXRvckNvbnRleHQoaywgbmFtZSwgZG9uZSA9IHt9LCBhcnJheVszXSwgZXh0cmFJbml0aWFsaXplcnMpO1xuICAgIGlmIChrKSB7XG4gICAgICBjdHguc3RhdGljID0gcywgY3R4LnByaXZhdGUgPSBwLCBhY2Nlc3MgPSBjdHguYWNjZXNzID0geyBoYXM6IHAgPyAoeCkgPT4gX19wcml2YXRlSW4odGFyZ2V0LCB4KSA6ICh4KSA9PiBuYW1lIGluIHggfTtcbiAgICAgIGlmIChrIF4gMykgYWNjZXNzLmdldCA9IHAgPyAoeCkgPT4gKGsgXiAxID8gX19wcml2YXRlR2V0IDogX19wcml2YXRlTWV0aG9kKSh4LCB0YXJnZXQsIGsgXiA0ID8gZXh0cmEgOiBkZXNjLmdldCkgOiAoeCkgPT4geFtuYW1lXTtcbiAgICAgIGlmIChrID4gMikgYWNjZXNzLnNldCA9IHAgPyAoeCwgeSkgPT4gX19wcml2YXRlU2V0KHgsIHRhcmdldCwgeSwgayBeIDQgPyBleHRyYSA6IGRlc2Muc2V0KSA6ICh4LCB5KSA9PiB4W25hbWVdID0geTtcbiAgICB9XG4gICAgaXQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoayA/IGsgPCA0ID8gcCA/IGV4dHJhIDogZGVzY1trZXldIDogayA+IDQgPyB2b2lkIDAgOiB7IGdldDogZGVzYy5nZXQsIHNldDogZGVzYy5zZXQgfSA6IHRhcmdldCwgY3R4KSwgZG9uZS5fID0gMTtcbiAgICBpZiAoayBeIDQgfHwgaXQgPT09IHZvaWQgMCkgX19leHBlY3RGbihpdCkgJiYgKGsgPiA0ID8gaW5pdGlhbGl6ZXJzLnVuc2hpZnQoaXQpIDogayA/IHAgPyBleHRyYSA9IGl0IDogZGVzY1trZXldID0gaXQgOiB0YXJnZXQgPSBpdCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGl0ICE9PSBcIm9iamVjdFwiIHx8IGl0ID09PSBudWxsKSBfX3R5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICBlbHNlIF9fZXhwZWN0Rm4oZm4gPSBpdC5nZXQpICYmIChkZXNjLmdldCA9IGZuKSwgX19leHBlY3RGbihmbiA9IGl0LnNldCkgJiYgKGRlc2Muc2V0ID0gZm4pLCBfX2V4cGVjdEZuKGZuID0gaXQuaW5pdCkgJiYgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoZm4pO1xuICB9XG4gIHJldHVybiBrIHx8IF9fZGVjb3JhdG9yTWV0YWRhdGEoYXJyYXksIHRhcmdldCksIGRlc2MgJiYgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgZGVzYyksIHAgPyBrIF4gNCA/IGV4dHJhIDogZGVzYyA6IHRhcmdldDtcbn07XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiBtZW1iZXIuaGFzKG9iaikgfHwgX190eXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xudmFyIF9fcHJpdmF0ZUluID0gKG1lbWJlciwgb2JqKSA9PiBPYmplY3Qob2JqKSAhPT0gb2JqID8gX190eXBlRXJyb3IoJ0Nhbm5vdCB1c2UgdGhlIFwiaW5cIiBvcGVyYXRvciBvbiB0aGlzIHZhbHVlJykgOiBtZW1iZXIuaGFzKG9iaik7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgdmFsdWUpO1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIG1ldGhvZCk7XG5cbi8vIHNyYy9jb3JlL3BsdWdpbnMvYWNjZXNzaWJpbGl0eS9kZWZhdWx0cy50c1xudmFyIGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICByb2xlOiBcImJ1dHRvblwiLFxuICByb2xlRGVzY3JpcHRpb246IFwiZHJhZ2dhYmxlXCJ9O1xudmFyIGRlZmF1bHREZXNjcmlwdGlvbklkUHJlZml4ID0gYGRuZC1raXQtZGVzY3JpcHRpb25gO1xudmFyIGRlZmF1bHRBbm5vdW5jZW1lbnRJZFByZWZpeCA9IGBkbmQta2l0LWFubm91bmNlbWVudGA7XG52YXIgZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9ucyA9IHtcbiAgZHJhZ2dhYmxlOiBgVG8gcGljayB1cCBhIGRyYWdnYWJsZSBpdGVtLCBwcmVzcyB0aGUgc3BhY2UgYmFyLiBXaGlsZSBkcmFnZ2luZywgdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0gaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFByZXNzIHNwYWNlIGFnYWluIHRvIGRyb3AgdGhlIGl0ZW0gaW4gaXRzIG5ldyBwb3NpdGlvbiwgb3IgcHJlc3MgZXNjYXBlIHRvIGNhbmNlbC5gXG59O1xudmFyIGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICBkcmFnc3RhcnQoeyBvcGVyYXRpb246IHsgc291cmNlIH0gfSkge1xuICAgIGlmICghc291cmNlKSByZXR1cm47XG4gICAgcmV0dXJuIGBQaWNrZWQgdXAgZHJhZ2dhYmxlIGl0ZW0gJHtzb3VyY2UuaWR9LmA7XG4gIH0sXG4gIGRyYWdvdmVyKHsgb3BlcmF0aW9uOiB7IHNvdXJjZSwgdGFyZ2V0IH0gfSkge1xuICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5pZCA9PT0gKHRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0LmlkKSkgcmV0dXJuO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBgRHJhZ2dhYmxlIGl0ZW0gJHtzb3VyY2UuaWR9IHdhcyBtb3ZlZCBvdmVyIGRyb3BwYWJsZSB0YXJnZXQgJHt0YXJnZXQuaWR9LmA7XG4gICAgfVxuICAgIHJldHVybiBgRHJhZ2dhYmxlIGl0ZW0gJHtzb3VyY2UuaWR9IGlzIG5vIGxvbmdlciBvdmVyIGEgZHJvcHBhYmxlIHRhcmdldC5gO1xuICB9LFxuICBkcmFnZW5kKHsgb3BlcmF0aW9uOiB7IHNvdXJjZSwgdGFyZ2V0IH0sIGNhbmNlbGVkIH0pIHtcbiAgICBpZiAoIXNvdXJjZSkgcmV0dXJuO1xuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuIGBEcmFnZ2luZyB3YXMgY2FuY2VsbGVkLiBEcmFnZ2FibGUgaXRlbSAke3NvdXJjZS5pZH0gd2FzIGRyb3BwZWQuYDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGBEcmFnZ2FibGUgaXRlbSAke3NvdXJjZS5pZH0gd2FzIGRyb3BwZWQgb3ZlciBkcm9wcGFibGUgdGFyZ2V0ICR7dGFyZ2V0LmlkfWA7XG4gICAgfVxuICAgIHJldHVybiBgRHJhZ2dhYmxlIGl0ZW0gJHtzb3VyY2UuaWR9IHdhcyBkcm9wcGVkLmA7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL3BsdWdpbnMvYWNjZXNzaWJpbGl0eS91dGlsaXRpZXMudHNcbmZ1bmN0aW9uIGlzRm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gW1wiaW5wdXRcIiwgXCJzZWxlY3RcIiwgXCJ0ZXh0YXJlYVwiLCBcImFcIiwgXCJidXR0b25cIl0uaW5jbHVkZXModGFnTmFtZSk7XG59XG5cbi8vIHNyYy9jb3JlL3BsdWdpbnMvYWNjZXNzaWJpbGl0eS9IaWRkZW5UZXh0LnRzXG5mdW5jdGlvbiBjcmVhdGVIaWRkZW5UZXh0KGlkLCB2YWx1ZSkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZWxlbWVudC5pZCA9IGlkO1xuICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8vIHNyYy9jb3JlL3BsdWdpbnMvYWNjZXNzaWJpbGl0eS9MaXZlUmVnaW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXZlUmVnaW9uKGlkKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBlbGVtZW50LmlkID0gaWQ7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInN0YXR1c1wiKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1hdG9taWNcIiwgXCJ0cnVlXCIpO1xuICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKTtcbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIFwiMXB4XCIpO1xuICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiaGVpZ2h0XCIsIFwiMXB4XCIpO1xuICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwibWFyZ2luXCIsIFwiLTFweFwiKTtcbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcImJvcmRlclwiLCBcIjBcIik7XG4gIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCJwYWRkaW5nXCIsIFwiMFwiKTtcbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpO1xuICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiY2xpcFwiLCBcInJlY3QoMCAwIDAgMClcIik7XG4gIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCJjbGlwLXBhdGhcIiwgXCJpbnNldCgxMDAlKVwiKTtcbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIndoaXRlLXNwYWNlXCIsIFwibm93cmFwXCIpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLy8gc3JjL2NvcmUvcGx1Z2lucy9hY2Nlc3NpYmlsaXR5L0FjY2Vzc2liaWxpdHkudHNcbnZhciBkZWJvdW5jZWRFdmVudHMgPSBbXCJkcmFnb3ZlclwiLCBcImRyYWdtb3ZlXCJdO1xudmFyIEFjY2Vzc2liaWxpdHkgPSBjbGFzcyBleHRlbmRzIFBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGlkUHJlZml4OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblByZWZpeCA9IGRlZmF1bHREZXNjcmlwdGlvbklkUHJlZml4LFxuICAgICAgICBhbm5vdW5jZW1lbnQ6IGFubm91bmNlbWVudFByZWZpeCA9IGRlZmF1bHRBbm5vdW5jZW1lbnRJZFByZWZpeFxuICAgICAgfSA9IHt9LFxuICAgICAgYW5ub3VuY2VtZW50cyA9IGRlZmF1bHRBbm5vdW5jZW1lbnRzLFxuICAgICAgc2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zID0gZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9ucyxcbiAgICAgIGRlYm91bmNlOiBkZWJvdW5jZU1zID0gNTAwXG4gICAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbklkID0gaWQgPyBgJHtkZXNjcmlwdGlvblByZWZpeH0tJHtpZH1gIDogZ2VuZXJhdGVVbmlxdWVJZChkZXNjcmlwdGlvblByZWZpeCk7XG4gICAgY29uc3QgYW5ub3VuY2VtZW50SWQgPSBpZCA/IGAke2Fubm91bmNlbWVudFByZWZpeH0tJHtpZH1gIDogZ2VuZXJhdGVVbmlxdWVJZChhbm5vdW5jZW1lbnRQcmVmaXgpO1xuICAgIGxldCBoaWRkZW5UZXh0RWxlbWVudDtcbiAgICBsZXQgbGl2ZVJlZ2lvbkVsZW1lbnQ7XG4gICAgbGV0IGxpdmVSZWdpb25UZXh0Tm9kZTtcbiAgICBsZXQgbGF0ZXN0QW5ub3VuY2VtZW50O1xuICAgIGNvbnN0IHVwZGF0ZUFubm91bmNlbWVudCA9ICh2YWx1ZSA9IGxhdGVzdEFubm91bmNlbWVudCkgPT4ge1xuICAgICAgaWYgKCFsaXZlUmVnaW9uVGV4dE5vZGUgfHwgIXZhbHVlKSByZXR1cm47XG4gICAgICBpZiAoKGxpdmVSZWdpb25UZXh0Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogbGl2ZVJlZ2lvblRleHROb2RlLm5vZGVWYWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgICAgIGxpdmVSZWdpb25UZXh0Tm9kZS5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjaGVkdWxlVXBkYXRlQW5ub3VuY2VtZW50ID0gKCkgPT4gc2NoZWR1bGVyLnNjaGVkdWxlKHVwZGF0ZUFubm91bmNlbWVudCk7XG4gICAgY29uc3QgZGVib3VuY2VkVXBkYXRlQW5ub3VuY2VtZW50ID0gZGVib3VuY2UoXG4gICAgICBzY2hlZHVsZVVwZGF0ZUFubm91bmNlbWVudCxcbiAgICAgIGRlYm91bmNlTXNcbiAgICApO1xuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gT2JqZWN0LmVudHJpZXMoYW5ub3VuY2VtZW50cykubWFwKFxuICAgICAgKFtldmVudE5hbWUsIGdldEFubm91bmNlbWVudF0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5tb25pdG9yLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgIChldmVudCwgbWFuYWdlcjIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBsaXZlUmVnaW9uVGV4dE5vZGU7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGFubm91bmNlbWVudCA9IGdldEFubm91bmNlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZ2V0QW5ub3VuY2VtZW50KGV2ZW50LCBtYW5hZ2VyMik7XG4gICAgICAgICAgICBpZiAoYW5ub3VuY2VtZW50ICYmIGVsZW1lbnQubm9kZVZhbHVlICE9PSBhbm5vdW5jZW1lbnQpIHtcbiAgICAgICAgICAgICAgbGF0ZXN0QW5ub3VuY2VtZW50ID0gYW5ub3VuY2VtZW50O1xuICAgICAgICAgICAgICBpZiAoZGVib3VuY2VkRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkZWJvdW5jZWRVcGRhdGVBbm5vdW5jZW1lbnQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZUFubm91bmNlbWVudCgpO1xuICAgICAgICAgICAgICAgIGRlYm91bmNlZFVwZGF0ZUFubm91bmNlbWVudC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGluaXRpYWxpemUgPSAoKSA9PiB7XG4gICAgICBsZXQgZWxlbWVudHMgPSBbXTtcbiAgICAgIGlmICghKGhpZGRlblRleHRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBoaWRkZW5UZXh0RWxlbWVudC5pc0Nvbm5lY3RlZCkpIHtcbiAgICAgICAgaGlkZGVuVGV4dEVsZW1lbnQgPSBjcmVhdGVIaWRkZW5UZXh0KFxuICAgICAgICAgIGRlc2NyaXB0aW9uSWQsXG4gICAgICAgICAgc2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zLmRyYWdnYWJsZVxuICAgICAgICApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGhpZGRlblRleHRFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghKGxpdmVSZWdpb25FbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBsaXZlUmVnaW9uRWxlbWVudC5pc0Nvbm5lY3RlZCkpIHtcbiAgICAgICAgbGl2ZVJlZ2lvbkVsZW1lbnQgPSBjcmVhdGVMaXZlUmVnaW9uKGFubm91bmNlbWVudElkKTtcbiAgICAgICAgbGl2ZVJlZ2lvblRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgIGxpdmVSZWdpb25FbGVtZW50LmFwcGVuZENoaWxkKGxpdmVSZWdpb25UZXh0Tm9kZSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2gobGl2ZVJlZ2lvbkVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoLi4uZWxlbWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbXV0YXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBleGVjdXRlTXV0YXRpb25zKCkge1xuICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIG9wZXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlZ2lzdGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIHZhciBfYTQ7XG4gICAgICBtdXRhdGlvbnMuY2xlYXIoKTtcbiAgICAgIGZvciAoY29uc3QgZHJhZ2dhYmxlIG9mIHRoaXMubWFuYWdlci5yZWdpc3RyeS5kcmFnZ2FibGVzLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2YXRvciA9IChfYTQgPSBkcmFnZ2FibGUuaGFuZGxlKSAhPSBudWxsID8gX2E0IDogZHJhZ2dhYmxlLmVsZW1lbnQ7XG4gICAgICAgIGlmIChhY3RpdmF0b3IpIHtcbiAgICAgICAgICBpZiAoIWhpZGRlblRleHRFbGVtZW50IHx8ICFsaXZlUmVnaW9uRWxlbWVudCkge1xuICAgICAgICAgICAgbXV0YXRpb25zLmFkZChpbml0aWFsaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCghaXNGb2N1c2FibGUoYWN0aXZhdG9yKSB8fCBpc1NhZmFyaSgpKSAmJiAhYWN0aXZhdG9yLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpKSB7XG4gICAgICAgICAgICBtdXRhdGlvbnMuYWRkKCgpID0+IGFjdGl2YXRvci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFjdGl2YXRvci5oYXNBdHRyaWJ1dGUoXCJyb2xlXCIpICYmICEoYWN0aXZhdG9yLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIikpIHtcbiAgICAgICAgICAgIG11dGF0aW9ucy5hZGQoXG4gICAgICAgICAgICAgICgpID0+IGFjdGl2YXRvci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIGRlZmF1bHRBdHRyaWJ1dGVzLnJvbGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFjdGl2YXRvci5oYXNBdHRyaWJ1dGUoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiKSkge1xuICAgICAgICAgICAgbXV0YXRpb25zLmFkZChcbiAgICAgICAgICAgICAgKCkgPT4gYWN0aXZhdG9yLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEF0dHJpYnV0ZXMucm9sZURlc2NyaXB0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYWN0aXZhdG9yLmhhc0F0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIikpIHtcbiAgICAgICAgICAgIG11dGF0aW9ucy5hZGQoXG4gICAgICAgICAgICAgICgpID0+IGFjdGl2YXRvci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGRlc2NyaXB0aW9uSWQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBbXCJhcmlhLXByZXNzZWRcIiwgXCJhcmlhLWdyYWJiZWRcIl0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKGRyYWdnYWJsZS5pc0RyYWdnaW5nKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmF0b3IuZ2V0QXR0cmlidXRlKGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIG11dGF0aW9ucy5hZGQoKCkgPT4gYWN0aXZhdG9yLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRpc2FibGVkID0gU3RyaW5nKGRyYWdnYWJsZS5kaXNhYmxlZCk7XG4gICAgICAgICAgaWYgKGFjdGl2YXRvci5nZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIpICE9PSBkaXNhYmxlZCkge1xuICAgICAgICAgICAgbXV0YXRpb25zLmFkZChcbiAgICAgICAgICAgICAgKCkgPT4gYWN0aXZhdG9yLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgZGlzYWJsZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG11dGF0aW9ucy5zaXplID4gMCkge1xuICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoZXhlY3V0ZU11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgaGlkZGVuVGV4dEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhpZGRlblRleHRFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgbGl2ZVJlZ2lvbkVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxpdmVSZWdpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgd2FpdCkge1xuICBsZXQgdGltZW91dDtcbiAgY29uc3QgZGVib3VuY2VkID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgd2FpdCk7XG4gIH07XG4gIGRlYm91bmNlZC5jYW5jZWwgPSAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG52YXIgQ3Vyc29yID0gY2xhc3MgZXh0ZW5kcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWFuYWdlciwgb3B0aW9ucyk7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBkb2MgPSBjb21wdXRlZChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdmFyIF9hNDtcbiAgICAgICAgcmV0dXJuIGdldERvY3VtZW50KChfYTQgPSB0aGlzLm1hbmFnZXIuZHJhZ09wZXJhdGlvbi5zb3VyY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTQuZWxlbWVudCk7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmRlc3Ryb3kgPSBlZmZlY3QoKCkgPT4ge1xuICAgICAgdmFyIF9hNDtcbiAgICAgIGNvbnN0IHsgZHJhZ09wZXJhdGlvbiB9ID0gdGhpcy5tYW5hZ2VyO1xuICAgICAgY29uc3QgeyBjdXJzb3IgPSBcImdyYWJiaW5nXCIsIG5vbmNlIH0gPSAoX2E0ID0gdGhpcy5vcHRpb25zKSAhPSBudWxsID8gX2E0IDoge307XG4gICAgICBpZiAoZHJhZ09wZXJhdGlvbi5zdGF0dXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQyID0gZG9jLnZhbHVlO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGAqIHsgY3Vyc29yOiAke2N1cnNvcn0gIWltcG9ydGFudDsgfWA7XG4gICAgICAgIGRvY3VtZW50Mi5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHN0eWxlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9wbHVnaW5zL2ZlZWRiYWNrL2NvbnN0YW50cy50c1xudmFyIEFUVFJfUFJFRklYID0gXCJkYXRhLWRuZC1cIjtcbnZhciBEUk9QUElOR19BVFRSSUJVVEUgPSBgJHtBVFRSX1BSRUZJWH1kcm9wcGluZ2A7XG52YXIgQ1NTX1BSRUZJWCA9IFwiLS1kbmQtXCI7XG52YXIgQVRUUklCVVRFID0gYCR7QVRUUl9QUkVGSVh9ZHJhZ2dpbmdgO1xudmFyIFBMQUNFSE9MREVSX0FUVFJJQlVURSA9IGAke0FUVFJfUFJFRklYfXBsYWNlaG9sZGVyYDtcbnZhciBJR05PUkVEX0FUVFJJQlVURVMgPSBbXG4gIEFUVFJJQlVURSxcbiAgUExBQ0VIT0xERVJfQVRUUklCVVRFLFxuICBcInBvcG92ZXJcIixcbiAgXCJhcmlhLXByZXNzZWRcIixcbiAgXCJhcmlhLWdyYWJiaW5nXCJcbl07XG52YXIgSUdOT1JFRF9TVFlMRVMgPSBbXCJ2aWV3LXRyYW5zaXRpb24tbmFtZVwiXTtcbnZhciBDU1NfUlVMRVMgPSBgXG4gIDpyb290IFske0FUVFJJQlVURX1dIHtcbiAgICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xuICAgIHRvdWNoLWFjdGlvbjogbm9uZTtcbiAgICB6LWluZGV4OiBjYWxjKGluZmluaXR5KTtcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNsYXRlO1xuICAgIHRvcDogdmFyKCR7Q1NTX1BSRUZJWH10b3AsIDBweCkgIWltcG9ydGFudDtcbiAgICBsZWZ0OiB2YXIoJHtDU1NfUFJFRklYfWxlZnQsIDBweCkgIWltcG9ydGFudDtcbiAgICByaWdodDogdW5zZXQgIWltcG9ydGFudDtcbiAgICBib3R0b206IHVuc2V0ICFpbXBvcnRhbnQ7XG4gICAgd2lkdGg6IHZhcigke0NTU19QUkVGSVh9d2lkdGgsIGF1dG8pO1xuICAgIG1heC13aWR0aDogdmFyKCR7Q1NTX1BSRUZJWH13aWR0aCwgYXV0byk7XG4gICAgaGVpZ2h0OiB2YXIoJHtDU1NfUFJFRklYfWhlaWdodCwgYXV0byk7XG4gICAgbWF4LWhlaWdodDogdmFyKCR7Q1NTX1BSRUZJWH1oZWlnaHQsIGF1dG8pO1xuICAgIHRyYW5zaXRpb246IHZhcigke0NTU19QUkVGSVh9dHJhbnNpdGlvbikgIWltcG9ydGFudDtcbiAgfVxuXG4gIDpyb290IFske1BMQUNFSE9MREVSX0FUVFJJQlVURX1dIHtcbiAgICB0cmFuc2l0aW9uOiBub25lO1xuICB9XG5cbiAgOnJvb3QgWyR7UExBQ0VIT0xERVJfQVRUUklCVVRFfT0naGlkZGVuJ10ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuXG4gIFske0FUVFJJQlVURX1dICoge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICBbJHtBVFRSSUJVVEV9XTpub3QoWyR7RFJPUFBJTkdfQVRUUklCVVRFfV0pIHtcbiAgICB0cmFuc2xhdGU6IHZhcigke0NTU19QUkVGSVh9dHJhbnNsYXRlKSAhaW1wb3J0YW50O1xuICB9XG5cbiAgWyR7QVRUUklCVVRFfV1bc3R5bGUqPScke0NTU19QUkVGSVh9c2NhbGUnXSB7XG4gICAgc2NhbGU6IHZhcigke0NTU19QUkVGSVh9c2NhbGUpICFpbXBvcnRhbnQ7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogdmFyKCR7Q1NTX1BSRUZJWH10cmFuc2Zvcm0tb3JpZ2luKSAhaW1wb3J0YW50O1xuICB9XG5cbiAgQGxheWVyIHtcbiAgICA6d2hlcmUoWyR7QVRUUklCVVRFfV1bcG9wb3Zlcl0pIHtcbiAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgYmFja2dyb3VuZDogdW5zZXQ7XG4gICAgICBib3JkZXI6IHVuc2V0O1xuICAgICAgbWFyZ2luOiB1bnNldDtcbiAgICAgIHBhZGRpbmc6IHVuc2V0O1xuICAgICAgY29sb3I6IGluaGVyaXQ7XG5cbiAgICAgICY6aXMoaW5wdXQsIGJ1dHRvbikge1xuICAgICAgICBib3JkZXI6IHJldmVydDtcbiAgICAgICAgYmFja2dyb3VuZDogcmV2ZXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBbJHtBVFRSSUJVVEV9XTo6YmFja2Ryb3AsIFske0FUVFJfUFJFRklYfW92ZXJsYXldOm5vdChbJHtBVFRSSUJVVEV9XSkge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG5gLnJlcGxhY2UoL1xcbisvZywgXCIgXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLnRyaW0oKTtcbmZ1bmN0aW9uIGNyZWF0ZVBsYWNlaG9sZGVyKHNvdXJjZSwgdHlwZSA9IFwiaGlkZGVuXCIpIHtcbiAgcmV0dXJuIHVudHJhY2tlZCgoKSA9PiB7XG4gICAgY29uc3QgeyBlbGVtZW50LCBtYW5hZ2VyIH0gPSBzb3VyY2U7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFtYW5hZ2VyKSByZXR1cm47XG4gICAgY29uc3QgY29udGFpbmVkRHJvcHBhYmxlcyA9IGZpbmRDb250YWluZWREcm9wcGFibGVzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIG1hbmFnZXIucmVnaXN0cnkuZHJvcHBhYmxlc1xuICAgICk7XG4gICAgY29uc3QgY2xlYW51cCA9IFtdO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gY2xvbmVFbGVtZW50KGVsZW1lbnQpO1xuICAgIGNvbnN0IHsgcmVtb3ZlIH0gPSBwbGFjZWhvbGRlcjtcbiAgICBwcm94eURyb3BwYWJsZUVsZW1lbnRzKGNvbnRhaW5lZERyb3BwYWJsZXMsIHBsYWNlaG9sZGVyLCBjbGVhbnVwKTtcbiAgICBjb25maWd1cmVQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgdHlwZSk7XG4gICAgcGxhY2Vob2xkZXIucmVtb3ZlID0gKCkgPT4ge1xuICAgICAgY2xlYW51cC5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgICByZW1vdmUuY2FsbChwbGFjZWhvbGRlcik7XG4gICAgfTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZENvbnRhaW5lZERyb3BwYWJsZXMoZWxlbWVudCwgZHJvcHBhYmxlcykge1xuICBjb25zdCBjb250YWluZWREcm9wcGFibGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBkcm9wcGFibGUgb2YgZHJvcHBhYmxlcykge1xuICAgIGlmICghZHJvcHBhYmxlLmVsZW1lbnQpIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtZW50ID09PSBkcm9wcGFibGUuZWxlbWVudCB8fCBlbGVtZW50LmNvbnRhaW5zKGRyb3BwYWJsZS5lbGVtZW50KSkge1xuICAgICAgY29uc3QgaWRlbnRpZmllckF0dHJpYnV0ZSA9IGAke0FUVFJfUFJFRklYfSR7Z2VuZXJhdGVVbmlxdWVJZChcImRvbS1pZFwiKX1gO1xuICAgICAgZHJvcHBhYmxlLmVsZW1lbnQuc2V0QXR0cmlidXRlKGlkZW50aWZpZXJBdHRyaWJ1dGUsIFwiXCIpO1xuICAgICAgY29udGFpbmVkRHJvcHBhYmxlcy5zZXQoZHJvcHBhYmxlLCBpZGVudGlmaWVyQXR0cmlidXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lZERyb3BwYWJsZXM7XG59XG5mdW5jdGlvbiBwcm94eURyb3BwYWJsZUVsZW1lbnRzKGNvbnRhaW5lZERyb3BwYWJsZXMsIHBsYWNlaG9sZGVyLCBjbGVhbnVwKSB7XG4gIGZvciAoY29uc3QgW2Ryb3BwYWJsZSwgaWRlbnRpZmllckF0dHJpYnV0ZV0gb2YgY29udGFpbmVkRHJvcHBhYmxlcykge1xuICAgIGlmICghZHJvcHBhYmxlLmVsZW1lbnQpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYFske2lkZW50aWZpZXJBdHRyaWJ1dGV9XWA7XG4gICAgY29uc3QgY2xvbmVkRWxlbWVudCA9IHBsYWNlaG9sZGVyLm1hdGNoZXMoc2VsZWN0b3IpID8gcGxhY2Vob2xkZXIgOiBwbGFjZWhvbGRlci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBkcm9wcGFibGUuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoaWRlbnRpZmllckF0dHJpYnV0ZSk7XG4gICAgaWYgKCFjbG9uZWRFbGVtZW50KSBjb250aW51ZTtcbiAgICBjb25zdCBvcmlnaW5hbEVsZW1lbnQgPSBkcm9wcGFibGUuZWxlbWVudDtcbiAgICBkcm9wcGFibGUucHJveHkgPSBjbG9uZWRFbGVtZW50O1xuICAgIGNsb25lZEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGlkZW50aWZpZXJBdHRyaWJ1dGUpO1xuICAgIFByb3hpZWRFbGVtZW50cy5zZXQob3JpZ2luYWxFbGVtZW50LCBjbG9uZWRFbGVtZW50KTtcbiAgICBjbGVhbnVwLnB1c2goKCkgPT4ge1xuICAgICAgUHJveGllZEVsZW1lbnRzLmRlbGV0ZShvcmlnaW5hbEVsZW1lbnQpO1xuICAgICAgZHJvcHBhYmxlLnByb3h5ID0gdm9pZCAwO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb25maWd1cmVQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgdHlwZSA9IFwiaGlkZGVuXCIpIHtcbiAgcGxhY2Vob2xkZXIuc2V0QXR0cmlidXRlKFwiaW5lcnRcIiwgXCJ0cnVlXCIpO1xuICBwbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoXCJ0YWItaW5kZXhcIiwgXCItMVwiKTtcbiAgcGxhY2Vob2xkZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICBwbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoUExBQ0VIT0xERVJfQVRUUklCVVRFLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzU2FtZUZyYW1lKGVsZW1lbnQsIHRhcmdldCkge1xuICBpZiAoZWxlbWVudCA9PT0gdGFyZ2V0KSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGdldEZyYW1lRWxlbWVudChlbGVtZW50KSA9PT0gZ2V0RnJhbWVFbGVtZW50KHRhcmdldCk7XG59XG5mdW5jdGlvbiBwcmV2ZW50UG9wb3ZlckNsb3NlKGV2ZW50KSB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudDtcbiAgaWYgKFwibmV3U3RhdGVcIiBpbiBldmVudCAmJiBldmVudC5uZXdTdGF0ZSA9PT0gXCJjbG9zZWRcIiAmJiBpc0VsZW1lbnQodGFyZ2V0KSAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKFwicG9wb3ZlclwiKSkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBzaG93UG9wb3Zlcih0YXJnZXQpKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUYWJsZVJvdyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwiVFJcIjtcbn1cblxuLy8gc3JjL2NvcmUvcGx1Z2lucy9mZWVkYmFjay9GZWVkYmFjay50c1xudmFyIHN0eWxlU2hlZXRSZWdpc3RyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgX292ZXJsYXlfZGVjLCBfYSwgX2luaXQsIF9vdmVybGF5LCBfRmVlZGJhY2tfaW5zdGFuY2VzLCByZW5kZXJfZm4sIGluamVjdFN0eWxlc19mbjtcbnZhciBfRmVlZGJhY2sgPSBjbGFzcyBfRmVlZGJhY2sgZXh0ZW5kcyAoX2EgPSBQbHVnaW4sIF9vdmVybGF5X2RlYyA9IFtyZWFjdGl2ZV0sIF9hKSB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihtYW5hZ2VyLCBvcHRpb25zKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX0ZlZWRiYWNrX2luc3RhbmNlcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vdmVybGF5LCBfX3J1bkluaXRpYWxpemVycyhfaW5pdCwgOCwgdGhpcykpLCBfX3J1bkluaXRpYWxpemVycyhfaW5pdCwgMTEsIHRoaXMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpbml0aWFsOiB7fSxcbiAgICAgIGN1cnJlbnQ6IHt9XG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdGVyRWZmZWN0KF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRmVlZGJhY2tfaW5zdGFuY2VzLCBpbmplY3RTdHlsZXNfZm4pKTtcbiAgICB0aGlzLnJlZ2lzdGVyRWZmZWN0KF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRmVlZGJhY2tfaW5zdGFuY2VzLCByZW5kZXJfZm4pKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGNvbnN0IFtkb2MsIHJlZ2lzdHJhdGlvbl0gb2Ygc3R5bGVTaGVldFJlZ2lzdHJ5LmVudHJpZXMoKSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5pbnN0YW5jZXMuaGFzKHRoaXMpKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbi5pbnN0YW5jZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLmluc3RhbmNlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLmNsZWFudXAoKTtcbiAgICAgICAgICBzdHlsZVNoZWV0UmVnaXN0cnkuZGVsZXRlKGRvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5faW5pdCA9IF9fZGVjb3JhdG9yU3RhcnQoX2EpO1xuX292ZXJsYXkgPSBuZXcgV2Vha01hcCgpO1xuX0ZlZWRiYWNrX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCk7XG5yZW5kZXJfZm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9hNCwgX2IyLCBfYzM7XG4gIGNvbnN0IHsgc3RhdGUsIG1hbmFnZXIsIG9wdGlvbnMgfSA9IHRoaXM7XG4gIGNvbnN0IHsgZHJhZ09wZXJhdGlvbiB9ID0gbWFuYWdlcjtcbiAgY29uc3QgeyBwb3NpdGlvbiwgc291cmNlLCBzdGF0dXMgfSA9IGRyYWdPcGVyYXRpb247XG4gIGlmIChzdGF0dXMuaWRsZSkge1xuICAgIHN0YXRlLmN1cnJlbnQgPSB7fTtcbiAgICBzdGF0ZS5pbml0aWFsID0ge307XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghc291cmNlKSByZXR1cm47XG4gIGNvbnN0IHsgZWxlbWVudCwgZmVlZGJhY2sgfSA9IHNvdXJjZTtcbiAgaWYgKCFlbGVtZW50IHx8IGZlZWRiYWNrID09PSBcIm5vbmVcIiB8fCAhc3RhdHVzLmluaXRpYWxpemVkIHx8IHN0YXR1cy5pbml0aWFsaXppbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgeyBpbml0aWFsIH0gPSBzdGF0ZTtcbiAgY29uc3QgZmVlZGJhY2tFbGVtZW50ID0gKF9hNCA9IHRoaXMub3ZlcmxheSkgIT0gbnVsbCA/IF9hNCA6IGVsZW1lbnQ7XG4gIGNvbnN0IGZyYW1lVHJhbnNmb3JtID0gZ2V0RnJhbWVUcmFuc2Zvcm0oZmVlZGJhY2tFbGVtZW50KTtcbiAgY29uc3QgZWxlbWVudEZyYW1lVHJhbnNmb3JtID0gZ2V0RnJhbWVUcmFuc2Zvcm0oZWxlbWVudCk7XG4gIGNvbnN0IGNyb3NzRnJhbWUgPSAhaXNTYW1lRnJhbWUoZWxlbWVudCwgZmVlZGJhY2tFbGVtZW50KTtcbiAgY29uc3Qgc2hhcGUgPSBuZXcgRE9NUmVjdGFuZ2xlKGVsZW1lbnQsIHtcbiAgICBmcmFtZVRyYW5zZm9ybTogY3Jvc3NGcmFtZSA/IGVsZW1lbnRGcmFtZVRyYW5zZm9ybSA6IG51bGwsXG4gICAgaWdub3JlVHJhbnNmb3JtczogIWNyb3NzRnJhbWVcbiAgfSk7XG4gIGNvbnN0IHNjYWxlRGVsdGEgPSB7XG4gICAgeDogZWxlbWVudEZyYW1lVHJhbnNmb3JtLnNjYWxlWCAvIGZyYW1lVHJhbnNmb3JtLnNjYWxlWCxcbiAgICB5OiBlbGVtZW50RnJhbWVUcmFuc2Zvcm0uc2NhbGVZIC8gZnJhbWVUcmFuc2Zvcm0uc2NhbGVZXG4gIH07XG4gIGxldCB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCB9ID0gc2hhcGU7XG4gIGlmIChjcm9zc0ZyYW1lKSB7XG4gICAgd2lkdGggPSB3aWR0aCAvIHNjYWxlRGVsdGEueDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgLyBzY2FsZURlbHRhLnk7XG4gIH1cbiAgbGV0IGVsZW1lbnRNdXRhdGlvbk9ic2VydmVyO1xuICBsZXQgZG9jdW1lbnRNdXRhdGlvbk9ic2VydmVyO1xuICBjb25zdCBzdHlsZXMgPSBuZXcgU3R5bGVzKGZlZWRiYWNrRWxlbWVudCk7XG4gIGNvbnN0IHtcbiAgICB0cmFuc2l0aW9uLFxuICAgIHRyYW5zbGF0ZSxcbiAgICBib3hTaXppbmcsXG4gICAgcGFkZGluZ0Jsb2NrU3RhcnQsXG4gICAgcGFkZGluZ0Jsb2NrRW5kLFxuICAgIHBhZGRpbmdJbmxpbmVTdGFydCxcbiAgICBwYWRkaW5nSW5saW5lRW5kLFxuICAgIGJvcmRlcklubGluZVN0YXJ0V2lkdGgsXG4gICAgYm9yZGVySW5saW5lRW5kV2lkdGgsXG4gICAgYm9yZGVyQmxvY2tTdGFydFdpZHRoLFxuICAgIGJvcmRlckJsb2NrRW5kV2lkdGhcbiAgfSA9IGdldENvbXB1dGVkU3R5bGVzKGVsZW1lbnQpO1xuICBjb25zdCBjbG9uZSA9IGZlZWRiYWNrID09PSBcImNsb25lXCI7XG4gIGNvbnN0IGNvbnRlbnRCb3ggPSBib3hTaXppbmcgPT09IFwiY29udGVudC1ib3hcIjtcbiAgY29uc3Qgd2lkdGhPZmZzZXQgPSBjb250ZW50Qm94ID8gcGFyc2VJbnQocGFkZGluZ0lubGluZVN0YXJ0KSArIHBhcnNlSW50KHBhZGRpbmdJbmxpbmVFbmQpICsgcGFyc2VJbnQoYm9yZGVySW5saW5lU3RhcnRXaWR0aCkgKyBwYXJzZUludChib3JkZXJJbmxpbmVFbmRXaWR0aCkgOiAwO1xuICBjb25zdCBoZWlnaHRPZmZzZXQgPSBjb250ZW50Qm94ID8gcGFyc2VJbnQocGFkZGluZ0Jsb2NrU3RhcnQpICsgcGFyc2VJbnQocGFkZGluZ0Jsb2NrRW5kKSArIHBhcnNlSW50KGJvcmRlckJsb2NrU3RhcnRXaWR0aCkgKyBwYXJzZUludChib3JkZXJCbG9ja0VuZFdpZHRoKSA6IDA7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gZmVlZGJhY2sgIT09IFwibW92ZVwiICYmICF0aGlzLm92ZXJsYXkgPyBjcmVhdGVQbGFjZWhvbGRlcihzb3VyY2UsIGNsb25lID8gXCJjbG9uZVwiIDogXCJoaWRkZW5cIikgOiBudWxsO1xuICBjb25zdCBpc0tleWJvYXJkT3BlcmF0aW9uID0gdW50cmFja2VkKFxuICAgICgpID0+IGlzS2V5Ym9hcmRFdmVudChtYW5hZ2VyLmRyYWdPcGVyYXRpb24uYWN0aXZhdG9yRXZlbnQpXG4gICk7XG4gIGlmICh0cmFuc2xhdGUgIT09IFwibm9uZVwiKSB7XG4gICAgY29uc3QgcGFyc2VkVHJhbnNsYXRlID0gcGFyc2VUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICBpZiAocGFyc2VkVHJhbnNsYXRlICYmICFpbml0aWFsLnRyYW5zbGF0ZSkge1xuICAgICAgaW5pdGlhbC50cmFuc2xhdGUgPSBwYXJzZWRUcmFuc2xhdGU7XG4gICAgfVxuICB9XG4gIGlmICghaW5pdGlhbC50cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdW50cmFja2VkKCgpID0+IHBvc2l0aW9uLmN1cnJlbnQpO1xuICAgIGluaXRpYWwudHJhbnNmb3JtT3JpZ2luID0ge1xuICAgICAgeDogKGN1cnJlbnQueCAtIGxlZnQgKiBmcmFtZVRyYW5zZm9ybS5zY2FsZVggLSBmcmFtZVRyYW5zZm9ybS54KSAvICh3aWR0aCAqIGZyYW1lVHJhbnNmb3JtLnNjYWxlWCksXG4gICAgICB5OiAoY3VycmVudC55IC0gdG9wICogZnJhbWVUcmFuc2Zvcm0uc2NhbGVZIC0gZnJhbWVUcmFuc2Zvcm0ueSkgLyAoaGVpZ2h0ICogZnJhbWVUcmFuc2Zvcm0uc2NhbGVZKVxuICAgIH07XG4gIH1cbiAgY29uc3QgeyB0cmFuc2Zvcm1PcmlnaW4gfSA9IGluaXRpYWw7XG4gIGNvbnN0IHJlbGF0aXZlVG9wID0gdG9wICogZnJhbWVUcmFuc2Zvcm0uc2NhbGVZICsgZnJhbWVUcmFuc2Zvcm0ueTtcbiAgY29uc3QgcmVsYXRpdmVMZWZ0ID0gbGVmdCAqIGZyYW1lVHJhbnNmb3JtLnNjYWxlWCArIGZyYW1lVHJhbnNmb3JtLng7XG4gIGlmICghaW5pdGlhbC5jb29yZGluYXRlcykge1xuICAgIGluaXRpYWwuY29vcmRpbmF0ZXMgPSB7XG4gICAgICB4OiByZWxhdGl2ZUxlZnQsXG4gICAgICB5OiByZWxhdGl2ZVRvcFxuICAgIH07XG4gICAgaWYgKHNjYWxlRGVsdGEueCAhPT0gMSB8fCBzY2FsZURlbHRhLnkgIT09IDEpIHtcbiAgICAgIGNvbnN0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IGVsZW1lbnRGcmFtZVRyYW5zZm9ybTtcbiAgICAgIGNvbnN0IHsgeDogdFgyLCB5OiB0WTIgfSA9IHRyYW5zZm9ybU9yaWdpbjtcbiAgICAgIGluaXRpYWwuY29vcmRpbmF0ZXMueCArPSAod2lkdGggKiBzY2FsZVggLSB3aWR0aCkgKiB0WDI7XG4gICAgICBpbml0aWFsLmNvb3JkaW5hdGVzLnkgKz0gKGhlaWdodCAqIHNjYWxlWSAtIGhlaWdodCkgKiB0WTI7XG4gICAgfVxuICB9XG4gIGlmICghaW5pdGlhbC5kaW1lbnNpb25zKSB7XG4gICAgaW5pdGlhbC5kaW1lbnNpb25zID0geyB3aWR0aCwgaGVpZ2h0IH07XG4gIH1cbiAgaWYgKCFpbml0aWFsLmZyYW1lVHJhbnNmb3JtKSB7XG4gICAgaW5pdGlhbC5mcmFtZVRyYW5zZm9ybSA9IGZyYW1lVHJhbnNmb3JtO1xuICB9XG4gIGNvbnN0IGNvb3JkaW5hdGVzRGVsdGEgPSB7XG4gICAgeDogaW5pdGlhbC5jb29yZGluYXRlcy54IC0gcmVsYXRpdmVMZWZ0LFxuICAgIHk6IGluaXRpYWwuY29vcmRpbmF0ZXMueSAtIHJlbGF0aXZlVG9wXG4gIH07XG4gIGNvbnN0IHNpemVEZWx0YSA9IHtcbiAgICB3aWR0aDogKGluaXRpYWwuZGltZW5zaW9ucy53aWR0aCAqIGluaXRpYWwuZnJhbWVUcmFuc2Zvcm0uc2NhbGVYIC0gd2lkdGggKiBmcmFtZVRyYW5zZm9ybS5zY2FsZVgpICogdHJhbnNmb3JtT3JpZ2luLngsXG4gICAgaGVpZ2h0OiAoaW5pdGlhbC5kaW1lbnNpb25zLmhlaWdodCAqIGluaXRpYWwuZnJhbWVUcmFuc2Zvcm0uc2NhbGVZIC0gaGVpZ2h0ICogZnJhbWVUcmFuc2Zvcm0uc2NhbGVZKSAqIHRyYW5zZm9ybU9yaWdpbi55XG4gIH07XG4gIGNvbnN0IGRlbHRhID0ge1xuICAgIHg6IGNvb3JkaW5hdGVzRGVsdGEueCAvIGZyYW1lVHJhbnNmb3JtLnNjYWxlWCArIHNpemVEZWx0YS53aWR0aCxcbiAgICB5OiBjb29yZGluYXRlc0RlbHRhLnkgLyBmcmFtZVRyYW5zZm9ybS5zY2FsZVkgKyBzaXplRGVsdGEuaGVpZ2h0XG4gIH07XG4gIGNvbnN0IHByb2plY3RlZCA9IHtcbiAgICBsZWZ0OiBsZWZ0ICsgZGVsdGEueCxcbiAgICB0b3A6IHRvcCArIGRlbHRhLnlcbiAgfTtcbiAgZmVlZGJhY2tFbGVtZW50LnNldEF0dHJpYnV0ZShBVFRSSUJVVEUsIFwidHJ1ZVwiKTtcbiAgY29uc3QgdHJhbnNmb3JtID0gdW50cmFja2VkKCgpID0+IGRyYWdPcGVyYXRpb24udHJhbnNmb3JtKTtcbiAgY29uc3QgaW5pdGlhbFRyYW5zbGF0ZSA9IChfYjIgPSBpbml0aWFsLnRyYW5zbGF0ZSkgIT0gbnVsbCA/IF9iMiA6IHsgeDogMCwgeTogMCB9O1xuICBjb25zdCB0WCA9IHRyYW5zZm9ybS54ICogZnJhbWVUcmFuc2Zvcm0uc2NhbGVYICsgaW5pdGlhbFRyYW5zbGF0ZS54O1xuICBjb25zdCB0WSA9IHRyYW5zZm9ybS55ICogZnJhbWVUcmFuc2Zvcm0uc2NhbGVZICsgaW5pdGlhbFRyYW5zbGF0ZS55O1xuICBjb25zdCB0cmFuc2xhdGVTdHJpbmcgPSBgJHt0WH1weCAke3RZfXB4IDBgO1xuICBjb25zdCB0cmFuc2l0aW9uU3RyaW5nID0gdHJhbnNpdGlvbiA/IGAke3RyYW5zaXRpb259LCB0cmFuc2xhdGUgMG1zIGxpbmVhcmAgOiBcIlwiO1xuICBzdHlsZXMuc2V0KFxuICAgIHtcbiAgICAgIHdpZHRoOiB3aWR0aCAtIHdpZHRoT2Zmc2V0LFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgLSBoZWlnaHRPZmZzZXQsXG4gICAgICB0b3A6IHByb2plY3RlZC50b3AsXG4gICAgICBsZWZ0OiBwcm9qZWN0ZWQubGVmdCxcbiAgICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlU3RyaW5nLFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvblN0cmluZyxcbiAgICAgIHNjYWxlOiBjcm9zc0ZyYW1lID8gYCR7c2NhbGVEZWx0YS54fSAke3NjYWxlRGVsdGEueX1gIDogXCJcIixcbiAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHt0cmFuc2Zvcm1PcmlnaW4ueCAqIDEwMH0lICR7dHJhbnNmb3JtT3JpZ2luLnkgKiAxMDB9JWBcbiAgICB9LFxuICAgIENTU19QUkVGSVhcbiAgKTtcbiAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgZWxlbWVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLCBwbGFjZWhvbGRlcik7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucm9vdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSB0eXBlb2Ygb3B0aW9ucy5yb290RWxlbWVudCA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yb290RWxlbWVudChzb3VyY2UpIDogb3B0aW9ucy5yb290RWxlbWVudDtcbiAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGlmIChzdXBwb3J0c1BvcG92ZXIoZmVlZGJhY2tFbGVtZW50KSkge1xuICAgIGlmICghZmVlZGJhY2tFbGVtZW50Lmhhc0F0dHJpYnV0ZShcInBvcG92ZXJcIikpIHtcbiAgICAgIGZlZWRiYWNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwb3BvdmVyXCIsIFwibWFudWFsXCIpO1xuICAgIH1cbiAgICBzaG93UG9wb3ZlcihmZWVkYmFja0VsZW1lbnQpO1xuICAgIGZlZWRiYWNrRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldG9nZ2xlXCIsIHByZXZlbnRQb3BvdmVyQ2xvc2UpO1xuICB9XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICBpZiAoIXBsYWNlaG9sZGVyKSByZXR1cm47XG4gICAgY29uc3QgcGxhY2Vob2xkZXJTaGFwZSA9IG5ldyBET01SZWN0YW5nbGUocGxhY2Vob2xkZXIsIHtcbiAgICAgIGZyYW1lVHJhbnNmb3JtLFxuICAgICAgaWdub3JlVHJhbnNmb3JtczogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbiAhPSBudWxsID8gdHJhbnNmb3JtT3JpZ2luIDogeyB4OiAxLCB5OiAxIH07XG4gICAgY29uc3QgZFggPSAod2lkdGggLSBwbGFjZWhvbGRlclNoYXBlLndpZHRoKSAqIG9yaWdpbi54ICsgZGVsdGEueDtcbiAgICBjb25zdCBkWSA9IChoZWlnaHQgLSBwbGFjZWhvbGRlclNoYXBlLmhlaWdodCkgKiBvcmlnaW4ueSArIGRlbHRhLnk7XG4gICAgc3R5bGVzLnNldChcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IHBsYWNlaG9sZGVyU2hhcGUud2lkdGggLSB3aWR0aE9mZnNldCxcbiAgICAgICAgaGVpZ2h0OiBwbGFjZWhvbGRlclNoYXBlLmhlaWdodCAtIGhlaWdodE9mZnNldCxcbiAgICAgICAgdG9wOiB0b3AgKyBkWSxcbiAgICAgICAgbGVmdDogbGVmdCArIGRYXG4gICAgICB9LFxuICAgICAgQ1NTX1BSRUZJWFxuICAgICk7XG4gICAgZWxlbWVudE11dGF0aW9uT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRNdXRhdGlvbk9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgaWYgKGlzVGFibGVSb3coZWxlbWVudCkgJiYgaXNUYWJsZVJvdyhwbGFjZWhvbGRlcikpIHtcbiAgICAgIGNvbnN0IGNlbGxzID0gQXJyYXkuZnJvbShlbGVtZW50LmNlbGxzKTtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyQ2VsbHMgPSBBcnJheS5mcm9tKHBsYWNlaG9sZGVyLmNlbGxzKTtcbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjZWxsXSBvZiBjZWxscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJDZWxsID0gcGxhY2Vob2xkZXJDZWxsc1tpbmRleF07XG4gICAgICAgIGNlbGwuc3R5bGUud2lkdGggPSBgJHtwbGFjZWhvbGRlckNlbGwub2Zmc2V0V2lkdGh9cHhgO1xuICAgICAgfVxuICAgIH1cbiAgICBkcmFnT3BlcmF0aW9uLnNoYXBlID0gbmV3IERPTVJlY3RhbmdsZShmZWVkYmFja0VsZW1lbnQpO1xuICB9KTtcbiAgY29uc3QgaW5pdGlhbFNoYXBlID0gbmV3IERPTVJlY3RhbmdsZShmZWVkYmFja0VsZW1lbnQpO1xuICB1bnRyYWNrZWQoKCkgPT4gZHJhZ09wZXJhdGlvbi5zaGFwZSA9IGluaXRpYWxTaGFwZSk7XG4gIGNvbnN0IGZlZWRiYWNrV2luZG93ID0gZ2V0V2luZG93KGZlZWRiYWNrRWxlbWVudCk7XG4gIGNvbnN0IGhhbmRsZVdpbmRvd1Jlc2l6ZSA9IChldmVudCkgPT4ge1xuICAgIHRoaXMubWFuYWdlci5hY3Rpb25zLnN0b3AoeyBldmVudCB9KTtcbiAgfTtcbiAgaWYgKGlzS2V5Ym9hcmRPcGVyYXRpb24pIHtcbiAgICBmZWVkYmFja1dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgaWYgKHVudHJhY2tlZCgoKSA9PiBzb3VyY2Uuc3RhdHVzKSA9PT0gXCJpZGxlXCIpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc291cmNlLnN0YXR1cyA9IFwiZHJhZ2dpbmdcIik7XG4gIH1cbiAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShwbGFjZWhvbGRlcik7XG4gICAgZWxlbWVudE11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICBsZXQgaGFzQ2hpbGRyZW5NdXRhdGlvbnMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50YXJnZXQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBoYXNDaGlsZHJlbk11dGF0aW9ucyA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgIT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lLnN0YXJ0c1dpdGgoXCJhcmlhLVwiKSB8fCBJR05PUkVEX0FUVFJJQlVURVMuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU3R5bGUoZWxlbWVudCkgJiYgc3VwcG9ydHNTdHlsZShwbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlczIgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgQXJyYXkuZnJvbShwbGFjZWhvbGRlci5zdHlsZSkpIHtcbiAgICAgICAgICAgICAgaWYgKHN0eWxlczIuZ2V0UHJvcGVydHlWYWx1ZShrZXkpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgQXJyYXkuZnJvbShzdHlsZXMyKSkge1xuICAgICAgICAgICAgICBpZiAoSUdOT1JFRF9TVFlMRVMuaW5jbHVkZXMoa2V5KSB8fCBrZXkuc3RhcnRzV2l0aChDU1NfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzMi5nZXRQcm9wZXJ0eVZhbHVlKGtleSk7XG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2Vob2xkZXIucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hpbGRyZW5NdXRhdGlvbnMgJiYgY2xvbmUpIHtcbiAgICAgICAgcGxhY2Vob2xkZXIuaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWxlbWVudE11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgIH0pO1xuICAgIGRvY3VtZW50TXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGVudHJ5LmFkZGVkTm9kZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIEFycmF5LmZyb20oZW50cnkuYWRkZWROb2RlcykpIHtcbiAgICAgICAgICBpZiAobm9kZS5jb250YWlucyhlbGVtZW50KSAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZyAhPT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgc2hvd1BvcG92ZXIoZmVlZGJhY2tFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUuY29udGFpbnMocGxhY2Vob2xkZXIpICYmIHBsYWNlaG9sZGVyLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWJlZ2luXCIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgc2hvd1BvcG92ZXIoZmVlZGJhY2tFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudE11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keSwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGlkID0gKF9jMyA9IG1hbmFnZXIuZHJhZ09wZXJhdGlvbi5zb3VyY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYzMuaWQ7XG4gIGNvbnN0IHJlc3RvcmVGb2N1cyA9ICgpID0+IHtcbiAgICB2YXIgX2E1O1xuICAgIGlmICghaXNLZXlib2FyZE9wZXJhdGlvbiB8fCBpZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRyYWdnYWJsZSA9IG1hbmFnZXIucmVnaXN0cnkuZHJhZ2dhYmxlcy5nZXQoaWQpO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gKF9hNSA9IGRyYWdnYWJsZSA9PSBudWxsID8gdm9pZCAwIDogZHJhZ2dhYmxlLmhhbmRsZSkgIT0gbnVsbCA/IF9hNSA6IGRyYWdnYWJsZSA9PSBudWxsID8gdm9pZCAwIDogZHJhZ2dhYmxlLmVsZW1lbnQ7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudDIpKSB7XG4gICAgICBlbGVtZW50Mi5mb2N1cygpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBlbGVtZW50TXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudE11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGRvY3VtZW50TXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnRNdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZmVlZGJhY2tXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgIGlmIChzdXBwb3J0c1BvcG92ZXIoZmVlZGJhY2tFbGVtZW50KSkge1xuICAgICAgZmVlZGJhY2tFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYmVmb3JldG9nZ2xlXCIsXG4gICAgICAgIHByZXZlbnRQb3BvdmVyQ2xvc2VcbiAgICAgICk7XG4gICAgICBmZWVkYmFja0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicG9wb3ZlclwiKTtcbiAgICB9XG4gICAgZmVlZGJhY2tFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShBVFRSSUJVVEUpO1xuICAgIHN0eWxlcy5yZXNldCgpO1xuICAgIHNvdXJjZS5zdGF0dXMgPSBcImlkbGVcIjtcbiAgICBjb25zdCBtb3ZlZCA9IHN0YXRlLmN1cnJlbnQudHJhbnNsYXRlICE9IG51bGw7XG4gICAgaWYgKHBsYWNlaG9sZGVyICYmIChtb3ZlZCB8fCBwbGFjZWhvbGRlci5wYXJlbnRFbGVtZW50ICE9PSBmZWVkYmFja0VsZW1lbnQucGFyZW50RWxlbWVudCkgJiYgZmVlZGJhY2tFbGVtZW50LmlzQ29ubmVjdGVkKSB7XG4gICAgICBwbGFjZWhvbGRlci5yZXBsYWNlV2l0aChmZWVkYmFja0VsZW1lbnQpO1xuICAgIH1cbiAgICBwbGFjZWhvbGRlciA9PSBudWxsID8gdm9pZCAwIDogcGxhY2Vob2xkZXIucmVtb3ZlKCk7XG4gIH07XG4gIGNvbnN0IGNsZWFudXBFZmZlY3RzID0gZWZmZWN0cyhcbiAgICAvLyBVcGRhdGUgdHJhbnNmb3JtIG9uIG1vdmVcbiAgICAoKSA9PiB7XG4gICAgICB2YXIgX2E1O1xuICAgICAgY29uc3QgeyB0cmFuc2Zvcm06IHRyYW5zZm9ybTIsIHN0YXR1czogc3RhdHVzMiB9ID0gZHJhZ09wZXJhdGlvbjtcbiAgICAgIGlmICghdHJhbnNmb3JtMi54ICYmICF0cmFuc2Zvcm0yLnkgJiYgIXN0YXRlLmN1cnJlbnQudHJhbnNsYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0dXMyLmRyYWdnaW5nKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxUcmFuc2xhdGUyID0gKF9hNSA9IGluaXRpYWwudHJhbnNsYXRlKSAhPSBudWxsID8gX2E1IDogeyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZTIgPSB7XG4gICAgICAgICAgeDogdHJhbnNmb3JtMi54IC8gZnJhbWVUcmFuc2Zvcm0uc2NhbGVYICsgaW5pdGlhbFRyYW5zbGF0ZTIueCxcbiAgICAgICAgICB5OiB0cmFuc2Zvcm0yLnkgLyBmcmFtZVRyYW5zZm9ybS5zY2FsZVkgKyBpbml0aWFsVHJhbnNsYXRlMi55XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVHJhbnNsYXRlID0gc3RhdGUuY3VycmVudC50cmFuc2xhdGU7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IHVudHJhY2tlZCgoKSA9PiBkcmFnT3BlcmF0aW9uLm1vZGlmaWVycyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaGFwZSA9IHVudHJhY2tlZCgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hNjtcbiAgICAgICAgICByZXR1cm4gKF9hNiA9IGRyYWdPcGVyYXRpb24uc2hhcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTYuY3VycmVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZVRyYW5zaXRpb24gPSBpc0tleWJvYXJkT3BlcmF0aW9uID8gXCIyNTBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMSwgMC41LCAxKVwiIDogXCIwbXMgbGluZWFyXCI7XG4gICAgICAgIHN0eWxlcy5zZXQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogYCR7dHJhbnNpdGlvbn0sIHRyYW5zbGF0ZSAke3RyYW5zbGF0ZVRyYW5zaXRpb259YCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogYCR7dHJhbnNsYXRlMi54fXB4ICR7dHJhbnNsYXRlMi55fXB4IDBgXG4gICAgICAgICAgfSxcbiAgICAgICAgICBDU1NfUFJFRklYXG4gICAgICAgICk7XG4gICAgICAgIGVsZW1lbnRNdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50TXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICBpZiAoY3VycmVudFNoYXBlICYmIGN1cnJlbnRTaGFwZSAhPT0gaW5pdGlhbFNoYXBlICYmIHByZXZpb3VzVHJhbnNsYXRlICYmICFtb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZGVsdGEyID0gUG9pbnQuZGVsdGEodHJhbnNsYXRlMiwgcHJldmlvdXNUcmFuc2xhdGUpO1xuICAgICAgICAgIGRyYWdPcGVyYXRpb24uc2hhcGUgPSBSZWN0YW5nbGUuZnJvbShcbiAgICAgICAgICAgIGN1cnJlbnRTaGFwZS5ib3VuZGluZ1JlY3RhbmdsZVxuICAgICAgICAgICkudHJhbnNsYXRlKFxuICAgICAgICAgICAgLy8gTmVlZCB0byB0YWtlIGludG8gYWNjb3VudCBmcmFtZSB0cmFuc2Zvcm0gd2hlbiBvcHRpbWlzdGljYWxseSB1cGRhdGluZyBzaGFwZVxuICAgICAgICAgICAgZGVsdGEyLnggKiBmcmFtZVRyYW5zZm9ybS5zY2FsZVgsXG4gICAgICAgICAgICBkZWx0YTIueSAqIGZyYW1lVHJhbnNmb3JtLnNjYWxlWVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ09wZXJhdGlvbi5zaGFwZSA9IG5ldyBET01SZWN0YW5nbGUoZmVlZGJhY2tFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jdXJyZW50LnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTI7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEcm9wIGFuaW1hdGlvblxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRyYWdPcGVyYXRpb24uc3RhdHVzLmRyb3BwZWQpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHNvdXJjZS5zdGF0dXMgPSBcImRyb3BwaW5nXCI7XG4gICAgICAgIGxldCB0cmFuc2xhdGUyID0gc3RhdGUuY3VycmVudC50cmFuc2xhdGU7XG4gICAgICAgIGNvbnN0IG1vdmVkID0gdHJhbnNsYXRlMiAhPSBudWxsO1xuICAgICAgICBpZiAoIXRyYW5zbGF0ZTIgJiYgZWxlbWVudCAhPT0gZmVlZGJhY2tFbGVtZW50KSB7XG4gICAgICAgICAgdHJhbnNsYXRlMiA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYW5zbGF0ZTIpIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyb3BBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hNSwgX2IzO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNob3dQb3BvdmVyKGZlZWRiYWNrRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBbLCBhbmltYXRpb25dID0gKF9hNSA9IGdldEZpbmFsS2V5ZnJhbWUoXG4gICAgICAgICAgICAgIGZlZWRiYWNrRWxlbWVudCxcbiAgICAgICAgICAgICAgKGtleWZyYW1lKSA9PiBcInRyYW5zbGF0ZVwiIGluIGtleWZyYW1lXG4gICAgICAgICAgICApKSAhPSBudWxsID8gX2E1IDogW107XG4gICAgICAgICAgICBhbmltYXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGxhY2Vob2xkZXIgIT0gbnVsbCA/IHBsYWNlaG9sZGVyIDogZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMyID0ge1xuICAgICAgICAgICAgICBmcmFtZVRyYW5zZm9ybTogaXNTYW1lRnJhbWUoZmVlZGJhY2tFbGVtZW50LCB0YXJnZXQpID8gbnVsbCA6IHZvaWQgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuZXcgRE9NUmVjdGFuZ2xlKGZlZWRiYWNrRWxlbWVudCwgb3B0aW9uczIpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZSA9IChfYjMgPSBwYXJzZVRyYW5zbGF0ZShnZXRDb21wdXRlZFN0eWxlcyhmZWVkYmFja0VsZW1lbnQpLnRyYW5zbGF0ZSkpICE9IG51bGwgPyBfYjMgOiB0cmFuc2xhdGUyO1xuICAgICAgICAgICAgY29uc3QgZmluYWwgPSBuZXcgRE9NUmVjdGFuZ2xlKHRhcmdldCwgb3B0aW9uczIpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEyID0gUmVjdGFuZ2xlLmRlbHRhKGN1cnJlbnQsIGZpbmFsLCBzb3VyY2UuYWxpZ25tZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVHJhbnNsYXRlID0ge1xuICAgICAgICAgICAgICB4OiBjdXJyZW50VHJhbnNsYXRlLnggLSBkZWx0YTIueCxcbiAgICAgICAgICAgICAgeTogY3VycmVudFRyYW5zbGF0ZS55IC0gZGVsdGEyLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRLZXlmcmFtZXMgPSBNYXRoLnJvdW5kKGN1cnJlbnQuaW50cmluc2ljSGVpZ2h0KSAhPT0gTWF0aC5yb3VuZChmaW5hbC5pbnRyaW5zaWNIZWlnaHQpID8ge1xuICAgICAgICAgICAgICBtaW5IZWlnaHQ6IFtcbiAgICAgICAgICAgICAgICBgJHtjdXJyZW50LmludHJpbnNpY0hlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgYCR7ZmluYWwuaW50cmluc2ljSGVpZ2h0fXB4YFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBtYXhIZWlnaHQ6IFtcbiAgICAgICAgICAgICAgICBgJHtjdXJyZW50LmludHJpbnNpY0hlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgYCR7ZmluYWwuaW50cmluc2ljSGVpZ2h0fXB4YFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9IDoge307XG4gICAgICAgICAgICBjb25zdCB3aWR0aEtleWZyYW1lcyA9IE1hdGgucm91bmQoY3VycmVudC5pbnRyaW5zaWNXaWR0aCkgIT09IE1hdGgucm91bmQoZmluYWwuaW50cmluc2ljV2lkdGgpID8ge1xuICAgICAgICAgICAgICBtaW5XaWR0aDogW1xuICAgICAgICAgICAgICAgIGAke2N1cnJlbnQuaW50cmluc2ljV2lkdGh9cHhgLFxuICAgICAgICAgICAgICAgIGAke2ZpbmFsLmludHJpbnNpY1dpZHRofXB4YFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBtYXhXaWR0aDogW1xuICAgICAgICAgICAgICAgIGAke2N1cnJlbnQuaW50cmluc2ljV2lkdGh9cHhgLFxuICAgICAgICAgICAgICAgIGAke2ZpbmFsLmludHJpbnNpY1dpZHRofXB4YFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9IDoge307XG4gICAgICAgICAgICBzdHlsZXMuc2V0KHsgdHJhbnNpdGlvbiB9LCBDU1NfUFJFRklYKTtcbiAgICAgICAgICAgIGZlZWRiYWNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoRFJPUFBJTkdfQVRUUklCVVRFLCBcIlwiKTtcbiAgICAgICAgICAgIGVsZW1lbnRNdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50TXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgYW5pbWF0ZVRyYW5zZm9ybSh7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IGZlZWRiYWNrRWxlbWVudCxcbiAgICAgICAgICAgICAga2V5ZnJhbWVzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBoZWlnaHRLZXlmcmFtZXMpLCB3aWR0aEtleWZyYW1lcyksIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGU6IFtcbiAgICAgICAgICAgICAgICAgIGAke2N1cnJlbnRUcmFuc2xhdGUueH1weCAke2N1cnJlbnRUcmFuc2xhdGUueX1weCAwYCxcbiAgICAgICAgICAgICAgICAgIGAke2ZpbmFsVHJhbnNsYXRlLnh9cHggJHtmaW5hbFRyYW5zbGF0ZS55fXB4IDBgXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBtb3ZlZCB8fCBmZWVkYmFja0VsZW1lbnQgIT09IGVsZW1lbnQgPyAyNTAgOiAwLFxuICAgICAgICAgICAgICAgIGVhc2luZzogXCJlYXNlXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGZlZWRiYWNrRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoRFJPUFBJTkdfQVRUUklCVVRFKTtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBhbmltYXRpb24uZmluaXNoKCk7XG4gICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3RvcmVGb2N1cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1hbmFnZXIucmVuZGVyZXIucmVuZGVyaW5nLnRoZW4oZHJvcEFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICApO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgICBjbGVhbnVwRWZmZWN0cygpO1xuICB9O1xufTtcbmluamVjdFN0eWxlc19mbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2E0LCBfYjIsIF9jMztcbiAgY29uc3QgeyBzdGF0dXMsIHNvdXJjZSwgdGFyZ2V0IH0gPSB0aGlzLm1hbmFnZXIuZHJhZ09wZXJhdGlvbjtcbiAgY29uc3QgeyBub25jZSB9ID0gKF9hNCA9IHRoaXMub3B0aW9ucykgIT0gbnVsbCA/IF9hNCA6IHt9O1xuICBpZiAoc3RhdHVzLmluaXRpYWxpemluZykge1xuICAgIGNvbnN0IHNvdXJjZURvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKF9iMiA9IHNvdXJjZSA9PSBudWxsID8gdm9pZCAwIDogc291cmNlLmVsZW1lbnQpICE9IG51bGwgPyBfYjIgOiBudWxsKTtcbiAgICBjb25zdCB0YXJnZXREb2N1bWVudCA9IGdldERvY3VtZW50KChfYzMgPSB0YXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldC5lbGVtZW50KSAhPSBudWxsID8gX2MzIDogbnVsbCk7XG4gICAgY29uc3QgZG9jdW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW3NvdXJjZURvY3VtZW50LCB0YXJnZXREb2N1bWVudF0pO1xuICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3VtZW50cykge1xuICAgICAgbGV0IHJlZ2lzdHJhdGlvbiA9IHN0eWxlU2hlZXRSZWdpc3RyeS5nZXQoZG9jKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IENTU19SVUxFUztcbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5oZWFkLnByZXBlbmQoc3R5bGUpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWROb2RlcyA9IEFycmF5LmZyb20oZW50cnkucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5sZW5ndGggPiAwICYmIHJlbW92ZWROb2Rlcy5pbmNsdWRlcyhzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBkb2MuaGVhZC5wcmVwZW5kKHN0eWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShkb2MuaGVhZCwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IHtcbiAgICAgICAgICBjbGVhbnVwOiAoKSA9PiB7XG4gICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zdGFuY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgICAgIH07XG4gICAgICAgIHN0eWxlU2hlZXRSZWdpc3RyeS5zZXQoZG9jLCByZWdpc3RyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmVnaXN0cmF0aW9uLmluc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUVsZW1lbnQoX2luaXQsIDQsIFwib3ZlcmxheVwiLCBfb3ZlcmxheV9kZWMsIF9GZWVkYmFjaywgX292ZXJsYXkpO1xuX19kZWNvcmF0b3JNZXRhZGF0YShfaW5pdCwgX0ZlZWRiYWNrKTtcbl9GZWVkYmFjay5jb25maWd1cmUgPSBjb25maWd1cmF0b3IoX0ZlZWRiYWNrKTtcbnZhciBGZWVkYmFjayA9IF9GZWVkYmFjaztcbnZhciBMT0NLRUQgPSB0cnVlO1xudmFyIFVOTE9DS0VEID0gZmFsc2U7XG52YXIgX2RlYywgX2EyLCBfZGVjMiwgX2IsIF9pbml0MiwgX19iLCBfX2E7XG5fYiA9IChfZGVjMiA9IFtyZWFjdGl2ZV0sIFNjcm9sbERpcmVjdGlvbi5Gb3J3YXJkKSwgX2EyID0gKF9kZWMgPSBbcmVhY3RpdmVdLCBTY3JvbGxEaXJlY3Rpb24uUmV2ZXJzZSk7XG52YXIgU2Nyb2xsTG9jayA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9fYiwgX19ydW5Jbml0aWFsaXplcnMoX2luaXQyLCA4LCB0aGlzLCBMT0NLRUQpKSwgX19ydW5Jbml0aWFsaXplcnMoX2luaXQyLCAxMSwgdGhpcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9fYSwgX19ydW5Jbml0aWFsaXplcnMoX2luaXQyLCAxMiwgdGhpcywgTE9DS0VEKSksIF9fcnVuSW5pdGlhbGl6ZXJzKF9pbml0MiwgMTUsIHRoaXMpO1xuICB9XG4gIGlzTG9ja2VkKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFNjcm9sbERpcmVjdGlvbi5JZGxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXNbU2Nyb2xsRGlyZWN0aW9uLkZvcndhcmRdID09PSBMT0NLRUQgJiYgdGhpc1tTY3JvbGxEaXJlY3Rpb24uUmV2ZXJzZV0gPT09IExPQ0tFRDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbZGlyZWN0aW9uXSA9PT0gTE9DS0VEO1xuICB9XG4gIHVubG9jayhkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uSWRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzW2RpcmVjdGlvbl0gPSBVTkxPQ0tFRDtcbiAgfVxufTtcbl9pbml0MiA9IF9fZGVjb3JhdG9yU3RhcnQobnVsbCk7XG5fX2IgPSBuZXcgV2Vha01hcCgpO1xuX19hID0gbmV3IFdlYWtNYXAoKTtcbl9fZGVjb3JhdGVFbGVtZW50KF9pbml0MiwgNCwgX2IsIF9kZWMyLCBTY3JvbGxMb2NrLCBfX2IpO1xuX19kZWNvcmF0ZUVsZW1lbnQoX2luaXQyLCA0LCBfYTIsIF9kZWMsIFNjcm9sbExvY2ssIF9fYSk7XG5fX2RlY29yYXRvck1ldGFkYXRhKF9pbml0MiwgU2Nyb2xsTG9jayk7XG5cbi8vIHNyYy9jb3JlL3BsdWdpbnMvc2Nyb2xsaW5nL1Njcm9sbEludGVudC50c1xudmFyIERJUkVDVElPTlMgPSBbU2Nyb2xsRGlyZWN0aW9uLkZvcndhcmQsIFNjcm9sbERpcmVjdGlvbi5SZXZlcnNlXTtcbnZhciBTY3JvbGxJbnRlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueCA9IG5ldyBTY3JvbGxMb2NrKCk7XG4gICAgdGhpcy55ID0gbmV3IFNjcm9sbExvY2soKTtcbiAgfVxuICBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy54LmlzTG9ja2VkKCkgJiYgdGhpcy55LmlzTG9ja2VkKCk7XG4gIH1cbn07XG52YXIgU2Nyb2xsSW50ZW50VHJhY2tlciA9IGNsYXNzIGV4dGVuZHMgUGx1Z2luIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIGNvbnN0IHNjcm9sbEludGVudCA9IHNpZ25hbChuZXcgU2Nyb2xsSW50ZW50KCkpO1xuICAgIGxldCBwcmV2aW91c0RlbHRhID0gbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IHNjcm9sbEludGVudDtcbiAgICBlZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IG1hbmFnZXIuZHJhZ09wZXJhdGlvbjtcbiAgICAgIGlmICghc3RhdHVzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHByZXZpb3VzRGVsdGEgPSBudWxsO1xuICAgICAgICBzY3JvbGxJbnRlbnQudmFsdWUgPSBuZXcgU2Nyb2xsSW50ZW50KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGVsdGEgfSA9IG1hbmFnZXIuZHJhZ09wZXJhdGlvbi5wb3NpdGlvbjtcbiAgICAgIGlmIChwcmV2aW91c0RlbHRhKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSB7XG4gICAgICAgICAgeDogZ2V0RGlyZWN0aW9uKGRlbHRhLngsIHByZXZpb3VzRGVsdGEueCksXG4gICAgICAgICAgeTogZ2V0RGlyZWN0aW9uKGRlbHRhLnksIHByZXZpb3VzRGVsdGEueSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW50ZW50ID0gc2Nyb2xsSW50ZW50LnBlZWsoKTtcbiAgICAgICAgYmF0Y2goKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgYXhpcyBvZiBBeGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRpcmVjdGlvbiBvZiBESVJFQ1RJT05TKSB7XG4gICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zW2F4aXNdID09PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpbnRlbnRbYXhpc10udW5sb2NrKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsSW50ZW50LnZhbHVlID0gaW50ZW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzRGVsdGEgPSBkZWx0YTtcbiAgICB9KTtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduYWwucGVlaygpO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguc2lnbihhIC0gYik7XG59XG5cbi8vIHNyYy9jb3JlL3BsdWdpbnMvc2Nyb2xsaW5nL1Njcm9sbGVyLnRzXG52YXIgX2F1dG9TY3JvbGxpbmdfZGVjLCBfYTMsIF9pbml0MywgX2F1dG9TY3JvbGxpbmcsIF9tZXRhLCBfc2Nyb2xsO1xudmFyIFNjcm9sbGVyID0gY2xhc3MgZXh0ZW5kcyAoX2EzID0gQ29yZVBsdWdpbiwgX2F1dG9TY3JvbGxpbmdfZGVjID0gW3JlYWN0aXZlXSwgX2EzKSB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2F1dG9TY3JvbGxpbmcsIF9fcnVuSW5pdGlhbGl6ZXJzKF9pbml0MywgOCwgdGhpcywgZmFsc2UpKSwgX19ydW5Jbml0aWFsaXplcnMoX2luaXQzLCAxMSwgdGhpcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tZXRhKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3Njcm9sbCwgKCkgPT4ge1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX21ldGEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZWxlbWVudCwgYnkgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWV0YSk7XG4gICAgICBpZiAoYnkueSkgZWxlbWVudC5zY3JvbGxUb3AgKz0gYnkueTtcbiAgICAgIGlmIChieS54KSBlbGVtZW50LnNjcm9sbExlZnQgKz0gYnkueDtcbiAgICB9KTtcbiAgICB0aGlzLnNjcm9sbCA9IChvcHRpb25zKSA9PiB7XG4gICAgICB2YXIgX2E0O1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50cygpO1xuICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX21ldGEsIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcG9zaXRpb24gfSA9IHRoaXMubWFuYWdlci5kcmFnT3BlcmF0aW9uO1xuICAgICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHBvc2l0aW9uLmN1cnJlbnQ7XG4gICAgICBpZiAoY3VycmVudFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgYnkgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3QgaW50ZW50ID0gYnkgPyB7XG4gICAgICAgICAgeDogZ2V0U2Nyb2xsSW50ZW50KGJ5LngpLFxuICAgICAgICAgIHk6IGdldFNjcm9sbEludGVudChieS55KVxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICBjb25zdCBzY3JvbGxJbnRlbnQgPSBpbnRlbnQgPyB2b2lkIDAgOiB0aGlzLnNjcm9sbEludGVudFRyYWNrZXIuY3VycmVudDtcbiAgICAgICAgaWYgKHNjcm9sbEludGVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsSW50ZW50LmlzTG9ja2VkKCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzY3JvbGxhYmxlRWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRDYW5TY3JvbGwgPSBjYW5TY3JvbGwoc2Nyb2xsYWJsZUVsZW1lbnQsIGJ5KTtcbiAgICAgICAgICBpZiAoZWxlbWVudENhblNjcm9sbC54IHx8IGVsZW1lbnRDYW5TY3JvbGwueSkge1xuICAgICAgICAgICAgY29uc3QgeyBzcGVlZCwgZGlyZWN0aW9uIH0gPSBkZXRlY3RTY3JvbGxJbnRlbnQoXG4gICAgICAgICAgICAgIHNjcm9sbGFibGVFbGVtZW50LFxuICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24sXG4gICAgICAgICAgICAgIGludGVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxJbnRlbnQpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBheGlzIG9mIEF4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSW50ZW50W2F4aXNdLmlzTG9ja2VkKGRpcmVjdGlvbltheGlzXSkpIHtcbiAgICAgICAgICAgICAgICAgIHNwZWVkW2F4aXNdID0gMDtcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbltheGlzXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uLnggfHwgZGlyZWN0aW9uLnkpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBieSAhPSBudWxsID8gYnkgOiBkaXJlY3Rpb247XG4gICAgICAgICAgICAgIGNvbnN0IHNjcm9sbExlZnRCeSA9IHggKiBzcGVlZC54O1xuICAgICAgICAgICAgICBjb25zdCBzY3JvbGxUb3BCeSA9IHkgKiBzcGVlZC55O1xuICAgICAgICAgICAgICBpZiAoc2Nyb2xsTGVmdEJ5IHx8IHNjcm9sbFRvcEJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTY3JvbGxCeSA9IChfYTQgPSBfX3ByaXZhdGVHZXQodGhpcywgX21ldGEpKSA9PSBudWxsID8gdm9pZCAwIDogX2E0LmJ5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9TY3JvbGxpbmcgJiYgcHJldmlvdXNTY3JvbGxCeSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsSW50ZW50TWlzbWF0Y2ggPSBwcmV2aW91c1Njcm9sbEJ5LnggJiYgIXNjcm9sbExlZnRCeSB8fCBwcmV2aW91c1Njcm9sbEJ5LnkgJiYgIXNjcm9sbFRvcEJ5O1xuICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbEludGVudE1pc21hdGNoKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXRhLCB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBzY3JvbGxhYmxlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgIGJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHNjcm9sbExlZnRCeSxcbiAgICAgICAgICAgICAgICAgICAgeTogc2Nyb2xsVG9wQnlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoX19wcml2YXRlR2V0KHRoaXMsIF9zY3JvbGwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXRhLCB2b2lkIDApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgbGV0IHByZXZpb3VzRWxlbWVudEZyb21Qb2ludCA9IG51bGw7XG4gICAgbGV0IHByZXZpb3VzU2Nyb2xsYWJsZUVsZW1lbnRzID0gbnVsbDtcbiAgICBjb25zdCBlbGVtZW50RnJvbVBvaW50ID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbiwgc291cmNlIH0gPSBtYW5hZ2VyLmRyYWdPcGVyYXRpb247XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnRGcm9tUG9pbnQoXG4gICAgICAgIGdldERvY3VtZW50KHNvdXJjZSA9PSBudWxsID8gdm9pZCAwIDogc291cmNlLmVsZW1lbnQpLFxuICAgICAgICBwb3NpdGlvbi5jdXJyZW50XG4gICAgICApO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcHJldmlvdXNFbGVtZW50RnJvbVBvaW50ID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50IDogcHJldmlvdXNFbGVtZW50RnJvbVBvaW50O1xuICAgIH0pO1xuICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50RnJvbVBvaW50LnZhbHVlO1xuICAgICAgY29uc3QgeyBkb2N1bWVudEVsZW1lbnQgfSA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xuICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gbWFuYWdlci5kcmFnT3BlcmF0aW9uO1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQuZWxlbWVudDtcbiAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGdldFNjcm9sbGFibGVBbmNlc3RvcnModGFyZ2V0RWxlbWVudCwge1xuICAgICAgICAgICAgZXhjbHVkZUVsZW1lbnQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJldmlvdXNTY3JvbGxhYmxlRWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyhlbGVtZW50LCB7XG4gICAgICAgICAgZXhjbHVkZUVsZW1lbnQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvU2Nyb2xsaW5nICYmIHByZXZpb3VzU2Nyb2xsYWJsZUVsZW1lbnRzICYmIGVsZW1lbnRzLnNpemUgPCAocHJldmlvdXNTY3JvbGxhYmxlRWxlbWVudHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzU2Nyb2xsYWJsZUVsZW1lbnRzLnNpemUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZpb3VzU2Nyb2xsYWJsZUVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzU2Nyb2xsYWJsZUVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzU2Nyb2xsYWJsZUVsZW1lbnRzID0gbnVsbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIGRlZXBFcXVhbCk7XG4gICAgdGhpcy5nZXRTY3JvbGxhYmxlRWxlbWVudHMgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1lbnRzLnZhbHVlO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxJbnRlbnRUcmFja2VyID0gbmV3IFNjcm9sbEludGVudFRyYWNrZXIobWFuYWdlcik7XG4gICAgdGhpcy5kZXN0cm95ID0gbWFuYWdlci5tb25pdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbW92ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWlzS2V5Ym9hcmRFdmVudChtYW5hZ2VyLmRyYWdPcGVyYXRpb24uYWN0aXZhdG9yRXZlbnQpIHx8ICFldmVudC5ieSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zY3JvbGwoeyBieTogZXZlbnQuYnkgfSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbl9pbml0MyA9IF9fZGVjb3JhdG9yU3RhcnQoX2EzKTtcbl9hdXRvU2Nyb2xsaW5nID0gbmV3IFdlYWtNYXAoKTtcbl9tZXRhID0gbmV3IFdlYWtNYXAoKTtcbl9zY3JvbGwgPSBuZXcgV2Vha01hcCgpO1xuX19kZWNvcmF0ZUVsZW1lbnQoX2luaXQzLCA0LCBcImF1dG9TY3JvbGxpbmdcIiwgX2F1dG9TY3JvbGxpbmdfZGVjLCBTY3JvbGxlciwgX2F1dG9TY3JvbGxpbmcpO1xuX19kZWNvcmF0b3JNZXRhZGF0YShfaW5pdDMsIFNjcm9sbGVyKTtcbmZ1bmN0aW9uIGdldFNjcm9sbEludGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIFNjcm9sbERpcmVjdGlvbi5Gb3J3YXJkO1xuICB9XG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICByZXR1cm4gU2Nyb2xsRGlyZWN0aW9uLlJldmVyc2U7XG4gIH1cbiAgcmV0dXJuIFNjcm9sbERpcmVjdGlvbi5JZGxlO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3NjaGVkdWxpbmcvc2NoZWR1bGVyLnRzXG52YXIgU2NoZWR1bGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY2hlZHVsZXI1KSB7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI1O1xuICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMudGFza3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMucmVzb2x2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmZsdXNoID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyB0YXNrcywgcmVzb2x2ZXJzIH0gPSB0aGlzO1xuICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRhc2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMucmVzb2x2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgICB0YXNrKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHJlc29sdmUgb2YgcmVzb2x2ZXJzKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHNjaGVkdWxlKHRhc2spIHtcbiAgICB0aGlzLnRhc2tzLmFkZCh0YXNrKTtcbiAgICBpZiAoIXRoaXMucGVuZGluZykge1xuICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyKHRoaXMuZmx1c2gpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHRoaXMucmVzb2x2ZXJzLmFkZChyZXNvbHZlKSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVyMyA9IG5ldyBTY2hlZHVsZXIoKGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvY29yZS9wbHVnaW5zL3Njcm9sbGluZy9BdXRvU2Nyb2xsZXIudHNcbnZhciBBVVRPU0NST0xMX0lOVEVSVkFMID0gMTA7XG52YXIgQXV0b1Njcm9sbGVyID0gY2xhc3MgZXh0ZW5kcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBfb3B0aW9ucykge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIGNvbnN0IHNjcm9sbGVyID0gbWFuYWdlci5yZWdpc3RyeS5wbHVnaW5zLmdldChTY3JvbGxlcik7XG4gICAgaWYgKCFzY3JvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0b1Njcm9sbGVyIHBsdWdpbiBkZXBlbmRzIG9uIFNjcm9sbGVyIHBsdWdpblwiKTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ID0gZWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcG9zaXRpb246IF8sIHN0YXR1cyB9ID0gbWFuYWdlci5kcmFnT3BlcmF0aW9uO1xuICAgICAgaWYgKHN0YXR1cy5kcmFnZ2luZykge1xuICAgICAgICBjb25zdCBjYW5TY3JvbGwyID0gc2Nyb2xsZXIuc2Nyb2xsKCk7XG4gICAgICAgIGlmIChjYW5TY3JvbGwyKSB7XG4gICAgICAgICAgc2Nyb2xsZXIuYXV0b1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgICgpID0+IHNjaGVkdWxlcjMuc2NoZWR1bGUoc2Nyb2xsZXIuc2Nyb2xsKSxcbiAgICAgICAgICAgIEFVVE9TQ1JPTExfSU5URVJWQUxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbGVyLmF1dG9TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIGxpc3RlbmVyT3B0aW9ucyA9IHtcbiAgY2FwdHVyZTogdHJ1ZSxcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbnZhciBfdGltZW91dDtcbnZhciBTY3JvbGxMaXN0ZW5lciA9IGNsYXNzIGV4dGVuZHMgQ29yZVBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3RpbWVvdXQpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfdGltZW91dCkgPT0gbnVsbCkge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3RpbWVvdXQsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubWFuYWdlci5jb2xsaXNpb25PYnNlcnZlci5mb3JjZVVwZGF0ZShmYWxzZSk7XG4gICAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF90aW1lb3V0LCB2b2lkIDApO1xuICAgICAgICB9LCA1MCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgeyBkcmFnT3BlcmF0aW9uIH0gPSB0aGlzLm1hbmFnZXI7XG4gICAgdGhpcy5kZXN0cm95ID0gZWZmZWN0KCgpID0+IHtcbiAgICAgIHZhciBfYTQsIF9iMiwgX2MzO1xuICAgICAgY29uc3QgZW5hYmxlZCA9IGRyYWdPcGVyYXRpb24uc3RhdHVzLmRyYWdnaW5nO1xuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IChfYzMgPSAoX2IyID0gKF9hNCA9IGRyYWdPcGVyYXRpb24uc291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2E0LmVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYjIub3duZXJEb2N1bWVudCkgIT0gbnVsbCA/IF9jMyA6IGRvY3VtZW50O1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJzY3JvbGxcIixcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsLFxuICAgICAgICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbl90aW1lb3V0ID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQcmV2ZW50U2VsZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWFuYWdlciwgb3B0aW9ucyk7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmRlc3Ryb3kgPSBlZmZlY3QoKCkgPT4ge1xuICAgICAgdmFyIF9hNDtcbiAgICAgIGNvbnN0IHsgZHJhZ09wZXJhdGlvbiB9ID0gdGhpcy5tYW5hZ2VyO1xuICAgICAgY29uc3QgeyBub25jZSB9ID0gKF9hNCA9IHRoaXMub3B0aW9ucykgIT0gbnVsbCA/IF9hNCA6IHt9O1xuICAgICAgaWYgKGRyYWdPcGVyYXRpb24uc3RhdHVzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBgKiB7IHVzZXItc2VsZWN0OiBub25lICFpbXBvcnRhbnQ7IC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmUgIWltcG9ydGFudDsgfWA7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICByZW1vdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCByZW1vdmVTZWxlY3Rpb24sIHtcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgcmVtb3ZlU2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3R5bGUucmVtb3ZlKCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiByZW1vdmVTZWxlY3Rpb24oKSB7XG4gIHZhciBfYTQ7XG4gIChfYTQgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC5yZW1vdmVBbGxSYW5nZXMoKTtcbn1cbnZhciBkZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuICBvZmZzZXQ6IDEwLFxuICBrZXlib2FyZENvZGVzOiB7XG4gICAgc3RhcnQ6IFtcIlNwYWNlXCIsIFwiRW50ZXJcIl0sXG4gICAgY2FuY2VsOiBbXCJFc2NhcGVcIl0sXG4gICAgZW5kOiBbXCJTcGFjZVwiLCBcIkVudGVyXCIsIFwiVGFiXCJdLFxuICAgIHVwOiBbXCJBcnJvd1VwXCJdLFxuICAgIGRvd246IFtcIkFycm93RG93blwiXSxcbiAgICBsZWZ0OiBbXCJBcnJvd0xlZnRcIl0sXG4gICAgcmlnaHQ6IFtcIkFycm93UmlnaHRcIl1cbiAgfSxcbiAgc2hvdWxkQWN0aXZhdGUoYXJncykge1xuICAgIHZhciBfYTQ7XG4gICAgY29uc3QgeyBldmVudCwgc291cmNlIH0gPSBhcmdzO1xuICAgIGNvbnN0IHRhcmdldCA9IChfYTQgPSBzb3VyY2UuaGFuZGxlKSAhPSBudWxsID8gX2E0IDogc291cmNlLmVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldCA9PT0gdGFyZ2V0O1xuICB9XG59KTtcbnZhciBfY2xlYW51cEZ1bmN0aW9ucztcbnZhciBfS2V5Ym9hcmRTZW5zb3IgPSBjbGFzcyBfS2V5Ym9hcmRTZW5zb3IgZXh0ZW5kcyBTZW5zb3Ige1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2xlYW51cEZ1bmN0aW9ucywgW10pO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xuICAgIHRoaXMuaGFuZGxlU291cmNlS2V5RG93biA9IChldmVudCwgc291cmNlLCBvcHRpb25zKSA9PiB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFbGVtZW50KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZS5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleWJvYXJkQ29kZXMgPSBkZWZhdWx0cy5rZXlib2FyZENvZGVzLFxuICAgICAgICBzaG91bGRBY3RpdmF0ZSA9IGRlZmF1bHRzLnNob3VsZEFjdGl2YXRlXG4gICAgICB9ID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgICAgaWYgKCFrZXlib2FyZENvZGVzLnN0YXJ0LmluY2x1ZGVzKGV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5tYW5hZ2VyLmRyYWdPcGVyYXRpb24uc3RhdHVzLmlkbGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEFjdGl2YXRlKHsgZXZlbnQsIHNvdXJjZSwgbWFuYWdlcjogdGhpcy5tYW5hZ2VyIH0pKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU3RhcnQoZXZlbnQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBiaW5kKHNvdXJjZSwgb3B0aW9ucyA9IHRoaXMub3B0aW9ucykge1xuICAgIGNvbnN0IHVuYmluZCA9IGVmZmVjdCgoKSA9PiB7XG4gICAgICB2YXIgX2E0O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gKF9hNCA9IHNvdXJjZS5oYW5kbGUpICE9IG51bGwgPyBfYTQgOiBzb3VyY2UuZWxlbWVudDtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVTb3VyY2VLZXlEb3duKGV2ZW50LCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuYmluZDtcbiAgfVxuICBoYW5kbGVTdGFydChldmVudCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSBzb3VyY2U7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb3VyY2UgZHJhZ2dhYmxlIGRvZXMgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCBlbGVtZW50XCIpO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWxlbWVudCk7XG4gICAgY29uc3QgeyBjZW50ZXIgfSA9IG5ldyBET01SZWN0YW5nbGUoZWxlbWVudCk7XG4gICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMubWFuYWdlci5hY3Rpb25zLnN0YXJ0KHtcbiAgICAgIGV2ZW50LFxuICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgIHk6IGNlbnRlci55XG4gICAgICB9LFxuICAgICAgc291cmNlXG4gICAgfSk7XG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHJldHVybiB0aGlzLmNsZWFudXAoKTtcbiAgICB0aGlzLnNpZGVFZmZlY3RzKCk7XG4gICAgY29uc3Qgc291cmNlRG9jdW1lbnQgPSBnZXREb2N1bWVudChlbGVtZW50KTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXG4gICAgICB0aGlzLmxpc3RlbmVycy5iaW5kKHNvdXJjZURvY3VtZW50LCBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImtleWRvd25cIixcbiAgICAgICAgICBsaXN0ZW5lcjogKGV2ZW50MikgPT4gdGhpcy5oYW5kbGVLZXlEb3duKGV2ZW50Miwgc291cmNlLCBvcHRpb25zKSxcbiAgICAgICAgICBvcHRpb25zOiB7IGNhcHR1cmU6IHRydWUgfVxuICAgICAgICB9XG4gICAgICBdKVxuICAgIF07XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9jbGVhbnVwRnVuY3Rpb25zKS5wdXNoKC4uLmxpc3RlbmVycyk7XG4gIH1cbiAgaGFuZGxlS2V5RG93bihldmVudCwgX3NvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsga2V5Ym9hcmRDb2RlcyA9IGRlZmF1bHRzLmtleWJvYXJkQ29kZXMgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBpZiAoaXNLZXljb2RlKGV2ZW50LCBbLi4ua2V5Ym9hcmRDb2Rlcy5lbmQsIC4uLmtleWJvYXJkQ29kZXMuY2FuY2VsXSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBjYW5jZWxlZCA9IGlzS2V5Y29kZShldmVudCwga2V5Ym9hcmRDb2Rlcy5jYW5jZWwpO1xuICAgICAgdGhpcy5oYW5kbGVFbmQoZXZlbnQsIGNhbmNlbGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzS2V5Y29kZShldmVudCwga2V5Ym9hcmRDb2Rlcy51cCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZShcInVwXCIsIGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzS2V5Y29kZShldmVudCwga2V5Ym9hcmRDb2Rlcy5kb3duKSkge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlKFwiZG93blwiLCBldmVudCk7XG4gICAgfVxuICAgIGlmIChpc0tleWNvZGUoZXZlbnQsIGtleWJvYXJkQ29kZXMubGVmdCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZShcImxlZnRcIiwgZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNLZXljb2RlKGV2ZW50LCBrZXlib2FyZENvZGVzLnJpZ2h0KSkge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlKFwicmlnaHRcIiwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFbmQoZXZlbnQsIGNhbmNlbGVkKSB7XG4gICAgdGhpcy5tYW5hZ2VyLmFjdGlvbnMuc3RvcCh7XG4gICAgICBldmVudCxcbiAgICAgIGNhbmNlbGVkXG4gICAgfSk7XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgaGFuZGxlTW92ZShkaXJlY3Rpb24sIGV2ZW50KSB7XG4gICAgdmFyIF9hNCwgX2IyO1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHRoaXMubWFuYWdlci5kcmFnT3BlcmF0aW9uO1xuICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LnNoaWZ0S2V5ID8gNSA6IDE7XG4gICAgbGV0IGJ5ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIGxldCBvZmZzZXQgPSAoX2IyID0gKF9hNCA9IHRoaXMub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC5vZmZzZXQpICE9IG51bGwgPyBfYjIgOiBkZWZhdWx0cy5vZmZzZXQ7XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG9mZnNldCA9IHsgeDogb2Zmc2V0LCB5OiBvZmZzZXQgfTtcbiAgICB9XG4gICAgaWYgKCFzaGFwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgIGJ5ID0geyB4OiAwLCB5OiAtb2Zmc2V0LnkgKiBmYWN0b3IgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICBieSA9IHsgeDogMCwgeTogb2Zmc2V0LnkgKiBmYWN0b3IgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBieSA9IHsgeDogLW9mZnNldC54ICogZmFjdG9yLCB5OiAwIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGJ5ID0geyB4OiBvZmZzZXQueCAqIGZhY3RvciwgeTogMCB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ5LnggfHwgYnkueSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMubWFuYWdlci5hY3Rpb25zLm1vdmUoe1xuICAgICAgICBldmVudCxcbiAgICAgICAgYnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzaWRlRWZmZWN0cygpIHtcbiAgICBjb25zdCBhdXRvU2Nyb2xsZXIgPSB0aGlzLm1hbmFnZXIucmVnaXN0cnkucGx1Z2lucy5nZXQoQXV0b1Njcm9sbGVyKTtcbiAgICBpZiAoKGF1dG9TY3JvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYXV0b1Njcm9sbGVyLmRpc2FibGVkKSA9PT0gZmFsc2UpIHtcbiAgICAgIGF1dG9TY3JvbGxlci5kaXNhYmxlKCk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NsZWFudXBGdW5jdGlvbnMpLnB1c2goKCkgPT4ge1xuICAgICAgICBhdXRvU2Nyb2xsZXIuZW5hYmxlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NsZWFudXBGdW5jdGlvbnMpLmZvckVhY2goKGNsZWFudXApID0+IGNsZWFudXAoKSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9jbGVhbnVwRnVuY3Rpb25zLCBbXSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICB9XG59O1xuX2NsZWFudXBGdW5jdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuX0tleWJvYXJkU2Vuc29yLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyYXRvcihfS2V5Ym9hcmRTZW5zb3IpO1xuX0tleWJvYXJkU2Vuc29yLmRlZmF1bHRzID0gZGVmYXVsdHM7XG52YXIgS2V5Ym9hcmRTZW5zb3IgPSBfS2V5Ym9hcmRTZW5zb3I7XG5mdW5jdGlvbiBpc0tleWNvZGUoZXZlbnQsIGNvZGVzKSB7XG4gIHJldHVybiBjb2Rlcy5pbmNsdWRlcyhldmVudC5jb2RlKTtcbn1cbnZhciBkZWZhdWx0czIgPSBPYmplY3QuZnJlZXplKHtcbiAgYWN0aXZhdGlvbkNvbnN0cmFpbnRzKGV2ZW50LCBzb3VyY2UpIHtcbiAgICB2YXIgX2E0O1xuICAgIGNvbnN0IHsgcG9pbnRlclR5cGUsIHRhcmdldCB9ID0gZXZlbnQ7XG4gICAgaWYgKHBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgJiYgaXNFbGVtZW50KHRhcmdldCkgJiYgKHNvdXJjZS5oYW5kbGUgPT09IHRhcmdldCB8fCAoKF9hNCA9IHNvdXJjZS5oYW5kbGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTQuY29udGFpbnModGFyZ2V0KSkpKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAocG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXk6IHsgdmFsdWU6IDI1MCwgdG9sZXJhbmNlOiA1IH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc1RleHRJbnB1dCh0YXJnZXQpICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWxheTogeyB2YWx1ZTogMjAwLCB0b2xlcmFuY2U6IDAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlbGF5OiB7IHZhbHVlOiAyMDAsIHRvbGVyYW5jZTogMTAgfSxcbiAgICAgIGRpc3RhbmNlOiB7IHZhbHVlOiA1IH1cbiAgICB9O1xuICB9XG59KTtcbnZhciBfY2xlYW51cCwgX2NsZWFyVGltZW91dDtcbnZhciBfUG9pbnRlclNlbnNvciA9IGNsYXNzIF9Qb2ludGVyU2Vuc29yIGV4dGVuZHMgU2Vuc29yIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NsZWFudXAsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2xlYXJUaW1lb3V0KTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmxhdGVzdCA9IHtcbiAgICAgIGV2ZW50OiB2b2lkIDAsXG4gICAgICBjb29yZGluYXRlczogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZU1vdmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGV2ZW50LCBjb29yZGluYXRlczogdG8gfSA9IHRoaXMubGF0ZXN0O1xuICAgICAgaWYgKCFldmVudCB8fCAhdG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tYW5hZ2VyLmFjdGlvbnMubW92ZSh7IGV2ZW50LCB0byB9KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ2FuY2VsID0gdGhpcy5oYW5kbGVDYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IHRoaXMuaGFuZGxlUG9pbnRlclVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVLZXlEb3duID0gdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcyk7XG4gIH1cbiAgYWN0aXZhdGlvbkNvbnN0cmFpbnRzKGV2ZW50LCBzb3VyY2UpIHtcbiAgICB2YXIgX2E0O1xuICAgIGNvbnN0IHsgYWN0aXZhdGlvbkNvbnN0cmFpbnRzID0gZGVmYXVsdHMyLmFjdGl2YXRpb25Db25zdHJhaW50cyB9ID0gKF9hNCA9IHRoaXMub3B0aW9ucykgIT0gbnVsbCA/IF9hNCA6IHt9O1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdHlwZW9mIGFjdGl2YXRpb25Db25zdHJhaW50cyA9PT0gXCJmdW5jdGlvblwiID8gYWN0aXZhdGlvbkNvbnN0cmFpbnRzKGV2ZW50LCBzb3VyY2UpIDogYWN0aXZhdGlvbkNvbnN0cmFpbnRzO1xuICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgfVxuICBiaW5kKHNvdXJjZSwgb3B0aW9ucyA9IHRoaXMub3B0aW9ucykge1xuICAgIGNvbnN0IHVuYmluZCA9IGVmZmVjdCgoKSA9PiB7XG4gICAgICB2YXIgX2E0O1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHsgc2lnbmFsOiBzaWduYWwzIH0gPSBjb250cm9sbGVyO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzUG9pbnRlckV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24oZXZlbnQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgdGFyZ2V0cyA9IFsoX2E0ID0gc291cmNlLmhhbmRsZSkgIT0gbnVsbCA/IF9hNCA6IHNvdXJjZS5lbGVtZW50XTtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFjdGl2YXRvckVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYWN0aXZhdG9yRWxlbWVudHMpKSB7XG4gICAgICAgICAgdGFyZ2V0cyA9IG9wdGlvbnMuYWN0aXZhdG9yRWxlbWVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0cyA9IG9wdGlvbnMuYWN0aXZhdG9yRWxlbWVudHMoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgICBpZiAoIXRhcmdldCkgY29udGludWU7XG4gICAgICAgIHBhdGNoV2luZG93KHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBsaXN0ZW5lciwgeyBzaWduYWw6IHNpZ25hbDMgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4gY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bmJpbmQ7XG4gIH1cbiAgaGFuZGxlUG9pbnRlckRvd24oZXZlbnQsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIWV2ZW50LmlzUHJpbWFyeSB8fCBldmVudC5idXR0b24gIT09IDAgfHwgIWlzRWxlbWVudChldmVudC50YXJnZXQpIHx8IHNvdXJjZS5kaXNhYmxlZCB8fCBpc0NhcHR1cmVkQnlTZW5zb3IoZXZlbnQpIHx8ICF0aGlzLm1hbmFnZXIuZHJhZ09wZXJhdGlvbi5zdGF0dXMuaWRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnQ7XG4gICAgY29uc3QgaXNOYXRpdmVEcmFnZ2FibGUgPSBpc0hUTUxFbGVtZW50KHRhcmdldCkgJiYgdGFyZ2V0LmRyYWdnYWJsZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpID09PSBcInRydWVcIjtcbiAgICBjb25zdCBvZmZzZXQgPSBnZXRGcmFtZVRyYW5zZm9ybShzb3VyY2UuZWxlbWVudCk7XG4gICAgdGhpcy5pbml0aWFsQ29vcmRpbmF0ZXMgPSB7XG4gICAgICB4OiBldmVudC5jbGllbnRYICogb2Zmc2V0LnNjYWxlWCArIG9mZnNldC54LFxuICAgICAgeTogZXZlbnQuY2xpZW50WSAqIG9mZnNldC5zY2FsZVkgKyBvZmZzZXQueVxuICAgIH07XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmFjdGl2YXRpb25Db25zdHJhaW50cyhldmVudCwgc291cmNlKTtcbiAgICBldmVudC5zZW5zb3IgPSB0aGlzO1xuICAgIGlmICghKGNvbnN0cmFpbnRzID09IG51bGwgPyB2b2lkIDAgOiBjb25zdHJhaW50cy5kZWxheSkgJiYgIShjb25zdHJhaW50cyA9PSBudWxsID8gdm9pZCAwIDogY29uc3RyYWludHMuZGlzdGFuY2UpKSB7XG4gICAgICB0aGlzLmhhbmRsZVN0YXJ0KHNvdXJjZSwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGRlbGF5IH0gPSBjb25zdHJhaW50cztcbiAgICAgIGlmIChkZWxheSkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZVN0YXJ0KHNvdXJjZSwgZXZlbnQpLFxuICAgICAgICAgIGRlbGF5LnZhbHVlXG4gICAgICAgICk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xlYXJUaW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xlYXJUaW1lb3V0LCB2b2lkIDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IGdldERvY3VtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgY29uc3QgdW5iaW5kTGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuYmluZChvd25lckRvY3VtZW50LCBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwicG9pbnRlcm1vdmVcIixcbiAgICAgICAgbGlzdGVuZXI6IChldmVudDIpID0+IHRoaXMuaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQyLCBzb3VyY2UpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcInBvaW50ZXJ1cFwiLFxuICAgICAgICBsaXN0ZW5lcjogdGhpcy5oYW5kbGVQb2ludGVyVXAsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIENhbmNlbCBhY3RpdmF0aW9uIGlmIHRoZXJlIGlzIGEgY29tcGV0aW5nIERyYWcgYW5kIERyb3AgaW50ZXJhY3Rpb25cbiAgICAgICAgdHlwZTogXCJkcmFnc3RhcnRcIixcbiAgICAgICAgbGlzdGVuZXI6IGlzTmF0aXZlRHJhZ2dhYmxlID8gdGhpcy5oYW5kbGVDYW5jZWwgOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0pO1xuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E0O1xuICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAoX2E0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9jbGVhclRpbWVvdXQpKSA9PSBudWxsID8gdm9pZCAwIDogX2E0LmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmluaXRpYWxDb29yZGluYXRlcyA9IHZvaWQgMDtcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xlYW51cCkuYWRkKGNsZWFudXApO1xuICB9XG4gIGhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50LCBzb3VyY2UpIHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgICBjb25zdCBvZmZzZXQgPSBnZXRGcmFtZVRyYW5zZm9ybShzb3VyY2UuZWxlbWVudCk7XG4gICAgY29vcmRpbmF0ZXMueCA9IGNvb3JkaW5hdGVzLnggKiBvZmZzZXQuc2NhbGVYICsgb2Zmc2V0Lng7XG4gICAgY29vcmRpbmF0ZXMueSA9IGNvb3JkaW5hdGVzLnkgKiBvZmZzZXQuc2NhbGVZICsgb2Zmc2V0Lnk7XG4gICAgaWYgKHRoaXMubWFuYWdlci5kcmFnT3BlcmF0aW9uLnN0YXR1cy5kcmFnZ2luZykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5sYXRlc3QuZXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMubGF0ZXN0LmNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7XG4gICAgICBzY2hlZHVsZXIuc2NoZWR1bGUodGhpcy5oYW5kbGVNb3ZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmluaXRpYWxDb29yZGluYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IHtcbiAgICAgIHg6IGNvb3JkaW5hdGVzLnggLSB0aGlzLmluaXRpYWxDb29yZGluYXRlcy54LFxuICAgICAgeTogY29vcmRpbmF0ZXMueSAtIHRoaXMuaW5pdGlhbENvb3JkaW5hdGVzLnlcbiAgICB9O1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5hY3RpdmF0aW9uQ29uc3RyYWludHMoZXZlbnQsIHNvdXJjZSk7XG4gICAgY29uc3QgeyBkaXN0YW5jZSwgZGVsYXkgfSA9IGNvbnN0cmFpbnRzICE9IG51bGwgPyBjb25zdHJhaW50cyA6IHt9O1xuICAgIGlmIChkaXN0YW5jZSkge1xuICAgICAgaWYgKGRpc3RhbmNlLnRvbGVyYW5jZSAhPSBudWxsICYmIGV4Y2VlZHNEaXN0YW5jZShkZWx0YSwgZGlzdGFuY2UudG9sZXJhbmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDYW5jZWwoZXZlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2VlZHNEaXN0YW5jZShkZWx0YSwgZGlzdGFuY2UudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0YXJ0KHNvdXJjZSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGlmIChleGNlZWRzRGlzdGFuY2UoZGVsdGEsIGRlbGF5LnRvbGVyYW5jZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2FuY2VsKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXMubWFuYWdlci5kcmFnT3BlcmF0aW9uO1xuICAgIGlmICghc3RhdHVzLmlkbGUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IGNhbmNlbGVkID0gIXN0YXR1cy5pbml0aWFsaXplZDtcbiAgICAgIHRoaXMubWFuYWdlci5hY3Rpb25zLnN0b3AoeyBldmVudCwgY2FuY2VsZWQgfSk7XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5oYW5kbGVDYW5jZWwoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVTdGFydChzb3VyY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hNDtcbiAgICBjb25zdCB7IG1hbmFnZXIsIGluaXRpYWxDb29yZGluYXRlcyB9ID0gdGhpcztcbiAgICAoX2E0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9jbGVhclRpbWVvdXQpKSA9PSBudWxsID8gdm9pZCAwIDogX2E0LmNhbGwodGhpcyk7XG4gICAgaWYgKCFpbml0aWFsQ29vcmRpbmF0ZXMgfHwgIW1hbmFnZXIuZHJhZ09wZXJhdGlvbi5zdGF0dXMuaWRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sbGVyID0gbWFuYWdlci5hY3Rpb25zLnN0YXJ0KHtcbiAgICAgIGNvb3JkaW5hdGVzOiBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICBldmVudCxcbiAgICAgIHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSByZXR1cm4gdGhpcy5jbGVhbnVwKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBwb2ludGVyQ2FwdHVyZVRhcmdldCA9IG93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBwb2ludGVyQ2FwdHVyZVRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgIGNvbnN0IHVuYmluZCA9IHRoaXMubGlzdGVuZXJzLmJpbmQob3duZXJEb2N1bWVudCwgW1xuICAgICAge1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiB0b3VjaCBkZXZpY2VzXG4gICAgICAgIHR5cGU6IFwidG91Y2htb3ZlXCIsXG4gICAgICAgIGxpc3RlbmVyOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIFByZXZlbnQgY2xpY2sgZXZlbnRzXG4gICAgICAgIHR5cGU6IFwiY2xpY2tcIixcbiAgICAgICAgbGlzdGVuZXI6IHByZXZlbnREZWZhdWx0XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImNvbnRleHRtZW51XCIsXG4gICAgICAgIGxpc3RlbmVyOiBwcmV2ZW50RGVmYXVsdFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJrZXlkb3duXCIsXG4gICAgICAgIGxpc3RlbmVyOiB0aGlzLmhhbmRsZUtleURvd25cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwibG9zdHBvaW50ZXJjYXB0dXJlXCIsXG4gICAgICAgIGxpc3RlbmVyOiAoZXZlbnQyKSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50Mi50YXJnZXQgIT09IHBvaW50ZXJDYXB0dXJlVGFyZ2V0KSByZXR1cm47XG4gICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAoZXZlbnQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0pO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xlYW51cCkuYWRkKHVuYmluZCk7XG4gIH1cbiAgaGFuZGxlQ2FuY2VsKGV2ZW50KSB7XG4gICAgY29uc3QgeyBkcmFnT3BlcmF0aW9uIH0gPSB0aGlzLm1hbmFnZXI7XG4gICAgaWYgKGRyYWdPcGVyYXRpb24uc3RhdHVzLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuYWN0aW9ucy5zdG9wKHsgZXZlbnQsIGNhbmNlbGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIHRoaXMubGF0ZXN0ID0ge1xuICAgICAgZXZlbnQ6IHZvaWQgMCxcbiAgICAgIGNvb3JkaW5hdGVzOiB2b2lkIDBcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xlYW51cCkuZm9yRWFjaCgoY2xlYW51cCkgPT4gY2xlYW51cCgpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NsZWFudXApLmNsZWFyKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICB9XG59O1xuX2NsZWFudXAgPSBuZXcgV2Vha01hcCgpO1xuX2NsZWFyVGltZW91dCA9IG5ldyBXZWFrTWFwKCk7XG5fUG9pbnRlclNlbnNvci5jb25maWd1cmUgPSBjb25maWd1cmF0b3IoX1BvaW50ZXJTZW5zb3IpO1xuX1BvaW50ZXJTZW5zb3IuZGVmYXVsdHMgPSBkZWZhdWx0czI7XG52YXIgUG9pbnRlclNlbnNvciA9IF9Qb2ludGVyU2Vuc29yO1xuZnVuY3Rpb24gaXNDYXB0dXJlZEJ5U2Vuc29yKGV2ZW50KSB7XG4gIHJldHVybiBcInNlbnNvclwiIGluIGV2ZW50O1xufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG52YXIgd2luZG93cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gcGF0Y2hXaW5kb3cod2luZG93KSB7XG4gIGlmICghd2luZG93IHx8IHdpbmRvd3MuaGFzKHdpbmRvdykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbm9vcCwge1xuICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH0pO1xuICB3aW5kb3dzLmFkZCh3aW5kb3cpO1xufVxuXG4vLyBzcmMvY29yZS9tYW5hZ2VyL21hbmFnZXIudHNcbnZhciBkZWZhdWx0UHJlc2V0ID0ge1xuICBtb2RpZmllcnM6IFtdLFxuICBwbHVnaW5zOiBbQWNjZXNzaWJpbGl0eSwgQXV0b1Njcm9sbGVyLCBDdXJzb3IsIEZlZWRiYWNrLCBQcmV2ZW50U2VsZWN0aW9uXSxcbiAgc2Vuc29yczogW1BvaW50ZXJTZW5zb3IsIEtleWJvYXJkU2Vuc29yXVxufTtcbnZhciBEcmFnRHJvcE1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIERyYWdEcm9wTWFuYWdlciQxIHtcbiAgY29uc3RydWN0b3IoaW5wdXQgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBsdWdpbnMgPSBkZWZhdWx0UHJlc2V0LnBsdWdpbnMsXG4gICAgICBzZW5zb3JzID0gZGVmYXVsdFByZXNldC5zZW5zb3JzLFxuICAgICAgbW9kaWZpZXJzID0gW11cbiAgICB9ID0gaW5wdXQ7XG4gICAgc3VwZXIoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgaW5wdXQpLCB7XG4gICAgICBwbHVnaW5zOiBbU2Nyb2xsTGlzdGVuZXIsIFNjcm9sbGVyLCAuLi5wbHVnaW5zXSxcbiAgICAgIHNlbnNvcnMsXG4gICAgICBtb2RpZmllcnNcbiAgICB9KSk7XG4gIH1cbn07XG52YXIgX2ZlZWRiYWNrX2RlYywgX2VsZW1lbnRfZGVjLCBfaGFuZGxlX2RlYywgX2MsIF9pbml0NCwgX2hhbmRsZSwgX2VsZW1lbnQsIF9mZWVkYmFjaztcbnZhciBEcmFnZ2FibGUgPSBjbGFzcyBleHRlbmRzIChfYyA9IERyYWdnYWJsZSQxLCBfaGFuZGxlX2RlYyA9IFtyZWFjdGl2ZV0sIF9lbGVtZW50X2RlYyA9IFtyZWFjdGl2ZV0sIF9mZWVkYmFja19kZWMgPSBbcmVhY3RpdmVdLCBfYykge1xuICBjb25zdHJ1Y3RvcihfYTQsIG1hbmFnZXIpIHtcbiAgICB2YXIgX2IyID0gX2E0LCB7XG4gICAgICBlbGVtZW50LFxuICAgICAgZWZmZWN0czogZWZmZWN0czIgPSAoKSA9PiBbXSxcbiAgICAgIGhhbmRsZSxcbiAgICAgIGZlZWRiYWNrID0gXCJkZWZhdWx0XCJcbiAgICB9ID0gX2IyLCBpbnB1dCA9IF9fb2JqUmVzdChfYjIsIFtcbiAgICAgIFwiZWxlbWVudFwiLFxuICAgICAgXCJlZmZlY3RzXCIsXG4gICAgICBcImhhbmRsZVwiLFxuICAgICAgXCJmZWVkYmFja1wiXG4gICAgXSk7XG4gICAgc3VwZXIoXG4gICAgICBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIGVmZmVjdHM6ICgpID0+IFtcbiAgICAgICAgICAuLi5lZmZlY3RzMigpLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTUsIF9iMztcbiAgICAgICAgICAgIGNvbnN0IHsgbWFuYWdlcjogbWFuYWdlcjIgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIW1hbmFnZXIyKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzZW5zb3JzID0gKF9iMyA9IChfYTUgPSB0aGlzLnNlbnNvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTUubWFwKGRlc2NyaXB0b3IpKSAhPSBudWxsID8gX2IzIDogW1xuICAgICAgICAgICAgICAuLi5tYW5hZ2VyMi5zZW5zb3JzXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgdW5iaW5kRnVuY3Rpb25zID0gc2Vuc29ycy5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlbnNvckluc3RhbmNlID0gZW50cnkgaW5zdGFuY2VvZiBTZW5zb3IgPyBlbnRyeSA6IG1hbmFnZXIyLnJlZ2lzdHJ5LnJlZ2lzdGVyKGVudHJ5LnBsdWdpbik7XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBlbnRyeSBpbnN0YW5jZW9mIFNlbnNvciA/IHZvaWQgMCA6IGVudHJ5Lm9wdGlvbnM7XG4gICAgICAgICAgICAgIGNvbnN0IHVuYmluZCA9IHNlbnNvckluc3RhbmNlLmJpbmQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIHJldHVybiB1bmJpbmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgICB1bmJpbmRGdW5jdGlvbnMuZm9yRWFjaCgodW5iaW5kKSA9PiB1bmJpbmQoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSwgaW5wdXQpLFxuICAgICAgbWFuYWdlclxuICAgICk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGUsIF9fcnVuSW5pdGlhbGl6ZXJzKF9pbml0NCwgOCwgdGhpcykpLCBfX3J1bkluaXRpYWxpemVycyhfaW5pdDQsIDExLCB0aGlzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2VsZW1lbnQsIF9fcnVuSW5pdGlhbGl6ZXJzKF9pbml0NCwgMTIsIHRoaXMpKSwgX19ydW5Jbml0aWFsaXplcnMoX2luaXQ0LCAxNSwgdGhpcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mZWVkYmFjaywgX19ydW5Jbml0aWFsaXplcnMoX2luaXQ0LCAxNiwgdGhpcykpLCBfX3J1bkluaXRpYWxpemVycyhfaW5pdDQsIDE5LCB0aGlzKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xuICAgIHRoaXMuZmVlZGJhY2sgPSBmZWVkYmFjaztcbiAgfVxufTtcbl9pbml0NCA9IF9fZGVjb3JhdG9yU3RhcnQoX2MpO1xuX2hhbmRsZSA9IG5ldyBXZWFrTWFwKCk7XG5fZWxlbWVudCA9IG5ldyBXZWFrTWFwKCk7XG5fZmVlZGJhY2sgPSBuZXcgV2Vha01hcCgpO1xuX19kZWNvcmF0ZUVsZW1lbnQoX2luaXQ0LCA0LCBcImhhbmRsZVwiLCBfaGFuZGxlX2RlYywgRHJhZ2dhYmxlLCBfaGFuZGxlKTtcbl9fZGVjb3JhdGVFbGVtZW50KF9pbml0NCwgNCwgXCJlbGVtZW50XCIsIF9lbGVtZW50X2RlYywgRHJhZ2dhYmxlLCBfZWxlbWVudCk7XG5fX2RlY29yYXRlRWxlbWVudChfaW5pdDQsIDQsIFwiZmVlZGJhY2tcIiwgX2ZlZWRiYWNrX2RlYywgRHJhZ2dhYmxlLCBfZmVlZGJhY2spO1xuX19kZWNvcmF0b3JNZXRhZGF0YShfaW5pdDQsIERyYWdnYWJsZSk7XG52YXIgX3Byb3h5X2RlYywgX2VsZW1lbnRfZGVjMiwgX2MyLCBfaW5pdDUsIF9lbGVtZW50MiwgX2QsIGVsZW1lbnRfZ2V0LCBlbGVtZW50X3NldCwgX0Ryb3BwYWJsZV9pbnN0YW5jZXMsIF9wcm94eTtcbnZhciBEcm9wcGFibGUgPSBjbGFzcyBleHRlbmRzIChfYzIgPSBEcm9wcGFibGUkMSwgX2VsZW1lbnRfZGVjMiA9IFtyZWFjdGl2ZV0sIF9wcm94eV9kZWMgPSBbcmVhY3RpdmVdLCBfYzIpIHtcbiAgY29uc3RydWN0b3IoX2E0LCBtYW5hZ2VyKSB7XG4gICAgdmFyIF9iMiA9IF9hNCwgeyBlbGVtZW50LCBlZmZlY3RzOiBlZmZlY3RzMiA9ICgpID0+IFtdIH0gPSBfYjIsIGlucHV0ID0gX19vYmpSZXN0KF9iMiwgW1wiZWxlbWVudFwiLCBcImVmZmVjdHNcIl0pO1xuICAgIGNvbnN0IHsgY29sbGlzaW9uRGV0ZWN0b3IgPSBkZWZhdWx0Q29sbGlzaW9uRGV0ZWN0aW9uIH0gPSBpbnB1dDtcbiAgICBjb25zdCB1cGRhdGVTaGFwZSA9IChib3VuZGluZ0NsaWVudFJlY3QpID0+IHtcbiAgICAgIGNvbnN0IHsgbWFuYWdlcjogbWFuYWdlcjIsIGVsZW1lbnQ6IGVsZW1lbnQyIH0gPSB0aGlzO1xuICAgICAgaWYgKCFlbGVtZW50MiB8fCBib3VuZGluZ0NsaWVudFJlY3QgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zaGFwZSA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWFuYWdlcjIpIHJldHVybjtcbiAgICAgIGNvbnN0IHVwZGF0ZWRTaGFwZSA9IG5ldyBET01SZWN0YW5nbGUoZWxlbWVudDIpO1xuICAgICAgY29uc3Qgc2hhcGUgPSB1bnRyYWNrZWQoKCkgPT4gdGhpcy5zaGFwZSk7XG4gICAgICBpZiAodXBkYXRlZFNoYXBlICYmIChzaGFwZSA9PSBudWxsID8gdm9pZCAwIDogc2hhcGUuZXF1YWxzKHVwZGF0ZWRTaGFwZSkpKSB7XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hhcGUgPSB1cGRhdGVkU2hhcGU7XG4gICAgICByZXR1cm4gdXBkYXRlZFNoYXBlO1xuICAgIH07XG4gICAgY29uc3Qgb2JzZXJ2ZVBvc2l0aW9uID0gc2lnbmFsKGZhbHNlKTtcbiAgICBzdXBlcihcbiAgICAgIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGlucHV0KSwge1xuICAgICAgICBjb2xsaXNpb25EZXRlY3RvcixcbiAgICAgICAgZWZmZWN0czogKCkgPT4gW1xuICAgICAgICAgIC4uLmVmZmVjdHMyKCksXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiwgbWFuYWdlcjogbWFuYWdlcjIgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIW1hbmFnZXIyKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IGRyYWdPcGVyYXRpb24gfSA9IG1hbmFnZXIyO1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UgfSA9IGRyYWdPcGVyYXRpb247XG4gICAgICAgICAgICBvYnNlcnZlUG9zaXRpb24udmFsdWUgPSBCb29sZWFuKFxuICAgICAgICAgICAgICBzb3VyY2UgJiYgZHJhZ09wZXJhdGlvbi5zdGF0dXMuaW5pdGlhbGl6ZWQgJiYgZWxlbWVudDIgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5hY2NlcHRzKHNvdXJjZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVQb3NpdGlvbi52YWx1ZSAmJiBlbGVtZW50Mikge1xuICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbk9ic2VydmVyID0gbmV3IFBvc2l0aW9uT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgZWxlbWVudDIsXG4gICAgICAgICAgICAgICAgdXBkYXRlU2hhcGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gdm9pZCAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hNTtcbiAgICAgICAgICAgIGlmICgoX2E1ID0gdGhpcy5tYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2E1LmRyYWdPcGVyYXRpb24uc3RhdHVzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pLFxuICAgICAgbWFuYWdlclxuICAgICk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9Ecm9wcGFibGVfaW5zdGFuY2VzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2VsZW1lbnQyLCBfX3J1bkluaXRpYWxpemVycyhfaW5pdDUsIDgsIHRoaXMpKSwgX19ydW5Jbml0aWFsaXplcnMoX2luaXQ1LCAxMSwgdGhpcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcm94eSwgX19ydW5Jbml0aWFsaXplcnMoX2luaXQ1LCAxMiwgdGhpcykpLCBfX3J1bkluaXRpYWxpemVycyhfaW5pdDUsIDE1LCB0aGlzKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucmVmcmVzaFNoYXBlID0gKCkgPT4gdXBkYXRlU2hhcGUoKTtcbiAgfVxuICBzZXQgZWxlbWVudChlbGVtZW50KSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9Ecm9wcGFibGVfaW5zdGFuY2VzLCBlbGVtZW50LCBlbGVtZW50X3NldCk7XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgdmFyIF9hNDtcbiAgICByZXR1cm4gKF9hNCA9IHRoaXMucHJveHkpICE9IG51bGwgPyBfYTQgOiBfX3ByaXZhdGVHZXQodGhpcywgX0Ryb3BwYWJsZV9pbnN0YW5jZXMsIGVsZW1lbnRfZ2V0KTtcbiAgfVxufTtcbl9pbml0NSA9IF9fZGVjb3JhdG9yU3RhcnQoX2MyKTtcbl9lbGVtZW50MiA9IG5ldyBXZWFrTWFwKCk7XG5fRHJvcHBhYmxlX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCk7XG5fcHJveHkgPSBuZXcgV2Vha01hcCgpO1xuX2QgPSBfX2RlY29yYXRlRWxlbWVudChfaW5pdDUsIDIwLCBcIiNlbGVtZW50XCIsIF9lbGVtZW50X2RlYzIsIF9Ecm9wcGFibGVfaW5zdGFuY2VzLCBfZWxlbWVudDIpLCBlbGVtZW50X2dldCA9IF9kLmdldCwgZWxlbWVudF9zZXQgPSBfZC5zZXQ7XG5fX2RlY29yYXRlRWxlbWVudChfaW5pdDUsIDQsIFwicHJveHlcIiwgX3Byb3h5X2RlYywgRHJvcHBhYmxlLCBfcHJveHkpO1xuX19kZWNvcmF0b3JNZXRhZGF0YShfaW5pdDUsIERyb3BwYWJsZSk7XG5cbmV4cG9ydCB7IEFjY2Vzc2liaWxpdHksIEF1dG9TY3JvbGxlciwgQ3Vyc29yLCBEcmFnRHJvcE1hbmFnZXIsIERyYWdnYWJsZSwgRHJvcHBhYmxlLCBGZWVkYmFjaywgS2V5Ym9hcmRTZW5zb3IsIFBvaW50ZXJTZW5zb3IsIFByZXZlbnRTZWxlY3Rpb24sIFNjcm9sbExpc3RlbmVyLCBTY3JvbGxlciwgZGVmYXVsdFByZXNldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/sortable.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/sortable.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OptimisticSortingPlugin: () => (/* binding */ OptimisticSortingPlugin),\n/* harmony export */   Sortable: () => (/* binding */ Sortable2),\n/* harmony export */   SortableKeyboardPlugin: () => (/* binding */ SortableKeyboardPlugin),\n/* harmony export */   defaultSortableTransition: () => (/* binding */ defaultSortableTransition),\n/* harmony export */   isSortable: () => (/* binding */ isSortable)\n/* harmony export */ });\n/* harmony import */ var _dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dnd-kit/state */ \"(ssr)/./node_modules/.pnpm/@preact+signals-core@1.12.1/node_modules/@preact/signals-core/dist/signals-core.mjs\");\n/* harmony import */ var _dnd_kit_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @dnd-kit/state */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+state@0.1.21/node_modules/@dnd-kit/state/dist/index.mjs\");\n/* harmony import */ var _dnd_kit_collision__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dnd-kit/collision */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+collision@0.1.21/node_modules/@dnd-kit/collision/dist/index.js\");\n/* harmony import */ var _dnd_kit_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dnd-kit/dom */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/index.js\");\n/* harmony import */ var _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/dom/utilities */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/utilities.js\");\n/* harmony import */ var _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dnd-kit/abstract */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+abstract@0.1.21/node_modules/@dnd-kit/abstract/index.js\");\n/* harmony import */ var _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dnd-kit/geometry */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+geometry@0.1.21/node_modules/@dnd-kit/geometry/dist/index.mjs\");\n\n\n\n\n\n\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __decoratorStart = (base) => {\n  var _a;\n  return [, , , __create((_a = void 0 ) != null ? _a : null)];\n};\nvar __decoratorStrings = [\"class\", \"method\", \"getter\", \"setter\", \"accessor\", \"field\", \"value\", \"get\", \"set\"];\nvar __expectFn = (fn) => fn !== void 0 && typeof fn !== \"function\" ? __typeError(\"Function expected\") : fn;\nvar __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError(\"Already initialized\") : fns.push(__expectFn(fn || null)) });\nvar __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol(\"metadata\"), array[3]);\nvar __runInitializers = (array, flags, self, value) => {\n  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);\n  return value;\n};\nvar __decorateElement = (array, flags, name, decorators, target, extra) => {\n  var fn, it, done, ctx, access, k = flags & 7, s = false, p = false;\n  var j = array.length + 1 , key = __decoratorStrings[k + 5];\n  var initializers = (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);\n  var desc = ((target = target.prototype), __getOwnPropDesc({ get [name]() {\n    return __privateGet(this, extra);\n  }, set [name](x) {\n    return __privateSet(this, extra, x);\n  } }, name));\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);\n    {\n      ctx.static = s, ctx.private = p, access = ctx.access = { has: (x) => name in x };\n      access.get = (x) => x[name];\n      access.set = (x, y) => x[name] = y;\n    }\n    it = (0, decorators[i])({ get: desc.get, set: desc.set } , ctx), done._ = 1;\n    if (it === void 0) __expectFn(it) && (desc[key] = it );\n    else if (typeof it !== \"object\" || it === null) __typeError(\"Object expected\");\n    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);\n  }\n  return desc && __defProp(target, name, desc), target;\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), member.set(obj, value), value);\n\n// src/sortable/utilities.ts\nfunction isSortable(element) {\n  return element instanceof SortableDroppable || element instanceof SortableDraggable;\n}\n\n// src/sortable/plugins/SortableKeyboardPlugin.ts\nvar TOLERANCE = 10;\nvar SortableKeyboardPlugin = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(manager) {\n    super(manager);\n    const cleanupEffect = (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.effect)(() => {\n      const { dragOperation } = manager;\n      if (!(0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(dragOperation.activatorEvent)) {\n        return;\n      }\n      if (!isSortable(dragOperation.source)) {\n        return;\n      }\n      if (dragOperation.status.initialized) {\n        const scroller = manager.registry.plugins.get(_dnd_kit_dom__WEBPACK_IMPORTED_MODULE_3__.Scroller);\n        if (scroller) {\n          scroller.disable();\n          return () => scroller.enable();\n        }\n      }\n    });\n    const unsubscribe = manager.monitor.addEventListener(\n      \"dragmove\",\n      (event, manager2) => {\n        queueMicrotask(() => {\n          if (this.disabled || event.defaultPrevented || !event.nativeEvent) {\n            return;\n          }\n          const { dragOperation } = manager2;\n          if (!(0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(event.nativeEvent)) {\n            return;\n          }\n          if (!isSortable(dragOperation.source)) {\n            return;\n          }\n          if (!dragOperation.shape) {\n            return;\n          }\n          const { actions, collisionObserver, registry } = manager2;\n          const { by } = event;\n          if (!by) {\n            return;\n          }\n          const direction = getDirection(by);\n          const { source, target } = dragOperation;\n          const { center } = dragOperation.shape.current;\n          const potentialTargets = [];\n          const cleanup = [];\n          (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n            for (const droppable of registry.droppables) {\n              const { id: id2 } = droppable;\n              if (!droppable.accepts(source) || id2 === (target == null ? void 0 : target.id) && isSortable(droppable) || !droppable.element) {\n                continue;\n              }\n              let previousShape = droppable.shape;\n              const shape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.DOMRectangle(droppable.element, {\n                getBoundingClientRect: (element) => (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.getVisibleBoundingRectangle)(element, void 0, 0.2)\n              });\n              if (!shape.height || !shape.width) continue;\n              if (direction == \"down\" && center.y + TOLERANCE < shape.center.y || direction == \"up\" && center.y - TOLERANCE > shape.center.y || direction == \"left\" && center.x - TOLERANCE > shape.center.x || direction == \"right\" && center.x + TOLERANCE < shape.center.x) {\n                potentialTargets.push(droppable);\n                droppable.shape = shape;\n                cleanup.push(() => droppable.shape = previousShape);\n              }\n            }\n          });\n          event.preventDefault();\n          collisionObserver.disable();\n          const collisions = collisionObserver.computeCollisions(\n            potentialTargets,\n            _dnd_kit_collision__WEBPACK_IMPORTED_MODULE_4__.closestCorners\n          );\n          (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => cleanup.forEach((clean) => clean()));\n          const [firstCollision] = collisions;\n          if (!firstCollision) {\n            return;\n          }\n          const { id } = firstCollision;\n          const { index, group } = source.sortable;\n          actions.setDropTarget(id).then(() => {\n            const { source: source2, target: target2, shape } = dragOperation;\n            if (!source2 || !isSortable(source2) || !shape) {\n              return;\n            }\n            const {\n              index: newIndex,\n              group: newGroup,\n              target: targetElement\n            } = source2.sortable;\n            const updated = index !== newIndex || group !== newGroup;\n            const element = updated ? targetElement : target2 == null ? void 0 : target2.element;\n            if (!element) return;\n            (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.scrollIntoViewIfNeeded)(element);\n            const updatedShape = new _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.DOMRectangle(element);\n            if (!updatedShape) {\n              return;\n            }\n            const delta = _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_5__.Rectangle.delta(\n              updatedShape,\n              _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_5__.Rectangle.from(shape.current.boundingRectangle),\n              source2.alignment\n            );\n            actions.move({\n              by: delta\n            });\n            if (updated) {\n              actions.setDropTarget(source2.id).then(() => collisionObserver.enable());\n            } else {\n              collisionObserver.enable();\n            }\n          });\n        });\n      }\n    );\n    this.destroy = () => {\n      unsubscribe();\n      cleanupEffect();\n    };\n  }\n};\nfunction getDirection(delta) {\n  const { x, y } = delta;\n  if (x > 0) {\n    return \"right\";\n  } else if (x < 0) {\n    return \"left\";\n  } else if (y > 0) {\n    return \"down\";\n  } else if (y < 0) {\n    return \"up\";\n  }\n}\n\n// ../helpers/dist/index.js\nvar __defProp2 = Object.defineProperty;\nvar __defProps2 = Object.defineProperties;\nvar __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp2.call(b, prop))\n      __defNormalProp2(a, prop, b[prop]);\n  if (__getOwnPropSymbols2)\n    for (var prop of __getOwnPropSymbols2(b)) {\n      if (__propIsEnum2.call(b, prop))\n        __defNormalProp2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));\nfunction arrayMove(array, from, to) {\n  if (from === to) {\n    return array;\n  }\n  const newArray = array.slice();\n  newArray.splice(to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\nfunction mutate(items, event, mutation) {\n  var _a, _b;\n  const { source, target, canceled } = event.operation;\n  if (!source || !target || canceled) {\n    if (\"preventDefault\" in event) event.preventDefault();\n    return items;\n  }\n  const findIndex = (item, id) => item === id || typeof item === \"object\" && \"id\" in item && item.id === id;\n  if (Array.isArray(items)) {\n    const sourceIndex2 = items.findIndex((item) => findIndex(item, source.id));\n    const targetIndex2 = items.findIndex((item) => findIndex(item, target.id));\n    if (sourceIndex2 === -1 || targetIndex2 === -1) {\n      return items;\n    }\n    if (!canceled && \"index\" in source && typeof source.index === \"number\") {\n      const projectedSourceIndex = source.index;\n      if (projectedSourceIndex !== sourceIndex2) {\n        return mutation(items, sourceIndex2, projectedSourceIndex);\n      }\n    }\n    return mutation(items, sourceIndex2, targetIndex2);\n  }\n  const entries = Object.entries(items);\n  let sourceIndex = -1;\n  let sourceParent;\n  let targetIndex = -1;\n  let targetParent;\n  for (const [id, children] of entries) {\n    if (sourceIndex === -1) {\n      sourceIndex = children.findIndex((item) => findIndex(item, source.id));\n      if (sourceIndex !== -1) {\n        sourceParent = id;\n      }\n    }\n    if (targetIndex === -1) {\n      targetIndex = children.findIndex((item) => findIndex(item, target.id));\n      if (targetIndex !== -1) {\n        targetParent = id;\n      }\n    }\n    if (sourceIndex !== -1 && targetIndex !== -1) {\n      break;\n    }\n  }\n  if (!source.manager) return items;\n  const { dragOperation } = source.manager;\n  const position = (_b = (_a = dragOperation.shape) == null ? void 0 : _a.current.center) != null ? _b : dragOperation.position.current;\n  if (targetParent == null) {\n    if (target.id in items) {\n      const insertionIndex = target.shape && position.y > target.shape.center.y ? items[target.id].length : 0;\n      targetParent = target.id;\n      targetIndex = insertionIndex;\n    }\n  }\n  if (sourceParent == null || targetParent == null || sourceParent === targetParent && sourceIndex === targetIndex) {\n    if (\"preventDefault\" in event) event.preventDefault();\n    return items;\n  }\n  if (sourceParent === targetParent) {\n    return __spreadProps2(__spreadValues2({}, items), {\n      [sourceParent]: mutation(items[sourceParent], sourceIndex, targetIndex)\n    });\n  }\n  const isBelowTarget = target.shape && Math.round(position.y) > Math.round(target.shape.center.y);\n  const modifier = isBelowTarget ? 1 : 0;\n  const sourceItem = items[sourceParent][sourceIndex];\n  return __spreadProps2(__spreadValues2({}, items), {\n    [sourceParent]: [\n      ...items[sourceParent].slice(0, sourceIndex),\n      ...items[sourceParent].slice(sourceIndex + 1)\n    ],\n    [targetParent]: [\n      ...items[targetParent].slice(0, targetIndex + modifier),\n      sourceItem,\n      ...items[targetParent].slice(targetIndex + modifier)\n    ]\n  });\n}\nfunction move(items, event) {\n  return mutate(items, event, arrayMove);\n}\nvar defaultGroup = \"__default__\";\nvar OptimisticSortingPlugin = class extends _dnd_kit_abstract__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(manager) {\n    super(manager);\n    const getSortableInstances = () => {\n      const sortableInstances = /* @__PURE__ */ new Map();\n      for (const droppable of manager.registry.droppables) {\n        if (droppable instanceof SortableDroppable) {\n          const { sortable } = droppable;\n          const { group } = sortable;\n          let instances = sortableInstances.get(group);\n          if (!instances) {\n            instances = /* @__PURE__ */ new Set();\n            sortableInstances.set(group, instances);\n          }\n          instances.add(sortable);\n        }\n      }\n      for (const [group, instances] of sortableInstances) {\n        sortableInstances.set(group, new Set(sort(instances)));\n      }\n      return sortableInstances;\n    };\n    const unsubscribe = [\n      manager.monitor.addEventListener(\"dragover\", (event, manager2) => {\n        if (this.disabled) {\n          return;\n        }\n        const { dragOperation } = manager2;\n        const { source, target } = dragOperation;\n        if (!isSortable(source) || !isSortable(target)) {\n          return;\n        }\n        if (source.sortable === target.sortable) {\n          return;\n        }\n        const instances = getSortableInstances();\n        const sameGroup = source.sortable.group === target.sortable.group;\n        const sourceInstances = instances.get(source.sortable.group);\n        const targetInstances = sameGroup ? sourceInstances : instances.get(target.sortable.group);\n        if (!sourceInstances || !targetInstances) return;\n        queueMicrotask(() => {\n          if (event.defaultPrevented) return;\n          manager2.renderer.rendering.then(() => {\n            var _a, _b, _c;\n            const newInstances = getSortableInstances();\n            for (const [group, sortableInstances] of instances.entries()) {\n              const entries = Array.from(sortableInstances).entries();\n              for (const [index, sortable] of entries) {\n                if (sortable.index !== index || sortable.group !== group || !((_a = newInstances.get(group)) == null ? void 0 : _a.has(sortable))) {\n                  return;\n                }\n              }\n            }\n            const sourceElement = source.sortable.element;\n            const targetElement = target.sortable.element;\n            if (!targetElement || !sourceElement) {\n              return;\n            }\n            if (!sameGroup && target.id === source.sortable.group) {\n              return;\n            }\n            const orderedSourceSortables = sort(sourceInstances);\n            const orderedTargetSortables = sameGroup ? orderedSourceSortables : sort(targetInstances);\n            const sourceGroup = (_b = source.sortable.group) != null ? _b : defaultGroup;\n            const targetGroup = (_c = target.sortable.group) != null ? _c : defaultGroup;\n            const state = {\n              [sourceGroup]: orderedSourceSortables,\n              [targetGroup]: orderedTargetSortables\n            };\n            const newState = move(state, event);\n            if (state === newState) return;\n            const sourceIndex = newState[targetGroup].indexOf(source.sortable);\n            const targetIndex = newState[targetGroup].indexOf(target.sortable);\n            manager2.collisionObserver.disable();\n            reorder(sourceElement, sourceIndex, targetElement, targetIndex);\n            (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n              for (const [index, sortable] of newState[sourceGroup].entries()) {\n                sortable.index = index;\n              }\n              if (!sameGroup) {\n                for (const [index, sortable] of newState[targetGroup].entries()) {\n                  sortable.group = target.sortable.group;\n                  sortable.index = index;\n                }\n              }\n            });\n            manager2.actions.setDropTarget(source.id).then(() => manager2.collisionObserver.enable());\n          });\n        });\n      }),\n      manager.monitor.addEventListener(\"dragend\", (event, manager2) => {\n        if (!event.canceled) {\n          return;\n        }\n        const { dragOperation } = manager2;\n        const { source } = dragOperation;\n        if (!isSortable(source)) {\n          return;\n        }\n        if (source.sortable.initialIndex === source.sortable.index && source.sortable.initialGroup === source.sortable.group) {\n          return;\n        }\n        queueMicrotask(() => {\n          const instances = getSortableInstances();\n          const initialGroupInstances = instances.get(\n            source.sortable.initialGroup\n          );\n          if (!initialGroupInstances) return;\n          manager2.renderer.rendering.then(() => {\n            for (const [group, sortableInstances] of instances.entries()) {\n              const entries = Array.from(sortableInstances).entries();\n              for (const [index, sortable] of entries) {\n                if (sortable.index !== index || sortable.group !== group) {\n                  return;\n                }\n              }\n            }\n            const initialGroup = sort(initialGroupInstances);\n            const sourceElement = source.sortable.element;\n            const target = initialGroup[source.sortable.initialIndex];\n            const targetElement = target == null ? void 0 : target.element;\n            if (!target || !targetElement || !sourceElement) {\n              return;\n            }\n            reorder(sourceElement, target.index, targetElement, source.index);\n            (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n              for (const [_, sortableInstances] of instances.entries()) {\n                const entries = Array.from(sortableInstances).values();\n                for (const sortable of entries) {\n                  sortable.index = sortable.initialIndex;\n                  sortable.group = sortable.initialGroup;\n                }\n              }\n            });\n          });\n        });\n      })\n    ];\n    this.destroy = () => {\n      for (const unsubscribeListener of unsubscribe) {\n        unsubscribeListener();\n      }\n    };\n  }\n};\nfunction reorder(sourceElement, sourceIndex, targetElement, targetIndex) {\n  const position = targetIndex < sourceIndex ? \"afterend\" : \"beforebegin\";\n  targetElement.insertAdjacentElement(position, sourceElement);\n}\nfunction sortByIndex(a, b) {\n  return a.index - b.index;\n}\nfunction sort(instances) {\n  return Array.from(instances).sort(sortByIndex);\n}\n\n// src/sortable/sortable.ts\nvar defaultPlugins = [\n  SortableKeyboardPlugin,\n  OptimisticSortingPlugin\n];\nvar defaultSortableTransition = {\n  duration: 250,\n  easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n  idle: false\n};\nvar store = new _dnd_kit_state__WEBPACK_IMPORTED_MODULE_6__.WeakStore();\nvar _group_dec, _index_dec, _init, _index, _previousGroup, _previousIndex, _group, _element;\n_index_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_6__.reactive], _group_dec = [_dnd_kit_state__WEBPACK_IMPORTED_MODULE_6__.reactive];\nvar Sortable2 = class {\n  constructor(_a, manager) {\n    __privateAdd(this, _index, __runInitializers(_init, 8, this)), __runInitializers(_init, 11, this);\n    __privateAdd(this, _previousGroup);\n    __privateAdd(this, _previousIndex);\n    __privateAdd(this, _group, __runInitializers(_init, 12, this)), __runInitializers(_init, 15, this);\n    __privateAdd(this, _element);\n    this.register = () => {\n      (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n        var _a, _b;\n        (_a = this.manager) == null ? void 0 : _a.registry.register(this.droppable);\n        (_b = this.manager) == null ? void 0 : _b.registry.register(this.draggable);\n      });\n      return () => this.unregister();\n    };\n    this.unregister = () => {\n      (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n        var _a, _b;\n        (_a = this.manager) == null ? void 0 : _a.registry.unregister(this.droppable);\n        (_b = this.manager) == null ? void 0 : _b.registry.unregister(this.draggable);\n      });\n    };\n    this.destroy = () => {\n      (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n        this.droppable.destroy();\n        this.draggable.destroy();\n      });\n    };\n    var _b = _a, {\n      effects: inputEffects = () => [],\n      group,\n      index,\n      sensors,\n      type,\n      transition = defaultSortableTransition,\n      plugins = defaultPlugins\n    } = _b, input = __objRest(_b, [\n      \"effects\",\n      \"group\",\n      \"index\",\n      \"sensors\",\n      \"type\",\n      \"transition\",\n      \"plugins\"\n    ]);\n    this.droppable = new SortableDroppable(input, manager, this);\n    this.draggable = new SortableDraggable(\n      __spreadProps(__spreadValues({}, input), {\n        effects: () => [\n          () => {\n            var _a2, _b2, _c;\n            const status = (_a2 = this.manager) == null ? void 0 : _a2.dragOperation.status;\n            if ((status == null ? void 0 : status.initializing) && this.id === ((_c = (_b2 = this.manager) == null ? void 0 : _b2.dragOperation.source) == null ? void 0 : _c.id)) {\n              store.clear(this.manager);\n            }\n            if (status == null ? void 0 : status.dragging) {\n              store.set(\n                this.manager,\n                this.id,\n                (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => ({\n                  initialIndex: this.index,\n                  initialGroup: this.group\n                }))\n              );\n            }\n          },\n          () => {\n            const { index: index2, group: group2, manager: _ } = this;\n            const previousIndex = __privateGet(this, _previousIndex);\n            const previousGroup = __privateGet(this, _previousGroup);\n            if (index2 !== previousIndex || group2 !== previousGroup) {\n              __privateSet(this, _previousIndex, index2);\n              __privateSet(this, _previousGroup, group2);\n              this.animate();\n            }\n          },\n          () => {\n            const { target } = this;\n            const { feedback, isDragSource } = this.draggable;\n            if (feedback == \"move\" && isDragSource) {\n              this.droppable.disabled = !target;\n            }\n          },\n          () => {\n            const { manager: manager2 } = this;\n            for (const plugin of plugins) {\n              manager2 == null ? void 0 : manager2.registry.register(plugin);\n            }\n          },\n          ...inputEffects()\n        ],\n        type,\n        sensors\n      }),\n      manager,\n      this\n    );\n    __privateSet(this, _element, input.element);\n    this.manager = manager;\n    this.index = index;\n    __privateSet(this, _previousIndex, index);\n    this.group = group;\n    __privateSet(this, _previousGroup, group);\n    this.type = type;\n    this.transition = transition;\n  }\n  get initialIndex() {\n    var _a, _b;\n    return (_b = (_a = store.get(this.manager, this.id)) == null ? void 0 : _a.initialIndex) != null ? _b : this.index;\n  }\n  get initialGroup() {\n    var _a, _b;\n    return (_b = (_a = store.get(this.manager, this.id)) == null ? void 0 : _a.initialGroup) != null ? _b : this.group;\n  }\n  animate() {\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => {\n      const { manager, transition } = this;\n      const { shape } = this.droppable;\n      if (!manager) return;\n      const { idle } = manager.dragOperation.status;\n      if (!shape || !transition || idle && !transition.idle) {\n        return;\n      }\n      manager.renderer.rendering.then(() => {\n        const { element } = this;\n        if (!element) {\n          return;\n        }\n        const updatedShape = this.refreshShape();\n        if (!updatedShape) {\n          return;\n        }\n        const delta = {\n          x: shape.boundingRectangle.left - updatedShape.boundingRectangle.left,\n          y: shape.boundingRectangle.top - updatedShape.boundingRectangle.top\n        };\n        const { translate } = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.getComputedStyles)(element);\n        const currentTranslate = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.computeTranslate)(element, translate, false);\n        const finalTranslate = (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.computeTranslate)(element, translate);\n        if (delta.x || delta.y) {\n          (0,_dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.animateTransform)({\n            element,\n            keyframes: {\n              translate: [\n                `${currentTranslate.x + delta.x}px ${currentTranslate.y + delta.y}px ${currentTranslate.z}`,\n                `${finalTranslate.x}px ${finalTranslate.y}px ${finalTranslate.z}`\n              ]\n            },\n            options: transition\n          }).then(() => {\n            if (!manager.dragOperation.status.dragging) {\n              this.droppable.shape = void 0;\n            }\n          });\n        }\n      });\n    });\n  }\n  get manager() {\n    return this.draggable.manager;\n  }\n  set manager(manager) {\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.draggable.manager = manager;\n      this.droppable.manager = manager;\n    });\n  }\n  set element(element) {\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      const previousElement = __privateGet(this, _element);\n      const droppableElement = this.droppable.element;\n      const draggableElement = this.draggable.element;\n      if (!droppableElement || droppableElement === previousElement) {\n        this.droppable.element = element;\n      }\n      if (!draggableElement || draggableElement === previousElement) {\n        this.draggable.element = element;\n      }\n      __privateSet(this, _element, element);\n    });\n  }\n  get element() {\n    var _a, _b;\n    const element = __privateGet(this, _element);\n    if (!element) return;\n    return (_b = (_a = _dnd_kit_dom_utilities__WEBPACK_IMPORTED_MODULE_2__.ProxiedElements.get(element)) != null ? _a : element) != null ? _b : this.droppable.element;\n  }\n  set target(target) {\n    this.droppable.element = target;\n  }\n  get target() {\n    return this.droppable.element;\n  }\n  set source(source) {\n    this.draggable.element = source;\n  }\n  get source() {\n    return this.draggable.element;\n  }\n  get disabled() {\n    return this.draggable.disabled && this.droppable.disabled;\n  }\n  set feedback(value) {\n    this.draggable.feedback = value;\n  }\n  set disabled(value) {\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.droppable.disabled = value;\n      this.draggable.disabled = value;\n    });\n  }\n  set data(data) {\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.droppable.data = data;\n      this.draggable.data = data;\n    });\n  }\n  set handle(handle) {\n    this.draggable.handle = handle;\n  }\n  set id(id) {\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.droppable.id = id;\n      this.draggable.id = id;\n    });\n  }\n  get id() {\n    return this.droppable.id;\n  }\n  set sensors(value) {\n    this.draggable.sensors = value;\n  }\n  set modifiers(value) {\n    this.draggable.modifiers = value;\n  }\n  set collisionPriority(value) {\n    this.droppable.collisionPriority = value;\n  }\n  set collisionDetector(value) {\n    this.droppable.collisionDetector = value != null ? value : _dnd_kit_collision__WEBPACK_IMPORTED_MODULE_4__.defaultCollisionDetection;\n  }\n  set alignment(value) {\n    this.draggable.alignment = value;\n  }\n  get alignment() {\n    return this.draggable.alignment;\n  }\n  set type(type) {\n    (0,_dnd_kit_state__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.droppable.type = type;\n      this.draggable.type = type;\n    });\n  }\n  get type() {\n    return this.draggable.type;\n  }\n  set accept(value) {\n    this.droppable.accept = value;\n  }\n  get accept() {\n    return this.droppable.accept;\n  }\n  get isDropTarget() {\n    return this.droppable.isDropTarget;\n  }\n  /**\n   * A boolean indicating whether the sortable item is the source of a drag operation.\n   */\n  get isDragSource() {\n    return this.draggable.isDragSource;\n  }\n  /**\n   * A boolean indicating whether the sortable item is being dragged.\n   */\n  get isDragging() {\n    return this.draggable.isDragging;\n  }\n  /**\n   * A boolean indicating whether the sortable item is being dropped.\n   */\n  get isDropping() {\n    return this.draggable.isDropping;\n  }\n  get status() {\n    return this.draggable.status;\n  }\n  refreshShape() {\n    return this.droppable.refreshShape();\n  }\n  accepts(draggable) {\n    return this.droppable.accepts(draggable);\n  }\n};\n_init = __decoratorStart();\n_index = new WeakMap();\n_previousGroup = new WeakMap();\n_previousIndex = new WeakMap();\n_group = new WeakMap();\n_element = new WeakMap();\n__decorateElement(_init, 4, \"index\", _index_dec, Sortable2, _index);\n__decorateElement(_init, 4, \"group\", _group_dec, Sortable2, _group);\n__decoratorMetadata(_init, Sortable2);\nvar SortableDraggable = class extends _dnd_kit_dom__WEBPACK_IMPORTED_MODULE_3__.Draggable {\n  constructor(input, manager, sortable) {\n    super(input, manager);\n    this.sortable = sortable;\n  }\n  get index() {\n    return this.sortable.index;\n  }\n};\nvar SortableDroppable = class extends _dnd_kit_dom__WEBPACK_IMPORTED_MODULE_3__.Droppable {\n  constructor(input, manager, sortable) {\n    super(input, manager);\n    this.sortable = sortable;\n  }\n};\n\n\n//# sourceMappingURL=sortable.js.map\n//# sourceMappingURL=sortable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGRuZC1raXQrZG9tQDAuMS4yMS9ub2RlX21vZHVsZXMvQGRuZC1raXQvZG9tL3NvcnRhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUErRTtBQUNBO0FBQ2pCO0FBQ3NJO0FBQ3pKO0FBQ0c7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsd0pBQXdKO0FBQ3pOO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDLFFBQVE7QUFDOUMsK0NBQStDO0FBQy9DO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxxREFBTTtBQUNqRDtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFNO0FBQ2hDLGNBQWMsZ0JBQWdCO0FBQzlCLFdBQVcsdUVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtEQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbURBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtREFBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5SDtBQUN6SDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZmVkZXJpY29qb3JnZWJvbmVsdG96emkvRGVza3RvcC9Xb3JrL3B1Y2svY29kZS9lY29zeXN0ZW0vcHVjay1jb25maWdzL3NoYWRjbi10d2Jsb2Nrcy9ub2RlX21vZHVsZXMvLnBucG0vQGRuZC1raXQrZG9tQDAuMS4yMS9ub2RlX21vZHVsZXMvQGRuZC1raXQvZG9tL3NvcnRhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdlYWtTdG9yZSwgZWZmZWN0LCBiYXRjaCwgdW50cmFja2VkLCByZWFjdGl2ZSB9IGZyb20gJ0BkbmQta2l0L3N0YXRlJztcbmltcG9ydCB7IGNsb3Nlc3RDb3JuZXJzLCBkZWZhdWx0Q29sbGlzaW9uRGV0ZWN0aW9uIH0gZnJvbSAnQGRuZC1raXQvY29sbGlzaW9uJztcbmltcG9ydCB7IFNjcm9sbGVyLCBEcmFnZ2FibGUsIERyb3BwYWJsZSB9IGZyb20gJ0BkbmQta2l0L2RvbSc7XG5pbXBvcnQgeyBpc0tleWJvYXJkRXZlbnQsIERPTVJlY3RhbmdsZSwgZ2V0VmlzaWJsZUJvdW5kaW5nUmVjdGFuZ2xlLCBzY3JvbGxJbnRvVmlld0lmTmVlZGVkLCBnZXRDb21wdXRlZFN0eWxlcywgY29tcHV0ZVRyYW5zbGF0ZSwgYW5pbWF0ZVRyYW5zZm9ybSwgUHJveGllZEVsZW1lbnRzIH0gZnJvbSAnQGRuZC1raXQvZG9tL3V0aWxpdGllcyc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAZG5kLWtpdC9hYnN0cmFjdCc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICdAZG5kLWtpdC9nZW9tZXRyeSc7XG5cbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2tub3duU3ltYm9sID0gKG5hbWUsIHN5bWJvbCkgPT4gKHN5bWJvbCA9IFN5bWJvbFtuYW1lXSkgPyBzeW1ib2wgOiBTeW1ib2wuZm9yKFwiU3ltYm9sLlwiICsgbmFtZSk7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fZGVjb3JhdG9yU3RhcnQgPSAoYmFzZSkgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiBbLCAsICwgX19jcmVhdGUoKF9hID0gdm9pZCAwICkgIT0gbnVsbCA/IF9hIDogbnVsbCldO1xufTtcbnZhciBfX2RlY29yYXRvclN0cmluZ3MgPSBbXCJjbGFzc1wiLCBcIm1ldGhvZFwiLCBcImdldHRlclwiLCBcInNldHRlclwiLCBcImFjY2Vzc29yXCIsIFwiZmllbGRcIiwgXCJ2YWx1ZVwiLCBcImdldFwiLCBcInNldFwiXTtcbnZhciBfX2V4cGVjdEZuID0gKGZuKSA9PiBmbiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiID8gX190eXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKSA6IGZuO1xudmFyIF9fZGVjb3JhdG9yQ29udGV4dCA9IChraW5kLCBuYW1lLCBkb25lLCBtZXRhZGF0YSwgZm5zKSA9PiAoeyBraW5kOiBfX2RlY29yYXRvclN0cmluZ3Nba2luZF0sIG5hbWUsIG1ldGFkYXRhLCBhZGRJbml0aWFsaXplcjogKGZuKSA9PiBkb25lLl8gPyBfX3R5cGVFcnJvcihcIkFscmVhZHkgaW5pdGlhbGl6ZWRcIikgOiBmbnMucHVzaChfX2V4cGVjdEZuKGZuIHx8IG51bGwpKSB9KTtcbnZhciBfX2RlY29yYXRvck1ldGFkYXRhID0gKGFycmF5LCB0YXJnZXQpID0+IF9fZGVmTm9ybWFsUHJvcCh0YXJnZXQsIF9fa25vd25TeW1ib2woXCJtZXRhZGF0YVwiKSwgYXJyYXlbM10pO1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKGFycmF5LCBmbGFncywgc2VsZiwgdmFsdWUpID0+IHtcbiAgZm9yICh2YXIgaSA9IDAsIGZucyA9IGFycmF5W2ZsYWdzID4+IDFdLCBuID0gZm5zICYmIGZucy5sZW5ndGg7IGkgPCBuOyBpKyspIGZsYWdzICYgMSA/IGZuc1tpXS5jYWxsKHNlbGYpIDogdmFsdWUgPSBmbnNbaV0uY2FsbChzZWxmLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kZWNvcmF0ZUVsZW1lbnQgPSAoYXJyYXksIGZsYWdzLCBuYW1lLCBkZWNvcmF0b3JzLCB0YXJnZXQsIGV4dHJhKSA9PiB7XG4gIHZhciBmbiwgaXQsIGRvbmUsIGN0eCwgYWNjZXNzLCBrID0gZmxhZ3MgJiA3LCBzID0gZmFsc2UsIHAgPSBmYWxzZTtcbiAgdmFyIGogPSBhcnJheS5sZW5ndGggKyAxICwga2V5ID0gX19kZWNvcmF0b3JTdHJpbmdzW2sgKyA1XTtcbiAgdmFyIGluaXRpYWxpemVycyA9IChhcnJheVtqIC0gMV0gPSBbXSksIGV4dHJhSW5pdGlhbGl6ZXJzID0gYXJyYXlbal0gfHwgKGFycmF5W2pdID0gW10pO1xuICB2YXIgZGVzYyA9ICgodGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZSksIF9fZ2V0T3duUHJvcERlc2MoeyBnZXQgW25hbWVdKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgZXh0cmEpO1xuICB9LCBzZXQgW25hbWVdKHgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlU2V0KHRoaXMsIGV4dHJhLCB4KTtcbiAgfSB9LCBuYW1lKSk7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY3R4ID0gX19kZWNvcmF0b3JDb250ZXh0KGssIG5hbWUsIGRvbmUgPSB7fSwgYXJyYXlbM10sIGV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICB7XG4gICAgICBjdHguc3RhdGljID0gcywgY3R4LnByaXZhdGUgPSBwLCBhY2Nlc3MgPSBjdHguYWNjZXNzID0geyBoYXM6ICh4KSA9PiBuYW1lIGluIHggfTtcbiAgICAgIGFjY2Vzcy5nZXQgPSAoeCkgPT4geFtuYW1lXTtcbiAgICAgIGFjY2Vzcy5zZXQgPSAoeCwgeSkgPT4geFtuYW1lXSA9IHk7XG4gICAgfVxuICAgIGl0ID0gKDAsIGRlY29yYXRvcnNbaV0pKHsgZ2V0OiBkZXNjLmdldCwgc2V0OiBkZXNjLnNldCB9ICwgY3R4KSwgZG9uZS5fID0gMTtcbiAgICBpZiAoaXQgPT09IHZvaWQgMCkgX19leHBlY3RGbihpdCkgJiYgKGRlc2Nba2V5XSA9IGl0ICk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGl0ICE9PSBcIm9iamVjdFwiIHx8IGl0ID09PSBudWxsKSBfX3R5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICBlbHNlIF9fZXhwZWN0Rm4oZm4gPSBpdC5nZXQpICYmIChkZXNjLmdldCA9IGZuKSwgX19leHBlY3RGbihmbiA9IGl0LnNldCkgJiYgKGRlc2Muc2V0ID0gZm4pLCBfX2V4cGVjdEZuKGZuID0gaXQuaW5pdCkgJiYgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoZm4pO1xuICB9XG4gIHJldHVybiBkZXNjICYmIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIGRlc2MpLCB0YXJnZXQ7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4gbWVtYmVyLmhhcyhvYmopIHx8IF9fdHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIG1lbWJlci5nZXQob2JqKSk7XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4gbWVtYmVyLmhhcyhvYmopID8gX190eXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSk7XG5cbi8vIHNyYy9zb3J0YWJsZS91dGlsaXRpZXMudHNcbmZ1bmN0aW9uIGlzU29ydGFibGUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIFNvcnRhYmxlRHJvcHBhYmxlIHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBTb3J0YWJsZURyYWdnYWJsZTtcbn1cblxuLy8gc3JjL3NvcnRhYmxlL3BsdWdpbnMvU29ydGFibGVLZXlib2FyZFBsdWdpbi50c1xudmFyIFRPTEVSQU5DRSA9IDEwO1xudmFyIFNvcnRhYmxlS2V5Ym9hcmRQbHVnaW4gPSBjbGFzcyBleHRlbmRzIFBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICBjb25zdCBjbGVhbnVwRWZmZWN0ID0gZWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHsgZHJhZ09wZXJhdGlvbiB9ID0gbWFuYWdlcjtcbiAgICAgIGlmICghaXNLZXlib2FyZEV2ZW50KGRyYWdPcGVyYXRpb24uYWN0aXZhdG9yRXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTb3J0YWJsZShkcmFnT3BlcmF0aW9uLnNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdPcGVyYXRpb24uc3RhdHVzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGVyID0gbWFuYWdlci5yZWdpc3RyeS5wbHVnaW5zLmdldChTY3JvbGxlcik7XG4gICAgICAgIGlmIChzY3JvbGxlcikge1xuICAgICAgICAgIHNjcm9sbGVyLmRpc2FibGUoKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gc2Nyb2xsZXIuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG1hbmFnZXIubW9uaXRvci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJkcmFnbW92ZVwiLFxuICAgICAgKGV2ZW50LCBtYW5hZ2VyMikgPT4ge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAhZXZlbnQubmF0aXZlRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBkcmFnT3BlcmF0aW9uIH0gPSBtYW5hZ2VyMjtcbiAgICAgICAgICBpZiAoIWlzS2V5Ym9hcmRFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1NvcnRhYmxlKGRyYWdPcGVyYXRpb24uc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRyYWdPcGVyYXRpb24uc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBhY3Rpb25zLCBjb2xsaXNpb25PYnNlcnZlciwgcmVnaXN0cnkgfSA9IG1hbmFnZXIyO1xuICAgICAgICAgIGNvbnN0IHsgYnkgfSA9IGV2ZW50O1xuICAgICAgICAgIGlmICghYnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGJ5KTtcbiAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBkcmFnT3BlcmF0aW9uO1xuICAgICAgICAgIGNvbnN0IHsgY2VudGVyIH0gPSBkcmFnT3BlcmF0aW9uLnNoYXBlLmN1cnJlbnQ7XG4gICAgICAgICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBbXTtcbiAgICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRyb3BwYWJsZSBvZiByZWdpc3RyeS5kcm9wcGFibGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgaWQ6IGlkMiB9ID0gZHJvcHBhYmxlO1xuICAgICAgICAgICAgICBpZiAoIWRyb3BwYWJsZS5hY2NlcHRzKHNvdXJjZSkgfHwgaWQyID09PSAodGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQuaWQpICYmIGlzU29ydGFibGUoZHJvcHBhYmxlKSB8fCAhZHJvcHBhYmxlLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcHJldmlvdXNTaGFwZSA9IGRyb3BwYWJsZS5zaGFwZTtcbiAgICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgRE9NUmVjdGFuZ2xlKGRyb3BwYWJsZS5lbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoZWxlbWVudCkgPT4gZ2V0VmlzaWJsZUJvdW5kaW5nUmVjdGFuZ2xlKGVsZW1lbnQsIHZvaWQgMCwgMC4yKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKCFzaGFwZS5oZWlnaHQgfHwgIXNoYXBlLndpZHRoKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImRvd25cIiAmJiBjZW50ZXIueSArIFRPTEVSQU5DRSA8IHNoYXBlLmNlbnRlci55IHx8IGRpcmVjdGlvbiA9PSBcInVwXCIgJiYgY2VudGVyLnkgLSBUT0xFUkFOQ0UgPiBzaGFwZS5jZW50ZXIueSB8fCBkaXJlY3Rpb24gPT0gXCJsZWZ0XCIgJiYgY2VudGVyLnggLSBUT0xFUkFOQ0UgPiBzaGFwZS5jZW50ZXIueCB8fCBkaXJlY3Rpb24gPT0gXCJyaWdodFwiICYmIGNlbnRlci54ICsgVE9MRVJBTkNFIDwgc2hhcGUuY2VudGVyLngpIHtcbiAgICAgICAgICAgICAgICBwb3RlbnRpYWxUYXJnZXRzLnB1c2goZHJvcHBhYmxlKTtcbiAgICAgICAgICAgICAgICBkcm9wcGFibGUuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwLnB1c2goKCkgPT4gZHJvcHBhYmxlLnNoYXBlID0gcHJldmlvdXNTaGFwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbGxpc2lvbk9ic2VydmVyLmRpc2FibGUoKTtcbiAgICAgICAgICBjb25zdCBjb2xsaXNpb25zID0gY29sbGlzaW9uT2JzZXJ2ZXIuY29tcHV0ZUNvbGxpc2lvbnMoXG4gICAgICAgICAgICBwb3RlbnRpYWxUYXJnZXRzLFxuICAgICAgICAgICAgY2xvc2VzdENvcm5lcnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJhdGNoKCgpID0+IGNsZWFudXAuZm9yRWFjaCgoY2xlYW4pID0+IGNsZWFuKCkpKTtcbiAgICAgICAgICBjb25zdCBbZmlyc3RDb2xsaXNpb25dID0gY29sbGlzaW9ucztcbiAgICAgICAgICBpZiAoIWZpcnN0Q29sbGlzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGZpcnN0Q29sbGlzaW9uO1xuICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIGdyb3VwIH0gPSBzb3VyY2Uuc29ydGFibGU7XG4gICAgICAgICAgYWN0aW9ucy5zZXREcm9wVGFyZ2V0KGlkKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlOiBzb3VyY2UyLCB0YXJnZXQ6IHRhcmdldDIsIHNoYXBlIH0gPSBkcmFnT3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UyIHx8ICFpc1NvcnRhYmxlKHNvdXJjZTIpIHx8ICFzaGFwZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGluZGV4OiBuZXdJbmRleCxcbiAgICAgICAgICAgICAgZ3JvdXA6IG5ld0dyb3VwLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldEVsZW1lbnRcbiAgICAgICAgICAgIH0gPSBzb3VyY2UyLnNvcnRhYmxlO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZCA9IGluZGV4ICE9PSBuZXdJbmRleCB8fCBncm91cCAhPT0gbmV3R3JvdXA7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdXBkYXRlZCA/IHRhcmdldEVsZW1lbnQgOiB0YXJnZXQyID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQyLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkU2hhcGUgPSBuZXcgRE9NUmVjdGFuZ2xlKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVkU2hhcGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBSZWN0YW5nbGUuZGVsdGEoXG4gICAgICAgICAgICAgIHVwZGF0ZWRTaGFwZSxcbiAgICAgICAgICAgICAgUmVjdGFuZ2xlLmZyb20oc2hhcGUuY3VycmVudC5ib3VuZGluZ1JlY3RhbmdsZSksXG4gICAgICAgICAgICAgIHNvdXJjZTIuYWxpZ25tZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWN0aW9ucy5tb3ZlKHtcbiAgICAgICAgICAgICAgYnk6IGRlbHRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgIGFjdGlvbnMuc2V0RHJvcFRhcmdldChzb3VyY2UyLmlkKS50aGVuKCgpID0+IGNvbGxpc2lvbk9ic2VydmVyLmVuYWJsZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbGxpc2lvbk9ic2VydmVyLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBjbGVhbnVwRWZmZWN0KCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERpcmVjdGlvbihkZWx0YSkge1xuICBjb25zdCB7IHgsIHkgfSA9IGRlbHRhO1xuICBpZiAoeCA+IDApIHtcbiAgICByZXR1cm4gXCJyaWdodFwiO1xuICB9IGVsc2UgaWYgKHggPCAwKSB7XG4gICAgcmV0dXJuIFwibGVmdFwiO1xuICB9IGVsc2UgaWYgKHkgPiAwKSB7XG4gICAgcmV0dXJuIFwiZG93blwiO1xuICB9IGVsc2UgaWYgKHkgPCAwKSB7XG4gICAgcmV0dXJuIFwidXBcIjtcbiAgfVxufVxuXG4vLyAuLi9oZWxwZXJzL2Rpc3QvaW5kZXguanNcbnZhciBfX2RlZlByb3AyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMyID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9sczIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bTIgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wMihvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMyID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AyLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AyKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9sczIpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzMihiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bTIuY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wMihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzMiA9IChhLCBiKSA9PiBfX2RlZlByb3BzMihhLCBfX2dldE93blByb3BEZXNjczIoYikpO1xuZnVuY3Rpb24gYXJyYXlNb3ZlKGFycmF5LCBmcm9tLCB0bykge1xuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgY29uc3QgbmV3QXJyYXkgPSBhcnJheS5zbGljZSgpO1xuICBuZXdBcnJheS5zcGxpY2UodG8sIDAsIG5ld0FycmF5LnNwbGljZShmcm9tLCAxKVswXSk7XG4gIHJldHVybiBuZXdBcnJheTtcbn1cbmZ1bmN0aW9uIG11dGF0ZShpdGVtcywgZXZlbnQsIG11dGF0aW9uKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHsgc291cmNlLCB0YXJnZXQsIGNhbmNlbGVkIH0gPSBldmVudC5vcGVyYXRpb247XG4gIGlmICghc291cmNlIHx8ICF0YXJnZXQgfHwgY2FuY2VsZWQpIHtcbiAgICBpZiAoXCJwcmV2ZW50RGVmYXVsdFwiIGluIGV2ZW50KSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBjb25zdCBmaW5kSW5kZXggPSAoaXRlbSwgaWQpID0+IGl0ZW0gPT09IGlkIHx8IHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBpdGVtICYmIGl0ZW0uaWQgPT09IGlkO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBjb25zdCBzb3VyY2VJbmRleDIgPSBpdGVtcy5maW5kSW5kZXgoKGl0ZW0pID0+IGZpbmRJbmRleChpdGVtLCBzb3VyY2UuaWQpKTtcbiAgICBjb25zdCB0YXJnZXRJbmRleDIgPSBpdGVtcy5maW5kSW5kZXgoKGl0ZW0pID0+IGZpbmRJbmRleChpdGVtLCB0YXJnZXQuaWQpKTtcbiAgICBpZiAoc291cmNlSW5kZXgyID09PSAtMSB8fCB0YXJnZXRJbmRleDIgPT09IC0xKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIGlmICghY2FuY2VsZWQgJiYgXCJpbmRleFwiIGluIHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlLmluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBwcm9qZWN0ZWRTb3VyY2VJbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgICAgIGlmIChwcm9qZWN0ZWRTb3VyY2VJbmRleCAhPT0gc291cmNlSW5kZXgyKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbihpdGVtcywgc291cmNlSW5kZXgyLCBwcm9qZWN0ZWRTb3VyY2VJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGlvbihpdGVtcywgc291cmNlSW5kZXgyLCB0YXJnZXRJbmRleDIpO1xuICB9XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhpdGVtcyk7XG4gIGxldCBzb3VyY2VJbmRleCA9IC0xO1xuICBsZXQgc291cmNlUGFyZW50O1xuICBsZXQgdGFyZ2V0SW5kZXggPSAtMTtcbiAgbGV0IHRhcmdldFBhcmVudDtcbiAgZm9yIChjb25zdCBbaWQsIGNoaWxkcmVuXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSAtMSkge1xuICAgICAgc291cmNlSW5kZXggPSBjaGlsZHJlbi5maW5kSW5kZXgoKGl0ZW0pID0+IGZpbmRJbmRleChpdGVtLCBzb3VyY2UuaWQpKTtcbiAgICAgIGlmIChzb3VyY2VJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc291cmNlUGFyZW50ID0gaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRhcmdldEluZGV4ID0gY2hpbGRyZW4uZmluZEluZGV4KChpdGVtKSA9PiBmaW5kSW5kZXgoaXRlbSwgdGFyZ2V0LmlkKSk7XG4gICAgICBpZiAodGFyZ2V0SW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRhcmdldFBhcmVudCA9IGlkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggIT09IC0xICYmIHRhcmdldEluZGV4ICE9PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghc291cmNlLm1hbmFnZXIpIHJldHVybiBpdGVtcztcbiAgY29uc3QgeyBkcmFnT3BlcmF0aW9uIH0gPSBzb3VyY2UubWFuYWdlcjtcbiAgY29uc3QgcG9zaXRpb24gPSAoX2IgPSAoX2EgPSBkcmFnT3BlcmF0aW9uLnNoYXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3VycmVudC5jZW50ZXIpICE9IG51bGwgPyBfYiA6IGRyYWdPcGVyYXRpb24ucG9zaXRpb24uY3VycmVudDtcbiAgaWYgKHRhcmdldFBhcmVudCA9PSBudWxsKSB7XG4gICAgaWYgKHRhcmdldC5pZCBpbiBpdGVtcykge1xuICAgICAgY29uc3QgaW5zZXJ0aW9uSW5kZXggPSB0YXJnZXQuc2hhcGUgJiYgcG9zaXRpb24ueSA+IHRhcmdldC5zaGFwZS5jZW50ZXIueSA/IGl0ZW1zW3RhcmdldC5pZF0ubGVuZ3RoIDogMDtcbiAgICAgIHRhcmdldFBhcmVudCA9IHRhcmdldC5pZDtcbiAgICAgIHRhcmdldEluZGV4ID0gaW5zZXJ0aW9uSW5kZXg7XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VQYXJlbnQgPT0gbnVsbCB8fCB0YXJnZXRQYXJlbnQgPT0gbnVsbCB8fCBzb3VyY2VQYXJlbnQgPT09IHRhcmdldFBhcmVudCAmJiBzb3VyY2VJbmRleCA9PT0gdGFyZ2V0SW5kZXgpIHtcbiAgICBpZiAoXCJwcmV2ZW50RGVmYXVsdFwiIGluIGV2ZW50KSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBpZiAoc291cmNlUGFyZW50ID09PSB0YXJnZXRQYXJlbnQpIHtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wczIoX19zcHJlYWRWYWx1ZXMyKHt9LCBpdGVtcyksIHtcbiAgICAgIFtzb3VyY2VQYXJlbnRdOiBtdXRhdGlvbihpdGVtc1tzb3VyY2VQYXJlbnRdLCBzb3VyY2VJbmRleCwgdGFyZ2V0SW5kZXgpXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgaXNCZWxvd1RhcmdldCA9IHRhcmdldC5zaGFwZSAmJiBNYXRoLnJvdW5kKHBvc2l0aW9uLnkpID4gTWF0aC5yb3VuZCh0YXJnZXQuc2hhcGUuY2VudGVyLnkpO1xuICBjb25zdCBtb2RpZmllciA9IGlzQmVsb3dUYXJnZXQgPyAxIDogMDtcbiAgY29uc3Qgc291cmNlSXRlbSA9IGl0ZW1zW3NvdXJjZVBhcmVudF1bc291cmNlSW5kZXhdO1xuICByZXR1cm4gX19zcHJlYWRQcm9wczIoX19zcHJlYWRWYWx1ZXMyKHt9LCBpdGVtcyksIHtcbiAgICBbc291cmNlUGFyZW50XTogW1xuICAgICAgLi4uaXRlbXNbc291cmNlUGFyZW50XS5zbGljZSgwLCBzb3VyY2VJbmRleCksXG4gICAgICAuLi5pdGVtc1tzb3VyY2VQYXJlbnRdLnNsaWNlKHNvdXJjZUluZGV4ICsgMSlcbiAgICBdLFxuICAgIFt0YXJnZXRQYXJlbnRdOiBbXG4gICAgICAuLi5pdGVtc1t0YXJnZXRQYXJlbnRdLnNsaWNlKDAsIHRhcmdldEluZGV4ICsgbW9kaWZpZXIpLFxuICAgICAgc291cmNlSXRlbSxcbiAgICAgIC4uLml0ZW1zW3RhcmdldFBhcmVudF0uc2xpY2UodGFyZ2V0SW5kZXggKyBtb2RpZmllcilcbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gbW92ZShpdGVtcywgZXZlbnQpIHtcbiAgcmV0dXJuIG11dGF0ZShpdGVtcywgZXZlbnQsIGFycmF5TW92ZSk7XG59XG52YXIgZGVmYXVsdEdyb3VwID0gXCJfX2RlZmF1bHRfX1wiO1xudmFyIE9wdGltaXN0aWNTb3J0aW5nUGx1Z2luID0gY2xhc3MgZXh0ZW5kcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgY29uc3QgZ2V0U29ydGFibGVJbnN0YW5jZXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzb3J0YWJsZUluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IGRyb3BwYWJsZSBvZiBtYW5hZ2VyLnJlZ2lzdHJ5LmRyb3BwYWJsZXMpIHtcbiAgICAgICAgaWYgKGRyb3BwYWJsZSBpbnN0YW5jZW9mIFNvcnRhYmxlRHJvcHBhYmxlKSB7XG4gICAgICAgICAgY29uc3QgeyBzb3J0YWJsZSB9ID0gZHJvcHBhYmxlO1xuICAgICAgICAgIGNvbnN0IHsgZ3JvdXAgfSA9IHNvcnRhYmxlO1xuICAgICAgICAgIGxldCBpbnN0YW5jZXMgPSBzb3J0YWJsZUluc3RhbmNlcy5nZXQoZ3JvdXApO1xuICAgICAgICAgIGlmICghaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBpbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgc29ydGFibGVJbnN0YW5jZXMuc2V0KGdyb3VwLCBpbnN0YW5jZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZXMuYWRkKHNvcnRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbZ3JvdXAsIGluc3RhbmNlc10gb2Ygc29ydGFibGVJbnN0YW5jZXMpIHtcbiAgICAgICAgc29ydGFibGVJbnN0YW5jZXMuc2V0KGdyb3VwLCBuZXcgU2V0KHNvcnQoaW5zdGFuY2VzKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvcnRhYmxlSW5zdGFuY2VzO1xuICAgIH07XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBbXG4gICAgICBtYW5hZ2VyLm1vbml0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChldmVudCwgbWFuYWdlcjIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkcmFnT3BlcmF0aW9uIH0gPSBtYW5hZ2VyMjtcbiAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCB9ID0gZHJhZ09wZXJhdGlvbjtcbiAgICAgICAgaWYgKCFpc1NvcnRhYmxlKHNvdXJjZSkgfHwgIWlzU29ydGFibGUodGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLnNvcnRhYmxlID09PSB0YXJnZXQuc29ydGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zdGFuY2VzID0gZ2V0U29ydGFibGVJbnN0YW5jZXMoKTtcbiAgICAgICAgY29uc3Qgc2FtZUdyb3VwID0gc291cmNlLnNvcnRhYmxlLmdyb3VwID09PSB0YXJnZXQuc29ydGFibGUuZ3JvdXA7XG4gICAgICAgIGNvbnN0IHNvdXJjZUluc3RhbmNlcyA9IGluc3RhbmNlcy5nZXQoc291cmNlLnNvcnRhYmxlLmdyb3VwKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5zdGFuY2VzID0gc2FtZUdyb3VwID8gc291cmNlSW5zdGFuY2VzIDogaW5zdGFuY2VzLmdldCh0YXJnZXQuc29ydGFibGUuZ3JvdXApO1xuICAgICAgICBpZiAoIXNvdXJjZUluc3RhbmNlcyB8fCAhdGFyZ2V0SW5zdGFuY2VzKSByZXR1cm47XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICAgIG1hbmFnZXIyLnJlbmRlcmVyLnJlbmRlcmluZy50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbmV3SW5zdGFuY2VzID0gZ2V0U29ydGFibGVJbnN0YW5jZXMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2dyb3VwLCBzb3J0YWJsZUluc3RhbmNlc10gb2YgaW5zdGFuY2VzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbShzb3J0YWJsZUluc3RhbmNlcykuZW50cmllcygpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgc29ydGFibGVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGFibGUuaW5kZXggIT09IGluZGV4IHx8IHNvcnRhYmxlLmdyb3VwICE9PSBncm91cCB8fCAhKChfYSA9IG5ld0luc3RhbmNlcy5nZXQoZ3JvdXApKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGFzKHNvcnRhYmxlKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBzb3VyY2Uuc29ydGFibGUuZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0YXJnZXQuc29ydGFibGUuZWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0RWxlbWVudCB8fCAhc291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNhbWVHcm91cCAmJiB0YXJnZXQuaWQgPT09IHNvdXJjZS5zb3J0YWJsZS5ncm91cCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcmRlcmVkU291cmNlU29ydGFibGVzID0gc29ydChzb3VyY2VJbnN0YW5jZXMpO1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJlZFRhcmdldFNvcnRhYmxlcyA9IHNhbWVHcm91cCA/IG9yZGVyZWRTb3VyY2VTb3J0YWJsZXMgOiBzb3J0KHRhcmdldEluc3RhbmNlcyk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VHcm91cCA9IChfYiA9IHNvdXJjZS5zb3J0YWJsZS5ncm91cCkgIT0gbnVsbCA/IF9iIDogZGVmYXVsdEdyb3VwO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0R3JvdXAgPSAoX2MgPSB0YXJnZXQuc29ydGFibGUuZ3JvdXApICE9IG51bGwgPyBfYyA6IGRlZmF1bHRHcm91cDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgICBbc291cmNlR3JvdXBdOiBvcmRlcmVkU291cmNlU29ydGFibGVzLFxuICAgICAgICAgICAgICBbdGFyZ2V0R3JvdXBdOiBvcmRlcmVkVGFyZ2V0U29ydGFibGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBtb3ZlKHN0YXRlLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IG5ld1N0YXRlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VJbmRleCA9IG5ld1N0YXRlW3RhcmdldEdyb3VwXS5pbmRleE9mKHNvdXJjZS5zb3J0YWJsZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IG5ld1N0YXRlW3RhcmdldEdyb3VwXS5pbmRleE9mKHRhcmdldC5zb3J0YWJsZSk7XG4gICAgICAgICAgICBtYW5hZ2VyMi5jb2xsaXNpb25PYnNlcnZlci5kaXNhYmxlKCk7XG4gICAgICAgICAgICByZW9yZGVyKHNvdXJjZUVsZW1lbnQsIHNvdXJjZUluZGV4LCB0YXJnZXRFbGVtZW50LCB0YXJnZXRJbmRleCk7XG4gICAgICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBzb3J0YWJsZV0gb2YgbmV3U3RhdGVbc291cmNlR3JvdXBdLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzYW1lR3JvdXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgc29ydGFibGVdIG9mIG5ld1N0YXRlW3RhcmdldEdyb3VwXS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIHNvcnRhYmxlLmdyb3VwID0gdGFyZ2V0LnNvcnRhYmxlLmdyb3VwO1xuICAgICAgICAgICAgICAgICAgc29ydGFibGUuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFuYWdlcjIuYWN0aW9ucy5zZXREcm9wVGFyZ2V0KHNvdXJjZS5pZCkudGhlbigoKSA9PiBtYW5hZ2VyMi5jb2xsaXNpb25PYnNlcnZlci5lbmFibGUoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBtYW5hZ2VyLm1vbml0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgKGV2ZW50LCBtYW5hZ2VyMikgPT4ge1xuICAgICAgICBpZiAoIWV2ZW50LmNhbmNlbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZHJhZ09wZXJhdGlvbiB9ID0gbWFuYWdlcjI7XG4gICAgICAgIGNvbnN0IHsgc291cmNlIH0gPSBkcmFnT3BlcmF0aW9uO1xuICAgICAgICBpZiAoIWlzU29ydGFibGUoc291cmNlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLnNvcnRhYmxlLmluaXRpYWxJbmRleCA9PT0gc291cmNlLnNvcnRhYmxlLmluZGV4ICYmIHNvdXJjZS5zb3J0YWJsZS5pbml0aWFsR3JvdXAgPT09IHNvdXJjZS5zb3J0YWJsZS5ncm91cCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5zdGFuY2VzID0gZ2V0U29ydGFibGVJbnN0YW5jZXMoKTtcbiAgICAgICAgICBjb25zdCBpbml0aWFsR3JvdXBJbnN0YW5jZXMgPSBpbnN0YW5jZXMuZ2V0KFxuICAgICAgICAgICAgc291cmNlLnNvcnRhYmxlLmluaXRpYWxHcm91cFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFpbml0aWFsR3JvdXBJbnN0YW5jZXMpIHJldHVybjtcbiAgICAgICAgICBtYW5hZ2VyMi5yZW5kZXJlci5yZW5kZXJpbmcudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtncm91cCwgc29ydGFibGVJbnN0YW5jZXNdIG9mIGluc3RhbmNlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20oc29ydGFibGVJbnN0YW5jZXMpLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHNvcnRhYmxlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlLmluZGV4ICE9PSBpbmRleCB8fCBzb3J0YWJsZS5ncm91cCAhPT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxHcm91cCA9IHNvcnQoaW5pdGlhbEdyb3VwSW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBzb3VyY2Uuc29ydGFibGUuZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGluaXRpYWxHcm91cFtzb3VyY2Uuc29ydGFibGUuaW5pdGlhbEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0YXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldC5lbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldEVsZW1lbnQgfHwgIXNvdXJjZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVvcmRlcihzb3VyY2VFbGVtZW50LCB0YXJnZXQuaW5kZXgsIHRhcmdldEVsZW1lbnQsIHNvdXJjZS5pbmRleCk7XG4gICAgICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW18sIHNvcnRhYmxlSW5zdGFuY2VzXSBvZiBpbnN0YW5jZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20oc29ydGFibGVJbnN0YW5jZXMpLnZhbHVlcygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc29ydGFibGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgc29ydGFibGUuaW5kZXggPSBzb3J0YWJsZS5pbml0aWFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICBzb3J0YWJsZS5ncm91cCA9IHNvcnRhYmxlLmluaXRpYWxHcm91cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgXTtcbiAgICB0aGlzLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVuc3Vic2NyaWJlTGlzdGVuZXIgb2YgdW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiByZW9yZGVyKHNvdXJjZUVsZW1lbnQsIHNvdXJjZUluZGV4LCB0YXJnZXRFbGVtZW50LCB0YXJnZXRJbmRleCkge1xuICBjb25zdCBwb3NpdGlvbiA9IHRhcmdldEluZGV4IDwgc291cmNlSW5kZXggPyBcImFmdGVyZW5kXCIgOiBcImJlZm9yZWJlZ2luXCI7XG4gIHRhcmdldEVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KHBvc2l0aW9uLCBzb3VyY2VFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHNvcnRCeUluZGV4KGEsIGIpIHtcbiAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xufVxuZnVuY3Rpb24gc29ydChpbnN0YW5jZXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oaW5zdGFuY2VzKS5zb3J0KHNvcnRCeUluZGV4KTtcbn1cblxuLy8gc3JjL3NvcnRhYmxlL3NvcnRhYmxlLnRzXG52YXIgZGVmYXVsdFBsdWdpbnMgPSBbXG4gIFNvcnRhYmxlS2V5Ym9hcmRQbHVnaW4sXG4gIE9wdGltaXN0aWNTb3J0aW5nUGx1Z2luXG5dO1xudmFyIGRlZmF1bHRTb3J0YWJsZVRyYW5zaXRpb24gPSB7XG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2luZzogXCJjdWJpYy1iZXppZXIoMC4yNSwgMSwgMC41LCAxKVwiLFxuICBpZGxlOiBmYWxzZVxufTtcbnZhciBzdG9yZSA9IG5ldyBXZWFrU3RvcmUoKTtcbnZhciBfZ3JvdXBfZGVjLCBfaW5kZXhfZGVjLCBfaW5pdCwgX2luZGV4LCBfcHJldmlvdXNHcm91cCwgX3ByZXZpb3VzSW5kZXgsIF9ncm91cCwgX2VsZW1lbnQ7XG5faW5kZXhfZGVjID0gW3JlYWN0aXZlXSwgX2dyb3VwX2RlYyA9IFtyZWFjdGl2ZV07XG52YXIgU29ydGFibGUyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfYSwgbWFuYWdlcikge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaW5kZXgsIF9fcnVuSW5pdGlhbGl6ZXJzKF9pbml0LCA4LCB0aGlzKSksIF9fcnVuSW5pdGlhbGl6ZXJzKF9pbml0LCAxMSwgdGhpcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcmV2aW91c0dyb3VwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3ByZXZpb3VzSW5kZXgpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZ3JvdXAsIF9fcnVuSW5pdGlhbGl6ZXJzKF9pbml0LCAxMiwgdGhpcykpLCBfX3J1bkluaXRpYWxpemVycyhfaW5pdCwgMTUsIHRoaXMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZWxlbWVudCk7XG4gICAgdGhpcy5yZWdpc3RlciA9ICgpID0+IHtcbiAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9hID0gdGhpcy5tYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVnaXN0cnkucmVnaXN0ZXIodGhpcy5kcm9wcGFibGUpO1xuICAgICAgICAoX2IgPSB0aGlzLm1hbmFnZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5yZWdpc3RyeS5yZWdpc3Rlcih0aGlzLmRyYWdnYWJsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICB9O1xuICAgIHRoaXMudW5yZWdpc3RlciA9ICgpID0+IHtcbiAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9hID0gdGhpcy5tYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVnaXN0cnkudW5yZWdpc3Rlcih0aGlzLmRyb3BwYWJsZSk7XG4gICAgICAgIChfYiA9IHRoaXMubWFuYWdlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnJlZ2lzdHJ5LnVucmVnaXN0ZXIodGhpcy5kcmFnZ2FibGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJvcHBhYmxlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgX2IgPSBfYSwge1xuICAgICAgZWZmZWN0czogaW5wdXRFZmZlY3RzID0gKCkgPT4gW10sXG4gICAgICBncm91cCxcbiAgICAgIGluZGV4LFxuICAgICAgc2Vuc29ycyxcbiAgICAgIHR5cGUsXG4gICAgICB0cmFuc2l0aW9uID0gZGVmYXVsdFNvcnRhYmxlVHJhbnNpdGlvbixcbiAgICAgIHBsdWdpbnMgPSBkZWZhdWx0UGx1Z2luc1xuICAgIH0gPSBfYiwgaW5wdXQgPSBfX29ialJlc3QoX2IsIFtcbiAgICAgIFwiZWZmZWN0c1wiLFxuICAgICAgXCJncm91cFwiLFxuICAgICAgXCJpbmRleFwiLFxuICAgICAgXCJzZW5zb3JzXCIsXG4gICAgICBcInR5cGVcIixcbiAgICAgIFwidHJhbnNpdGlvblwiLFxuICAgICAgXCJwbHVnaW5zXCJcbiAgICBdKTtcbiAgICB0aGlzLmRyb3BwYWJsZSA9IG5ldyBTb3J0YWJsZURyb3BwYWJsZShpbnB1dCwgbWFuYWdlciwgdGhpcyk7XG4gICAgdGhpcy5kcmFnZ2FibGUgPSBuZXcgU29ydGFibGVEcmFnZ2FibGUoXG4gICAgICBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBpbnB1dCksIHtcbiAgICAgICAgZWZmZWN0czogKCkgPT4gW1xuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTIsIF9iMiwgX2M7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSAoX2EyID0gdGhpcy5tYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRyYWdPcGVyYXRpb24uc3RhdHVzO1xuICAgICAgICAgICAgaWYgKChzdGF0dXMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXR1cy5pbml0aWFsaXppbmcpICYmIHRoaXMuaWQgPT09ICgoX2MgPSAoX2IyID0gdGhpcy5tYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmRyYWdPcGVyYXRpb24uc291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaWQpKSB7XG4gICAgICAgICAgICAgIHN0b3JlLmNsZWFyKHRoaXMubWFuYWdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgc3RvcmUuc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlcixcbiAgICAgICAgICAgICAgICB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHVudHJhY2tlZCgoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgaW5pdGlhbEdyb3VwOiB0aGlzLmdyb3VwXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGluZGV4OiBpbmRleDIsIGdyb3VwOiBncm91cDIsIG1hbmFnZXI6IF8gfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gX19wcml2YXRlR2V0KHRoaXMsIF9wcmV2aW91c0luZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzR3JvdXAgPSBfX3ByaXZhdGVHZXQodGhpcywgX3ByZXZpb3VzR3JvdXApO1xuICAgICAgICAgICAgaWYgKGluZGV4MiAhPT0gcHJldmlvdXNJbmRleCB8fCBncm91cDIgIT09IHByZXZpb3VzR3JvdXApIHtcbiAgICAgICAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9wcmV2aW91c0luZGV4LCBpbmRleDIpO1xuICAgICAgICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3ByZXZpb3VzR3JvdXAsIGdyb3VwMik7XG4gICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGZlZWRiYWNrLCBpc0RyYWdTb3VyY2UgfSA9IHRoaXMuZHJhZ2dhYmxlO1xuICAgICAgICAgICAgaWYgKGZlZWRiYWNrID09IFwibW92ZVwiICYmIGlzRHJhZ1NvdXJjZSkge1xuICAgICAgICAgICAgICB0aGlzLmRyb3BwYWJsZS5kaXNhYmxlZCA9ICF0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG1hbmFnZXI6IG1hbmFnZXIyIH0gPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgICBtYW5hZ2VyMiA9PSBudWxsID8gdm9pZCAwIDogbWFuYWdlcjIucmVnaXN0cnkucmVnaXN0ZXIocGx1Z2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLmlucHV0RWZmZWN0cygpXG4gICAgICAgIF0sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHNlbnNvcnNcbiAgICAgIH0pLFxuICAgICAgbWFuYWdlcixcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZWxlbWVudCwgaW5wdXQuZWxlbWVudCk7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wcmV2aW91c0luZGV4LCBpbmRleCk7XG4gICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcHJldmlvdXNHcm91cCwgZ3JvdXApO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgfVxuICBnZXQgaW5pdGlhbEluZGV4KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHN0b3JlLmdldCh0aGlzLm1hbmFnZXIsIHRoaXMuaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5pdGlhbEluZGV4KSAhPSBudWxsID8gX2IgOiB0aGlzLmluZGV4O1xuICB9XG4gIGdldCBpbml0aWFsR3JvdXAoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gc3RvcmUuZ2V0KHRoaXMubWFuYWdlciwgdGhpcy5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbml0aWFsR3JvdXApICE9IG51bGwgPyBfYiA6IHRoaXMuZ3JvdXA7XG4gIH1cbiAgYW5pbWF0ZSgpIHtcbiAgICB1bnRyYWNrZWQoKCkgPT4ge1xuICAgICAgY29uc3QgeyBtYW5hZ2VyLCB0cmFuc2l0aW9uIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5kcm9wcGFibGU7XG4gICAgICBpZiAoIW1hbmFnZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IHsgaWRsZSB9ID0gbWFuYWdlci5kcmFnT3BlcmF0aW9uLnN0YXR1cztcbiAgICAgIGlmICghc2hhcGUgfHwgIXRyYW5zaXRpb24gfHwgaWRsZSAmJiAhdHJhbnNpdGlvbi5pZGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hbmFnZXIucmVuZGVyZXIucmVuZGVyaW5nLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVkU2hhcGUgPSB0aGlzLnJlZnJlc2hTaGFwZSgpO1xuICAgICAgICBpZiAoIXVwZGF0ZWRTaGFwZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHtcbiAgICAgICAgICB4OiBzaGFwZS5ib3VuZGluZ1JlY3RhbmdsZS5sZWZ0IC0gdXBkYXRlZFNoYXBlLmJvdW5kaW5nUmVjdGFuZ2xlLmxlZnQsXG4gICAgICAgICAgeTogc2hhcGUuYm91bmRpbmdSZWN0YW5nbGUudG9wIC0gdXBkYXRlZFNoYXBlLmJvdW5kaW5nUmVjdGFuZ2xlLnRvcFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHRyYW5zbGF0ZSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZXMoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2xhdGUgPSBjb21wdXRlVHJhbnNsYXRlKGVsZW1lbnQsIHRyYW5zbGF0ZSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBmaW5hbFRyYW5zbGF0ZSA9IGNvbXB1dGVUcmFuc2xhdGUoZWxlbWVudCwgdHJhbnNsYXRlKTtcbiAgICAgICAgaWYgKGRlbHRhLnggfHwgZGVsdGEueSkge1xuICAgICAgICAgIGFuaW1hdGVUcmFuc2Zvcm0oe1xuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGtleWZyYW1lczoge1xuICAgICAgICAgICAgICB0cmFuc2xhdGU6IFtcbiAgICAgICAgICAgICAgICBgJHtjdXJyZW50VHJhbnNsYXRlLnggKyBkZWx0YS54fXB4ICR7Y3VycmVudFRyYW5zbGF0ZS55ICsgZGVsdGEueX1weCAke2N1cnJlbnRUcmFuc2xhdGUuen1gLFxuICAgICAgICAgICAgICAgIGAke2ZpbmFsVHJhbnNsYXRlLnh9cHggJHtmaW5hbFRyYW5zbGF0ZS55fXB4ICR7ZmluYWxUcmFuc2xhdGUuen1gXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiB0cmFuc2l0aW9uXG4gICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hbmFnZXIuZHJhZ09wZXJhdGlvbi5zdGF0dXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5kcm9wcGFibGUuc2hhcGUgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldCBtYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5tYW5hZ2VyO1xuICB9XG4gIHNldCBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmRyYWdnYWJsZS5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgIHRoaXMuZHJvcHBhYmxlLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIH0pO1xuICB9XG4gIHNldCBlbGVtZW50KGVsZW1lbnQpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBjb25zdCBwcmV2aW91c0VsZW1lbnQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2VsZW1lbnQpO1xuICAgICAgY29uc3QgZHJvcHBhYmxlRWxlbWVudCA9IHRoaXMuZHJvcHBhYmxlLmVsZW1lbnQ7XG4gICAgICBjb25zdCBkcmFnZ2FibGVFbGVtZW50ID0gdGhpcy5kcmFnZ2FibGUuZWxlbWVudDtcbiAgICAgIGlmICghZHJvcHBhYmxlRWxlbWVudCB8fCBkcm9wcGFibGVFbGVtZW50ID09PSBwcmV2aW91c0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kcm9wcGFibGUuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWRyYWdnYWJsZUVsZW1lbnQgfHwgZHJhZ2dhYmxlRWxlbWVudCA9PT0gcHJldmlvdXNFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9lbGVtZW50LCBlbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2VsZW1lbnQpO1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBQcm94aWVkRWxlbWVudHMuZ2V0KGVsZW1lbnQpKSAhPSBudWxsID8gX2EgOiBlbGVtZW50KSAhPSBudWxsID8gX2IgOiB0aGlzLmRyb3BwYWJsZS5lbGVtZW50O1xuICB9XG4gIHNldCB0YXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy5kcm9wcGFibGUuZWxlbWVudCA9IHRhcmdldDtcbiAgfVxuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmRyb3BwYWJsZS5lbGVtZW50O1xuICB9XG4gIHNldCBzb3VyY2Uoc291cmNlKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUuZWxlbWVudCA9IHNvdXJjZTtcbiAgfVxuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5lbGVtZW50O1xuICB9XG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUuZGlzYWJsZWQgJiYgdGhpcy5kcm9wcGFibGUuZGlzYWJsZWQ7XG4gIH1cbiAgc2V0IGZlZWRiYWNrKHZhbHVlKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUuZmVlZGJhY2sgPSB2YWx1ZTtcbiAgfVxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmRyb3BwYWJsZS5kaXNhYmxlZCA9IHZhbHVlO1xuICAgICAgdGhpcy5kcmFnZ2FibGUuZGlzYWJsZWQgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5kcm9wcGFibGUuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmRyYWdnYWJsZS5kYXRhID0gZGF0YTtcbiAgICB9KTtcbiAgfVxuICBzZXQgaGFuZGxlKGhhbmRsZSkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLmhhbmRsZSA9IGhhbmRsZTtcbiAgfVxuICBzZXQgaWQoaWQpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmRyb3BwYWJsZS5pZCA9IGlkO1xuICAgICAgdGhpcy5kcmFnZ2FibGUuaWQgPSBpZDtcbiAgICB9KTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcHBhYmxlLmlkO1xuICB9XG4gIHNldCBzZW5zb3JzKHZhbHVlKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUuc2Vuc29ycyA9IHZhbHVlO1xuICB9XG4gIHNldCBtb2RpZmllcnModmFsdWUpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5tb2RpZmllcnMgPSB2YWx1ZTtcbiAgfVxuICBzZXQgY29sbGlzaW9uUHJpb3JpdHkodmFsdWUpIHtcbiAgICB0aGlzLmRyb3BwYWJsZS5jb2xsaXNpb25Qcmlvcml0eSA9IHZhbHVlO1xuICB9XG4gIHNldCBjb2xsaXNpb25EZXRlY3Rvcih2YWx1ZSkge1xuICAgIHRoaXMuZHJvcHBhYmxlLmNvbGxpc2lvbkRldGVjdG9yID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdENvbGxpc2lvbkRldGVjdGlvbjtcbiAgfVxuICBzZXQgYWxpZ25tZW50KHZhbHVlKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUuYWxpZ25tZW50ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGFsaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUuYWxpZ25tZW50O1xuICB9XG4gIHNldCB0eXBlKHR5cGUpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmRyb3BwYWJsZS50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuZHJhZ2dhYmxlLnR5cGUgPSB0eXBlO1xuICAgIH0pO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS50eXBlO1xuICB9XG4gIHNldCBhY2NlcHQodmFsdWUpIHtcbiAgICB0aGlzLmRyb3BwYWJsZS5hY2NlcHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYWNjZXB0KCkge1xuICAgIHJldHVybiB0aGlzLmRyb3BwYWJsZS5hY2NlcHQ7XG4gIH1cbiAgZ2V0IGlzRHJvcFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kcm9wcGFibGUuaXNEcm9wVGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzb3J0YWJsZSBpdGVtIGlzIHRoZSBzb3VyY2Ugb2YgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICovXG4gIGdldCBpc0RyYWdTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLmlzRHJhZ1NvdXJjZTtcbiAgfVxuICAvKipcbiAgICogQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc29ydGFibGUgaXRlbSBpcyBiZWluZyBkcmFnZ2VkLlxuICAgKi9cbiAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLmlzRHJhZ2dpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNvcnRhYmxlIGl0ZW0gaXMgYmVpbmcgZHJvcHBlZC5cbiAgICovXG4gIGdldCBpc0Ryb3BwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5pc0Ryb3BwaW5nO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLnN0YXR1cztcbiAgfVxuICByZWZyZXNoU2hhcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcHBhYmxlLnJlZnJlc2hTaGFwZSgpO1xuICB9XG4gIGFjY2VwdHMoZHJhZ2dhYmxlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcHBhYmxlLmFjY2VwdHMoZHJhZ2dhYmxlKTtcbiAgfVxufTtcbl9pbml0ID0gX19kZWNvcmF0b3JTdGFydCgpO1xuX2luZGV4ID0gbmV3IFdlYWtNYXAoKTtcbl9wcmV2aW91c0dyb3VwID0gbmV3IFdlYWtNYXAoKTtcbl9wcmV2aW91c0luZGV4ID0gbmV3IFdlYWtNYXAoKTtcbl9ncm91cCA9IG5ldyBXZWFrTWFwKCk7XG5fZWxlbWVudCA9IG5ldyBXZWFrTWFwKCk7XG5fX2RlY29yYXRlRWxlbWVudChfaW5pdCwgNCwgXCJpbmRleFwiLCBfaW5kZXhfZGVjLCBTb3J0YWJsZTIsIF9pbmRleCk7XG5fX2RlY29yYXRlRWxlbWVudChfaW5pdCwgNCwgXCJncm91cFwiLCBfZ3JvdXBfZGVjLCBTb3J0YWJsZTIsIF9ncm91cCk7XG5fX2RlY29yYXRvck1ldGFkYXRhKF9pbml0LCBTb3J0YWJsZTIpO1xudmFyIFNvcnRhYmxlRHJhZ2dhYmxlID0gY2xhc3MgZXh0ZW5kcyBEcmFnZ2FibGUge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgbWFuYWdlciwgc29ydGFibGUpIHtcbiAgICBzdXBlcihpbnB1dCwgbWFuYWdlcik7XG4gICAgdGhpcy5zb3J0YWJsZSA9IHNvcnRhYmxlO1xuICB9XG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0YWJsZS5pbmRleDtcbiAgfVxufTtcbnZhciBTb3J0YWJsZURyb3BwYWJsZSA9IGNsYXNzIGV4dGVuZHMgRHJvcHBhYmxlIHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIG1hbmFnZXIsIHNvcnRhYmxlKSB7XG4gICAgc3VwZXIoaW5wdXQsIG1hbmFnZXIpO1xuICAgIHRoaXMuc29ydGFibGUgPSBzb3J0YWJsZTtcbiAgfVxufTtcblxuZXhwb3J0IHsgT3B0aW1pc3RpY1NvcnRpbmdQbHVnaW4sIFNvcnRhYmxlMiBhcyBTb3J0YWJsZSwgU29ydGFibGVLZXlib2FyZFBsdWdpbiwgZGVmYXVsdFNvcnRhYmxlVHJhbnNpdGlvbiwgaXNTb3J0YWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydGFibGUuanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0YWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/sortable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/utilities.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/utilities.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMRectangle: () => (/* binding */ DOMRectangle),\n/* harmony export */   Listeners: () => (/* binding */ Listeners),\n/* harmony export */   PositionObserver: () => (/* binding */ FrameObserver),\n/* harmony export */   ProxiedElements: () => (/* binding */ ProxiedElements),\n/* harmony export */   ResizeNotifier: () => (/* binding */ ResizeNotifier),\n/* harmony export */   Scheduler: () => (/* binding */ Scheduler),\n/* harmony export */   ScrollDirection: () => (/* binding */ ScrollDirection),\n/* harmony export */   Styles: () => (/* binding */ Styles),\n/* harmony export */   animateTransform: () => (/* binding */ animateTransform),\n/* harmony export */   canScroll: () => (/* binding */ canScroll),\n/* harmony export */   canUseDOM: () => (/* binding */ canUseDOM),\n/* harmony export */   cloneElement: () => (/* binding */ cloneElement),\n/* harmony export */   computeTranslate: () => (/* binding */ computeTranslate),\n/* harmony export */   detectScrollIntent: () => (/* binding */ detectScrollIntent),\n/* harmony export */   generateUniqueId: () => (/* binding */ generateUniqueId),\n/* harmony export */   getBoundingRectangle: () => (/* binding */ getBoundingRectangle),\n/* harmony export */   getComputedStyles: () => (/* binding */ getComputedStyles),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getElementFromPoint: () => (/* binding */ getElementFromPoint),\n/* harmony export */   getFinalKeyframe: () => (/* binding */ getFinalKeyframe),\n/* harmony export */   getFirstScrollableAncestor: () => (/* binding */ getFirstScrollableAncestor),\n/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),\n/* harmony export */   getFrameTransform: () => (/* binding */ getFrameTransform),\n/* harmony export */   getScrollableAncestors: () => (/* binding */ getScrollableAncestors),\n/* harmony export */   getViewportBoundingRectangle: () => (/* binding */ getViewportBoundingRectangle),\n/* harmony export */   getVisibleBoundingRectangle: () => (/* binding */ getVisibleBoundingRectangle),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   hidePopover: () => (/* binding */ hidePopover),\n/* harmony export */   inverseTransform: () => (/* binding */ inverseTransform),\n/* harmony export */   isDocumentScrollingElement: () => (/* binding */ isDocumentScrollingElement),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isKeyboardEvent: () => (/* binding */ isKeyboardEvent),\n/* harmony export */   isKeyframeEffect: () => (/* binding */ isKeyframeEffect),\n/* harmony export */   isPointerEvent: () => (/* binding */ isPointerEvent),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTextInput: () => (/* binding */ isTextInput),\n/* harmony export */   parseTransform: () => (/* binding */ parseTransform),\n/* harmony export */   parseTranslate: () => (/* binding */ parseTranslate),\n/* harmony export */   scheduler: () => (/* binding */ scheduler),\n/* harmony export */   scrollIntoViewIfNeeded: () => (/* binding */ scrollIntoViewIfNeeded),\n/* harmony export */   showPopover: () => (/* binding */ showPopover),\n/* harmony export */   supportsPopover: () => (/* binding */ supportsPopover),\n/* harmony export */   supportsStyle: () => (/* binding */ supportsStyle),\n/* harmony export */   supportsViewTransition: () => (/* binding */ supportsViewTransition),\n/* harmony export */   timeout: () => (/* binding */ timeout)\n/* harmony export */ });\n/* harmony import */ var _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dnd-kit/geometry */ \"(ssr)/./node_modules/.pnpm/@dnd-kit+geometry@0.1.21/node_modules/@dnd-kit/geometry/dist/index.mjs\");\n\n\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/utilities/type-guards/isKeyframeEffect.ts\nfunction isKeyframeEffect(effect) {\n  if (!effect) return false;\n  if (effect instanceof KeyframeEffect) return true;\n  return \"getKeyframes\" in effect && typeof effect.getKeyframes === \"function\";\n}\n\n// src/utilities/animations/getFinalKeyframe.ts\nfunction getFinalKeyframe(element, match) {\n  const animations2 = element.getAnimations();\n  if (animations2.length > 0) {\n    for (const animation of animations2) {\n      if (animation.playState !== \"running\") continue;\n      const { effect } = animation;\n      const keyframes = isKeyframeEffect(effect) ? effect.getKeyframes() : [];\n      const matchedKeyframes = keyframes.filter(match);\n      if (matchedKeyframes.length > 0) {\n        return [matchedKeyframes[matchedKeyframes.length - 1], animation];\n      }\n    }\n  }\n  return null;\n}\n\n// src/utilities/bounding-rectangle/getBoundingRectangle.ts\nfunction getBoundingRectangle(element) {\n  const { width, height, top, left, bottom, right } = element.getBoundingClientRect();\n  return { width, height, top, left, bottom, right };\n}\n\n// src/utilities/execution-context/canUseDOM.ts\nvar canUseDOM = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\n\n// src/utilities/type-guards/isWindow.ts\nfunction isWindow(element) {\n  const elementString = Object.prototype.toString.call(element);\n  return elementString === \"[object Window]\" || // In Electron context the Window object serializes to [object global]\n  elementString === \"[object global]\";\n}\n\n// src/utilities/type-guards/isNode.ts\nfunction isNode(node) {\n  return \"nodeType\" in node;\n}\n\n// src/utilities/execution-context/getWindow.ts\nfunction getWindow(target) {\n  var _a, _b, _c;\n  if (!target) {\n    return window;\n  }\n  if (isWindow(target)) {\n    return target;\n  }\n  if (!isNode(target)) {\n    return window;\n  }\n  if (\"defaultView\" in target) {\n    return (_a = target.defaultView) != null ? _a : window;\n  }\n  return (_c = (_b = target.ownerDocument) == null ? void 0 : _b.defaultView) != null ? _c : window;\n}\n\n// src/utilities/type-guards/isDocument.ts\nfunction isDocument(node) {\n  const { Document } = getWindow(node);\n  return node instanceof Document || \"nodeType\" in node && node.nodeType === Node.DOCUMENT_NODE;\n}\n\n// src/utilities/type-guards/isHTMLElement.ts\nfunction isHTMLElement(node) {\n  if (!node || isWindow(node)) return false;\n  return node instanceof getWindow(node).HTMLElement || \"namespaceURI\" in node && typeof node.namespaceURI === \"string\" && node.namespaceURI.endsWith(\"html\");\n}\n\n// src/utilities/type-guards/isSVGElement.ts\nfunction isSVGElement(node) {\n  return node instanceof getWindow(node).SVGElement || \"namespaceURI\" in node && typeof node.namespaceURI === \"string\" && node.namespaceURI.endsWith(\"svg\");\n}\n\n// src/utilities/execution-context/getDocument.ts\nfunction getDocument(target) {\n  if (!target) {\n    return document;\n  }\n  if (isWindow(target)) {\n    return target.document;\n  }\n  if (!isNode(target)) {\n    return document;\n  }\n  if (isDocument(target)) {\n    return target;\n  }\n  if (isHTMLElement(target) || isSVGElement(target)) {\n    return target.ownerDocument;\n  }\n  return document;\n}\n\n// src/utilities/bounding-rectangle/getViewportBoundingRectangle.ts\nfunction getViewportBoundingRectangle(element) {\n  const { documentElement } = getDocument(element);\n  const width = documentElement.clientWidth;\n  const height = documentElement.clientHeight;\n  return {\n    top: 0,\n    left: 0,\n    right: width,\n    bottom: height,\n    width,\n    height\n  };\n}\n\n// src/utilities/bounding-rectangle/isOverflowVisible.ts\nfunction isOverflowVisible(element, style) {\n  if (isDetailsElement(element) && element.open === false) {\n    return false;\n  }\n  const { overflow, overflowX, overflowY } = getComputedStyle(element);\n  return overflow === \"visible\" && overflowX === \"visible\" && overflowY === \"visible\";\n}\nfunction isDetailsElement(element) {\n  return element.tagName === \"DETAILS\";\n}\n\n// src/utilities/bounding-rectangle/getVisibleBoundingRectangle.ts\nfunction getVisibleBoundingRectangle(element, boundingClientRect = element.getBoundingClientRect(), margin = 0) {\n  var _a;\n  let rect = boundingClientRect;\n  const { ownerDocument } = element;\n  const ownerWindow = (_a = ownerDocument.defaultView) != null ? _a : window;\n  let ancestor = element.parentElement;\n  while (ancestor && ancestor !== ownerDocument.documentElement) {\n    if (!isOverflowVisible(ancestor)) {\n      const ancestorRect = ancestor.getBoundingClientRect();\n      const marginTop = margin * (ancestorRect.bottom - ancestorRect.top);\n      const marginRight = margin * (ancestorRect.right - ancestorRect.left);\n      const marginBottom = margin * (ancestorRect.bottom - ancestorRect.top);\n      const marginLeft = margin * (ancestorRect.right - ancestorRect.left);\n      rect = {\n        top: Math.max(rect.top, ancestorRect.top - marginTop),\n        right: Math.min(rect.right, ancestorRect.right + marginRight),\n        bottom: Math.min(rect.bottom, ancestorRect.bottom + marginBottom),\n        left: Math.max(rect.left, ancestorRect.left - marginLeft),\n        width: 0,\n        // Will be calculated next\n        height: 0\n        // Will be calculated next\n      };\n      rect.width = rect.right - rect.left;\n      rect.height = rect.bottom - rect.top;\n    }\n    ancestor = ancestor.parentElement;\n  }\n  const viewportWidth = ownerWindow.innerWidth;\n  const viewportHeight = ownerWindow.innerHeight;\n  const viewportMarginY = margin * viewportHeight;\n  const viewportMarginX = margin * viewportWidth;\n  rect = {\n    top: Math.max(rect.top, 0 - viewportMarginY),\n    right: Math.min(rect.right, viewportWidth + viewportMarginX),\n    bottom: Math.min(rect.bottom, viewportHeight + viewportMarginY),\n    left: Math.max(rect.left, 0 - viewportMarginX),\n    width: 0,\n    // Will be calculated next\n    height: 0\n    // Will be calculated next\n  };\n  rect.width = rect.right - rect.left;\n  rect.height = rect.bottom - rect.top;\n  if (rect.width < 0) {\n    rect.width = 0;\n  }\n  if (rect.height < 0) {\n    rect.height = 0;\n  }\n  return rect;\n}\n\n// src/utilities/execution-context/isSafari.ts\nfunction isSafari() {\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n\n// src/utilities/element/cloneElement.ts\nfunction cloneElement(element) {\n  const selector = \"input, textarea, select, canvas, [contenteditable]\";\n  const clonedElement = element.cloneNode(true);\n  const fields = Array.from(element.querySelectorAll(selector));\n  const clonedFields = Array.from(clonedElement.querySelectorAll(selector));\n  clonedFields.forEach((field, index) => {\n    const originalField = fields[index];\n    if (isField(field) && isField(originalField)) {\n      if (field.type !== \"file\") {\n        field.value = originalField.value;\n      }\n      if (field.type === \"radio\" && field.name) {\n        field.name = `Cloned__${field.name}`;\n      }\n    }\n    if (isCanvasElement(field) && isCanvasElement(originalField) && originalField.width > 0 && originalField.height > 0) {\n      const destCtx = field.getContext(\"2d\");\n      destCtx == null ? void 0 : destCtx.drawImage(originalField, 0, 0);\n    }\n  });\n  return clonedElement;\n}\nfunction isField(element) {\n  return \"value\" in element;\n}\nfunction isCanvasElement(element) {\n  return element.tagName === \"CANVAS\";\n}\n\n// src/utilities/element/getElementFromPoint.ts\nfunction getElementFromPoint(document2, { x, y }) {\n  const element = document2.elementFromPoint(x, y);\n  if (isIFrameElement(element)) {\n    const { contentDocument } = element;\n    if (contentDocument) {\n      const { left, top } = element.getBoundingClientRect();\n      return getElementFromPoint(contentDocument, {\n        x: x - left,\n        y: y - top\n      });\n    }\n  }\n  return element;\n}\nfunction isIFrameElement(element) {\n  return (element == null ? void 0 : element.tagName) === \"IFRAME\";\n}\n\n// src/utilities/element/proxiedElements.ts\nvar ProxiedElements = /* @__PURE__ */ new WeakMap();\n\n// src/utilities/event-listeners/Listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.entries = /* @__PURE__ */ new Set();\n    this.clear = () => {\n      for (const entry of this.entries) {\n        const [target, { type, listener, options }] = entry;\n        target.removeEventListener(type, listener, options);\n      }\n      this.entries.clear();\n    };\n  }\n  bind(target, input) {\n    const listeners = Array.isArray(input) ? input : [input];\n    const entries = [];\n    for (const descriptor of listeners) {\n      const { type, listener, options } = descriptor;\n      const entry = [target, descriptor];\n      target.addEventListener(type, listener, options);\n      this.entries.add(entry);\n      entries.push(entry);\n    }\n    return function cleanup() {\n      for (const [target2, { type, listener, options }] of entries) {\n        target2.removeEventListener(type, listener, options);\n      }\n    };\n  }\n};\n\n// src/utilities/frame/getFrameElement.ts\nfunction getFrameElement(el) {\n  const refWindow = el == null ? void 0 : el.ownerDocument.defaultView;\n  if (refWindow && refWindow.self !== refWindow.parent) {\n    return refWindow.frameElement;\n  }\n}\n\n// src/utilities/frame/getFrameElements.ts\nfunction getFrameElements(el) {\n  const frames = /* @__PURE__ */ new Set();\n  let frame = getFrameElement(el);\n  while (frame) {\n    frames.add(frame);\n    frame = getFrameElement(frame);\n  }\n  return frames;\n}\n\n// src/utilities/scheduling/timeout.ts\nfunction timeout(callback, duration) {\n  const id = setTimeout(callback, duration);\n  return () => clearTimeout(id);\n}\n\n// src/utilities/scheduling/throttle.ts\nfunction throttle(func, limit) {\n  const time = () => performance.now();\n  let cancel;\n  let lastRan;\n  return function(...args) {\n    const context = this;\n    if (!lastRan) {\n      func.apply(context, args);\n      lastRan = time();\n    } else {\n      cancel == null ? void 0 : cancel();\n      cancel = timeout(\n        () => {\n          func.apply(context, args);\n          lastRan = time();\n        },\n        limit - (time() - lastRan)\n      );\n    }\n  };\n}\n\n// src/utilities/bounding-rectangle/isRectEqual.ts\nfunction isRectEqual(a, b) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  return a.top == b.top && a.left == b.left && a.right == b.right && a.bottom == b.bottom;\n}\n\n// src/utilities/bounding-rectangle/isVisible.ts\nfunction isVisible(element, boundingClientRect = element.getBoundingClientRect()) {\n  const { width, height } = getVisibleBoundingRectangle(\n    element,\n    boundingClientRect\n  );\n  return width > 0 && height > 0;\n}\n\n// src/utilities/observers/ResizeNotifier.ts\nvar Observer = canUseDOM ? ResizeObserver : class MockResizeObserver {\n  observe() {\n  }\n  unobserve() {\n  }\n  disconnect() {\n  }\n};\nvar _initialized;\nvar ResizeNotifier = class extends Observer {\n  constructor(callback) {\n    super((entries) => {\n      if (!__privateGet(this, _initialized)) {\n        __privateSet(this, _initialized, true);\n        return;\n      }\n      callback(entries, this);\n    });\n    __privateAdd(this, _initialized, false);\n  }\n};\n_initialized = new WeakMap();\n\n// src/utilities/observers/PositionObserver.ts\nvar threshold = Array.from({ length: 100 }, (_, index) => index / 100);\nvar THROTTLE_INTERVAL = 75;\nvar _visible, _previousBoundingClientRect, _resizeObserver, _positionObserver, _visibilityObserver, _debug, _disconnected, _observePosition, _PositionObserver_instances, notify_fn, updateDebug_fn;\nvar PositionObserver = class {\n  constructor(element, callback, options = {\n    debug: false,\n    skipInitial: false\n  }) {\n    this.element = element;\n    this.callback = callback;\n    __privateAdd(this, _PositionObserver_instances);\n    this.disconnect = () => {\n      var _a, _b, _c;\n      __privateSet(this, _disconnected, true);\n      (_a = __privateGet(this, _resizeObserver)) == null ? void 0 : _a.disconnect();\n      (_b = __privateGet(this, _positionObserver)) == null ? void 0 : _b.disconnect();\n      __privateGet(this, _visibilityObserver).disconnect();\n      (_c = __privateGet(this, _debug)) == null ? void 0 : _c.remove();\n    };\n    __privateAdd(this, _visible, true);\n    __privateAdd(this, _previousBoundingClientRect);\n    __privateAdd(this, _resizeObserver);\n    __privateAdd(this, _positionObserver);\n    __privateAdd(this, _visibilityObserver);\n    __privateAdd(this, _debug);\n    __privateAdd(this, _disconnected, false);\n    __privateAdd(this, _observePosition, throttle(() => {\n      var _a, _b, _c;\n      const { element } = this;\n      (_a = __privateGet(this, _positionObserver)) == null ? void 0 : _a.disconnect();\n      if (__privateGet(this, _disconnected) || !__privateGet(this, _visible) || !element.isConnected) {\n        return;\n      }\n      const root = (_b = element.ownerDocument) != null ? _b : document;\n      const { innerHeight, innerWidth } = (_c = root.defaultView) != null ? _c : window;\n      const clientRect = element.getBoundingClientRect();\n      const visibleRect = getVisibleBoundingRectangle(element, clientRect);\n      const { top, left, bottom, right } = visibleRect;\n      const insetTop = -Math.floor(top);\n      const insetLeft = -Math.floor(left);\n      const insetRight = -Math.floor(innerWidth - right);\n      const insetBottom = -Math.floor(innerHeight - bottom);\n      const rootMargin = `${insetTop}px ${insetRight}px ${insetBottom}px ${insetLeft}px`;\n      this.boundingClientRect = clientRect;\n      __privateSet(this, _positionObserver, new IntersectionObserver(\n        (entries) => {\n          const [entry] = entries;\n          const { intersectionRect } = entry;\n          const intersectionRatio = entry.intersectionRatio !== 1 ? entry.intersectionRatio : _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.intersectionRatio(\n            intersectionRect,\n            getVisibleBoundingRectangle(element)\n          );\n          if (intersectionRatio !== 1) {\n            __privateGet(this, _observePosition).call(this);\n          }\n        },\n        {\n          threshold,\n          rootMargin,\n          root\n        }\n      ));\n      __privateGet(this, _positionObserver).observe(element);\n      __privateMethod(this, _PositionObserver_instances, notify_fn).call(this);\n    }, THROTTLE_INTERVAL));\n    this.boundingClientRect = element.getBoundingClientRect();\n    __privateSet(this, _visible, isVisible(element, this.boundingClientRect));\n    let initial = true;\n    this.callback = (boundingClientRect) => {\n      if (initial) {\n        initial = false;\n        if (options.skipInitial) return;\n      }\n      callback(boundingClientRect);\n    };\n    const root = element.ownerDocument;\n    if (options == null ? void 0 : options.debug) {\n      __privateSet(this, _debug, document.createElement(\"div\"));\n      __privateGet(this, _debug).style.background = \"rgba(0,0,0,0.15)\";\n      __privateGet(this, _debug).style.position = \"fixed\";\n      __privateGet(this, _debug).style.pointerEvents = \"none\";\n      root.body.appendChild(__privateGet(this, _debug));\n    }\n    __privateSet(this, _visibilityObserver, new IntersectionObserver(\n      (entries) => {\n        var _a, _b;\n        const entry = entries[entries.length - 1];\n        const { boundingClientRect, isIntersecting: visible } = entry;\n        const { width, height } = boundingClientRect;\n        const previousVisible = __privateGet(this, _visible);\n        __privateSet(this, _visible, visible);\n        if (!width && !height) return;\n        if (previousVisible && !visible) {\n          (_a = __privateGet(this, _positionObserver)) == null ? void 0 : _a.disconnect();\n          this.callback(null);\n          (_b = __privateGet(this, _resizeObserver)) == null ? void 0 : _b.disconnect();\n          __privateSet(this, _resizeObserver, void 0);\n          if (__privateGet(this, _debug)) __privateGet(this, _debug).style.visibility = \"hidden\";\n        } else {\n          __privateGet(this, _observePosition).call(this);\n        }\n        if (visible && !__privateGet(this, _resizeObserver)) {\n          __privateSet(this, _resizeObserver, new ResizeNotifier(__privateGet(this, _observePosition)));\n          __privateGet(this, _resizeObserver).observe(element);\n        }\n      },\n      {\n        threshold,\n        root\n      }\n    ));\n    if (__privateGet(this, _visible) && !options.skipInitial) {\n      this.callback(this.boundingClientRect);\n    }\n    __privateGet(this, _visibilityObserver).observe(element);\n  }\n};\n_visible = new WeakMap();\n_previousBoundingClientRect = new WeakMap();\n_resizeObserver = new WeakMap();\n_positionObserver = new WeakMap();\n_visibilityObserver = new WeakMap();\n_debug = new WeakMap();\n_disconnected = new WeakMap();\n_observePosition = new WeakMap();\n_PositionObserver_instances = new WeakSet();\nnotify_fn = function() {\n  if (__privateGet(this, _disconnected)) return;\n  __privateMethod(this, _PositionObserver_instances, updateDebug_fn).call(this);\n  if (isRectEqual(this.boundingClientRect, __privateGet(this, _previousBoundingClientRect)))\n    return;\n  this.callback(this.boundingClientRect);\n  __privateSet(this, _previousBoundingClientRect, this.boundingClientRect);\n};\nupdateDebug_fn = function() {\n  if (__privateGet(this, _debug)) {\n    const { top, left, width, height } = getVisibleBoundingRectangle(\n      this.element\n    );\n    __privateGet(this, _debug).style.overflow = \"hidden\";\n    __privateGet(this, _debug).style.visibility = \"visible\";\n    __privateGet(this, _debug).style.top = `${Math.floor(top)}px`;\n    __privateGet(this, _debug).style.left = `${Math.floor(left)}px`;\n    __privateGet(this, _debug).style.width = `${Math.floor(width)}px`;\n    __privateGet(this, _debug).style.height = `${Math.floor(height)}px`;\n  }\n};\n\n// src/utilities/observers/FrameObserver.ts\nvar framePositionObservers = /* @__PURE__ */ new WeakMap();\nvar scrollListeners = /* @__PURE__ */ new WeakMap();\nfunction addFrameListener(frame, callback) {\n  let cached = framePositionObservers.get(frame);\n  if (!cached) {\n    const observer = new PositionObserver(\n      frame,\n      (boundingClientRect) => {\n        const cached2 = framePositionObservers.get(frame);\n        if (!cached2) return;\n        cached2.callbacks.forEach((callback2) => callback2(boundingClientRect));\n      },\n      { skipInitial: true }\n    );\n    cached = { disconnect: observer.disconnect, callbacks: /* @__PURE__ */ new Set() };\n  }\n  cached.callbacks.add(callback);\n  framePositionObservers.set(frame, cached);\n  return () => {\n    cached.callbacks.delete(callback);\n    if (cached.callbacks.size === 0) {\n      framePositionObservers.delete(frame);\n      cached.disconnect();\n    }\n  };\n}\nfunction observeParentFrames(frames, callback) {\n  const cleanup = /* @__PURE__ */ new Set();\n  for (const frame of frames) {\n    const remove = addFrameListener(frame, callback);\n    cleanup.add(remove);\n  }\n  return () => cleanup.forEach((remove) => remove());\n}\nfunction addScrollListener(element, callback) {\n  var _a;\n  const doc = element.ownerDocument;\n  if (!scrollListeners.has(doc)) {\n    const controller = new AbortController();\n    const listeners2 = /* @__PURE__ */ new Set();\n    document.addEventListener(\n      \"scroll\",\n      (event) => listeners2.forEach((listener) => listener(event)),\n      {\n        capture: true,\n        passive: true,\n        signal: controller.signal\n      }\n    );\n    scrollListeners.set(doc, { disconnect: () => controller.abort(), listeners: listeners2 });\n  }\n  const { listeners, disconnect } = (_a = scrollListeners.get(doc)) != null ? _a : {};\n  if (!listeners || !disconnect) return () => {\n  };\n  listeners.add(callback);\n  return () => {\n    listeners.delete(callback);\n    if (listeners.size === 0) {\n      disconnect();\n      scrollListeners.delete(doc);\n    }\n  };\n}\nvar _elementObserver, _disconnected2, _frames, _handleScroll;\nvar FrameObserver = class {\n  constructor(element, callback, options) {\n    this.callback = callback;\n    __privateAdd(this, _elementObserver);\n    __privateAdd(this, _disconnected2, false);\n    __privateAdd(this, _frames);\n    __privateAdd(this, _handleScroll, throttle((event) => {\n      if (__privateGet(this, _disconnected2)) return;\n      if (!event.target) return;\n      if (\"contains\" in event.target && typeof event.target.contains === \"function\") {\n        for (const frame of __privateGet(this, _frames)) {\n          if (event.target.contains(frame)) {\n            this.callback(__privateGet(this, _elementObserver).boundingClientRect);\n            break;\n          }\n        }\n      }\n    }, THROTTLE_INTERVAL));\n    const frames = getFrameElements(element);\n    const unobserveParentFrames = observeParentFrames(frames, callback);\n    const removeScrollListener = addScrollListener(element, __privateGet(this, _handleScroll));\n    __privateSet(this, _frames, frames);\n    __privateSet(this, _elementObserver, new PositionObserver(element, callback, options));\n    this.disconnect = () => {\n      if (__privateGet(this, _disconnected2)) return;\n      __privateSet(this, _disconnected2, true);\n      unobserveParentFrames();\n      removeScrollListener();\n      __privateGet(this, _elementObserver).disconnect();\n    };\n  }\n};\n_elementObserver = new WeakMap();\n_disconnected2 = new WeakMap();\n_frames = new WeakMap();\n_handleScroll = new WeakMap();\n\n// src/utilities/popover/supportsPopover.ts\nfunction supportsPopover(element) {\n  return \"showPopover\" in element && \"hidePopover\" in element && typeof element.showPopover === \"function\" && typeof element.hidePopover === \"function\";\n}\n\n// src/utilities/popover/showPopover.ts\nfunction showPopover(element) {\n  try {\n    if (supportsPopover(element) && element.isConnected && element.hasAttribute(\"popover\") && // This selector can throw an error in browsers that don't support it\n    !element.matches(\":popover-open\")) {\n      element.showPopover();\n    }\n  } catch (error) {\n  }\n}\n\n// src/utilities/popover/hidePopover.ts\nfunction hidePopover(element) {\n  try {\n    if (supportsPopover(element) && element.isConnected && element.hasAttribute(\"popover\") && // This selector can throw an error in browsers that don't support it\n    element.matches(\":popover-open\")) {\n      element.hidePopover();\n    }\n  } catch (error) {\n  }\n}\n\n// src/utilities/scroll/documentScrollingElement.ts\nfunction isDocumentScrollingElement(element) {\n  if (!canUseDOM || !element) {\n    return false;\n  }\n  return element === getDocument(element).scrollingElement;\n}\n\n// src/utilities/scroll/getScrollPosition.ts\nfunction getScrollPosition(scrollableElement) {\n  const window2 = getWindow(scrollableElement);\n  const rect = isDocumentScrollingElement(scrollableElement) ? getViewportBoundingRectangle(scrollableElement) : getBoundingRectangle(scrollableElement);\n  const dimensions = isDocumentScrollingElement(scrollableElement) ? {\n    height: window2.innerHeight,\n    width: window2.innerWidth\n  } : {\n    height: scrollableElement.clientHeight,\n    width: scrollableElement.clientWidth\n  };\n  const position = {\n    current: {\n      x: scrollableElement.scrollLeft,\n      y: scrollableElement.scrollTop\n    },\n    max: {\n      x: scrollableElement.scrollWidth - dimensions.width,\n      y: scrollableElement.scrollHeight - dimensions.height\n    }\n  };\n  const isTop = position.current.y <= 0;\n  const isLeft = position.current.x <= 0;\n  const isBottom = position.current.y >= position.max.y;\n  const isRight = position.current.x >= position.max.x;\n  return {\n    rect,\n    position,\n    isTop,\n    isLeft,\n    isBottom,\n    isRight\n  };\n}\n\n// src/utilities/scroll/canScroll.ts\nfunction canScroll(scrollableElement, by) {\n  const { isTop, isBottom, isLeft, isRight, position } = getScrollPosition(scrollableElement);\n  const { x, y } = by != null ? by : { x: 0, y: 0 };\n  const top = !isTop && position.current.y + y > 0;\n  const bottom = !isBottom && position.current.y + y < position.max.y;\n  const left = !isLeft && position.current.x + x > 0;\n  const right = !isRight && position.current.x + x < position.max.x;\n  return {\n    top,\n    bottom,\n    left,\n    right,\n    x: left || right,\n    y: top || bottom\n  };\n}\n\n// src/utilities/scheduling/scheduler.ts\nvar Scheduler = class {\n  constructor(scheduler4) {\n    this.scheduler = scheduler4;\n    this.pending = false;\n    this.tasks = /* @__PURE__ */ new Set();\n    this.resolvers = /* @__PURE__ */ new Set();\n    this.flush = () => {\n      const { tasks, resolvers } = this;\n      this.pending = false;\n      this.tasks = /* @__PURE__ */ new Set();\n      this.resolvers = /* @__PURE__ */ new Set();\n      for (const task of tasks) {\n        task();\n      }\n      for (const resolve of resolvers) {\n        resolve();\n      }\n    };\n  }\n  schedule(task) {\n    this.tasks.add(task);\n    if (!this.pending) {\n      this.pending = true;\n      this.scheduler(this.flush);\n    }\n    return new Promise((resolve) => this.resolvers.add(resolve));\n  }\n};\nvar scheduler = new Scheduler((callback) => {\n  if (typeof requestAnimationFrame === \"function\") {\n    requestAnimationFrame(callback);\n  } else {\n    callback();\n  }\n});\n\n// src/utilities/styles/getComputedStyles.ts\nvar scheduler2 = new Scheduler((callback) => setTimeout(callback, 50));\nvar cachedStyles = /* @__PURE__ */ new Map();\nvar clear = cachedStyles.clear.bind(cachedStyles);\nfunction getComputedStyles(element, cached = false) {\n  if (!cached) return computeStyles(element);\n  let styles = cachedStyles.get(element);\n  if (styles) return styles;\n  styles = computeStyles(element);\n  cachedStyles.set(element, styles);\n  scheduler2.schedule(clear);\n  return styles;\n}\nfunction computeStyles(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\n// src/utilities/scroll/isFixed.ts\nfunction isFixed(node, computedStyle = getComputedStyles(node, true)) {\n  return computedStyle.position === \"fixed\" || computedStyle.position === \"sticky\";\n}\n\n// src/utilities/scroll/isScrollable.ts\nfunction isScrollable(element, computedStyle = getComputedStyles(element, true)) {\n  const overflowRegex = /(auto|scroll|overlay)/;\n  const properties = [\"overflow\", \"overflowX\", \"overflowY\"];\n  return properties.some((property) => {\n    const value = computedStyle[property];\n    return typeof value === \"string\" ? overflowRegex.test(value) : false;\n  });\n}\n\n// src/utilities/scroll/getScrollableAncestors.ts\nvar defaultOptions = {\n  excludeElement: true\n};\nfunction getScrollableAncestors(element, options = defaultOptions) {\n  const { limit, excludeElement } = options;\n  const scrollParents = /* @__PURE__ */ new Set();\n  function findScrollableAncestors(node) {\n    if (limit != null && scrollParents.size >= limit) {\n      return scrollParents;\n    }\n    if (!node) {\n      return scrollParents;\n    }\n    if (isDocument(node) && node.scrollingElement != null && !scrollParents.has(node.scrollingElement)) {\n      scrollParents.add(node.scrollingElement);\n      return scrollParents;\n    }\n    if (!isHTMLElement(node)) {\n      if (isSVGElement(node)) {\n        return findScrollableAncestors(node.parentElement);\n      }\n      return scrollParents;\n    }\n    if (scrollParents.has(node)) {\n      return scrollParents;\n    }\n    const computedStyle = getComputedStyles(node, true);\n    if (excludeElement && node === element) ; else if (isScrollable(node, computedStyle)) {\n      scrollParents.add(node);\n    }\n    if (isFixed(node, computedStyle)) {\n      const { scrollingElement } = node.ownerDocument;\n      if (scrollingElement) scrollParents.add(scrollingElement);\n      return scrollParents;\n    }\n    return findScrollableAncestors(node.parentNode);\n  }\n  if (!element) {\n    return scrollParents;\n  }\n  return findScrollableAncestors(element);\n}\nfunction getFirstScrollableAncestor(node) {\n  const [firstScrollableAncestor] = getScrollableAncestors(node, { limit: 1 });\n  return firstScrollableAncestor != null ? firstScrollableAncestor : null;\n}\n\n// src/utilities/frame/getFrameTransform.ts\nfunction getFrameTransform(el, boundary = window.frameElement) {\n  const transform = {\n    x: 0,\n    y: 0,\n    scaleX: 1,\n    scaleY: 1\n  };\n  if (!el) return transform;\n  let frame = getFrameElement(el);\n  while (frame) {\n    if (frame === boundary) {\n      return transform;\n    }\n    const rect = getBoundingRectangle(frame);\n    const { x: scaleX, y: scaleY } = getScale(frame, rect);\n    transform.x = transform.x + rect.left;\n    transform.y = transform.y + rect.top;\n    transform.scaleX = transform.scaleX * scaleX;\n    transform.scaleY = transform.scaleY * scaleY;\n    frame = getFrameElement(frame);\n  }\n  return transform;\n}\nfunction getScale(element, boundingRectangle = getBoundingRectangle(element)) {\n  const width = Math.round(boundingRectangle.width);\n  const height = Math.round(boundingRectangle.height);\n  if (isHTMLElement(element)) {\n    return {\n      x: width / element.offsetWidth,\n      y: height / element.offsetHeight\n    };\n  }\n  const styles = getComputedStyles(element, true);\n  return {\n    x: (parseFloat(styles.width) || width) / width,\n    y: (parseFloat(styles.height) || height) / height\n  };\n}\n\n// src/utilities/transform/parseScale.ts\nfunction parseScale(scale) {\n  if (scale === \"none\") {\n    return null;\n  }\n  const values = scale.split(\" \");\n  const x = parseFloat(values[0]);\n  const y = parseFloat(values[1]);\n  if (isNaN(x) && isNaN(y)) {\n    return null;\n  }\n  return {\n    x: isNaN(x) ? y : x,\n    y: isNaN(y) ? x : y\n  };\n}\n\n// src/utilities/transform/parseTranslate.ts\nfunction parseTranslate(translate) {\n  if (translate === \"none\") {\n    return null;\n  }\n  const [x, y, z = \"0\"] = translate.split(\" \");\n  const output = { x: parseFloat(x), y: parseFloat(y), z: parseInt(z, 10) };\n  if (isNaN(output.x) && isNaN(output.y)) {\n    return null;\n  }\n  return {\n    x: isNaN(output.x) ? 0 : output.x,\n    y: isNaN(output.y) ? 0 : output.y,\n    z: isNaN(output.z) ? 0 : output.z\n  };\n}\n\n// src/utilities/transform/parseTransform.ts\nfunction parseTransform(computedStyles) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  const { scale, transform, translate } = computedStyles;\n  const parsedScale = parseScale(scale);\n  const parsedTranslate = parseTranslate(translate);\n  const parsedMatrix = parseTransformMatrix(transform);\n  if (!parsedMatrix && !parsedScale && !parsedTranslate) {\n    return null;\n  }\n  const normalizedScale = {\n    x: (_a = parsedScale == null ? void 0 : parsedScale.x) != null ? _a : 1,\n    y: (_b = parsedScale == null ? void 0 : parsedScale.y) != null ? _b : 1\n  };\n  const normalizedTranslate = {\n    x: (_c = parsedTranslate == null ? void 0 : parsedTranslate.x) != null ? _c : 0,\n    y: (_d = parsedTranslate == null ? void 0 : parsedTranslate.y) != null ? _d : 0\n  };\n  const normalizedMatrix = {\n    x: (_e = parsedMatrix == null ? void 0 : parsedMatrix.x) != null ? _e : 0,\n    y: (_f = parsedMatrix == null ? void 0 : parsedMatrix.y) != null ? _f : 0,\n    scaleX: (_g = parsedMatrix == null ? void 0 : parsedMatrix.scaleX) != null ? _g : 1,\n    scaleY: (_h = parsedMatrix == null ? void 0 : parsedMatrix.scaleY) != null ? _h : 1\n  };\n  return {\n    x: normalizedTranslate.x + normalizedMatrix.x,\n    y: normalizedTranslate.y + normalizedMatrix.y,\n    z: (_i = parsedTranslate == null ? void 0 : parsedTranslate.z) != null ? _i : 0,\n    scaleX: normalizedScale.x * normalizedMatrix.scaleX,\n    scaleY: normalizedScale.y * normalizedMatrix.scaleY\n  };\n}\nfunction parseTransformMatrix(transform) {\n  if (transform.startsWith(\"matrix3d(\")) {\n    const transformArray = transform.slice(9, -1).split(/, /);\n    return {\n      x: +transformArray[12],\n      y: +transformArray[13],\n      scaleX: +transformArray[0],\n      scaleY: +transformArray[5]\n    };\n  } else if (transform.startsWith(\"matrix(\")) {\n    const transformArray = transform.slice(7, -1).split(/, /);\n    return {\n      x: +transformArray[4],\n      y: +transformArray[5],\n      scaleX: +transformArray[0],\n      scaleY: +transformArray[3]\n    };\n  }\n  return null;\n}\n\n// src/utilities/scroll/detectScrollIntent.ts\nvar ScrollDirection = /* @__PURE__ */ ((ScrollDirection2) => {\n  ScrollDirection2[ScrollDirection2[\"Idle\"] = 0] = \"Idle\";\n  ScrollDirection2[ScrollDirection2[\"Forward\"] = 1] = \"Forward\";\n  ScrollDirection2[ScrollDirection2[\"Reverse\"] = -1] = \"Reverse\";\n  return ScrollDirection2;\n})(ScrollDirection || {});\nvar defaultThreshold = {\n  x: 0.2,\n  y: 0.2\n};\nvar defaultTolerance = {\n  x: 10,\n  y: 10\n};\nfunction detectScrollIntent(scrollableElement, coordinates, intent, acceleration = 25, thresholdPercentage = defaultThreshold, tolerance = defaultTolerance) {\n  const { x, y } = coordinates;\n  const { rect, isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollableElement);\n  const frameTransform = getFrameTransform(scrollableElement);\n  const computedStyles = getComputedStyles(scrollableElement, true);\n  const parsedTransform = parseTransform(computedStyles);\n  const isXAxisInverted = parsedTransform !== null ? (parsedTransform == null ? void 0 : parsedTransform.scaleX) < 0 : false;\n  const isYAxisInverted = parsedTransform !== null ? (parsedTransform == null ? void 0 : parsedTransform.scaleY) < 0 : false;\n  const scrollContainerRect = new _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(\n    rect.left * frameTransform.scaleX + frameTransform.x,\n    rect.top * frameTransform.scaleY + frameTransform.y,\n    rect.width * frameTransform.scaleX,\n    rect.height * frameTransform.scaleY\n  );\n  const direction = {\n    x: 0 /* Idle */,\n    y: 0 /* Idle */\n  };\n  const speed = {\n    x: 0,\n    y: 0\n  };\n  const threshold2 = {\n    height: scrollContainerRect.height * thresholdPercentage.y,\n    width: scrollContainerRect.width * thresholdPercentage.x\n  };\n  if ((!isTop || isYAxisInverted && !isBottom) && y <= scrollContainerRect.top + threshold2.height && (intent == null ? void 0 : intent.y) !== 1 /* Forward */ && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {\n    direction.y = isYAxisInverted ? 1 /* Forward */ : -1 /* Reverse */;\n    speed.y = acceleration * Math.abs(\n      (scrollContainerRect.top + threshold2.height - y) / threshold2.height\n    );\n  } else if ((!isBottom || isYAxisInverted && !isTop) && y >= scrollContainerRect.bottom - threshold2.height && (intent == null ? void 0 : intent.y) !== -1 /* Reverse */ && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {\n    direction.y = isYAxisInverted ? -1 /* Reverse */ : 1 /* Forward */;\n    speed.y = acceleration * Math.abs(\n      (scrollContainerRect.bottom - threshold2.height - y) / threshold2.height\n    );\n  }\n  if ((!isRight || isXAxisInverted && !isLeft) && x >= scrollContainerRect.right - threshold2.width && (intent == null ? void 0 : intent.x) !== -1 /* Reverse */ && y >= scrollContainerRect.top - tolerance.y && y <= scrollContainerRect.bottom + tolerance.y) {\n    direction.x = isXAxisInverted ? -1 /* Reverse */ : 1 /* Forward */;\n    speed.x = acceleration * Math.abs(\n      (scrollContainerRect.right - threshold2.width - x) / threshold2.width\n    );\n  } else if ((!isLeft || isXAxisInverted && !isRight) && x <= scrollContainerRect.left + threshold2.width && (intent == null ? void 0 : intent.x) !== 1 /* Forward */ && y >= scrollContainerRect.top - tolerance.y && y <= scrollContainerRect.bottom + tolerance.y) {\n    direction.x = isXAxisInverted ? 1 /* Forward */ : -1 /* Reverse */;\n    speed.x = acceleration * Math.abs(\n      (scrollContainerRect.left + threshold2.width - x) / threshold2.width\n    );\n  }\n  return {\n    direction,\n    speed\n  };\n}\n\n// src/utilities/scroll/scrollIntoViewIfNeeded.ts\nfunction supportsScrollIntoViewIfNeeded(element) {\n  return \"scrollIntoViewIfNeeded\" in element && typeof element.scrollIntoViewIfNeeded === \"function\";\n}\nfunction scrollIntoViewIfNeeded(el, centerIfNeeded = false) {\n  if (supportsScrollIntoViewIfNeeded(el)) {\n    el.scrollIntoViewIfNeeded(centerIfNeeded);\n    return;\n  }\n  if (!isHTMLElement(el)) {\n    return el.scrollIntoView();\n  }\n  var parent = getFirstScrollableAncestor(el);\n  if (!isHTMLElement(parent)) {\n    return;\n  }\n  const parentComputedStyle = getComputedStyles(parent, true), parentBorderTopWidth = parseInt(\n    parentComputedStyle.getPropertyValue(\"border-top-width\")\n  ), parentBorderLeftWidth = parseInt(\n    parentComputedStyle.getPropertyValue(\"border-left-width\")\n  ), overTop = el.offsetTop - parent.offsetTop < parent.scrollTop, overBottom = el.offsetTop - parent.offsetTop + el.clientHeight - parentBorderTopWidth > parent.scrollTop + parent.clientHeight, overLeft = el.offsetLeft - parent.offsetLeft < parent.scrollLeft, overRight = el.offsetLeft - parent.offsetLeft + el.clientWidth - parentBorderLeftWidth > parent.scrollLeft + parent.clientWidth, alignWithTop = overTop && !overBottom;\n  if ((overTop || overBottom) && centerIfNeeded) {\n    parent.scrollTop = el.offsetTop - parent.offsetTop - parent.clientHeight / 2 - parentBorderTopWidth + el.clientHeight / 2;\n  }\n  if ((overLeft || overRight) && centerIfNeeded) {\n    parent.scrollLeft = el.offsetLeft - parent.offsetLeft - parent.clientWidth / 2 - parentBorderLeftWidth + el.clientWidth / 2;\n  }\n  if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {\n    el.scrollIntoView(alignWithTop);\n  }\n}\n\n// src/utilities/transform/applyTransform.ts\nfunction applyTransform(rect, parsedTransform, transformOrigin) {\n  const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;\n  const x = rect.left + translateX + (1 - scaleX) * parseFloat(transformOrigin);\n  const y = rect.top + translateY + (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(\" \") + 1));\n  const w = scaleX ? rect.width * scaleX : rect.width;\n  const h = scaleY ? rect.height * scaleY : rect.height;\n  return {\n    width: w,\n    height: h,\n    top: y,\n    right: x + w,\n    bottom: y + h,\n    left: x\n  };\n}\n\n// src/utilities/transform/inverseTransform.ts\nfunction inverseTransform(rect, parsedTransform, transformOrigin) {\n  const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;\n  const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);\n  const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(\" \") + 1));\n  const w = scaleX ? rect.width / scaleX : rect.width;\n  const h = scaleY ? rect.height / scaleY : rect.height;\n  return {\n    width: w,\n    height: h,\n    top: y,\n    right: x + w,\n    bottom: y + h,\n    left: x\n  };\n}\n\n// src/utilities/transform/animateTransform.ts\nfunction animateTransform({ element, keyframes, options }) {\n  return element.animate(keyframes, options).finished;\n}\n\n// src/utilities/transform/computeTranslate.ts\nfunction computeTranslate(element, translate = getComputedStyles(element).translate, projected = true) {\n  if (projected) {\n    const keyframe = getFinalKeyframe(\n      element,\n      (keyframe2) => \"translate\" in keyframe2\n    );\n    if (keyframe) {\n      const { translate: translate2 = \"\" } = keyframe[0];\n      if (typeof translate2 === \"string\") {\n        const finalTranslate = parseTranslate(translate2);\n        if (finalTranslate) {\n          return finalTranslate;\n        }\n      }\n    }\n  }\n  if (translate) {\n    const finalTranslate = parseTranslate(translate);\n    if (finalTranslate) {\n      return finalTranslate;\n    }\n  }\n  return { x: 0, y: 0, z: 0 };\n}\n\n// src/utilities/animations/forceFinishAnimations.ts\nvar scheduler3 = new Scheduler((callback) => setTimeout(callback, 0));\nvar animations = /* @__PURE__ */ new Map();\nvar clear2 = animations.clear.bind(animations);\nfunction getDocumentAnimations(element) {\n  const document2 = element.ownerDocument;\n  let documentAnimations = animations.get(document2);\n  if (documentAnimations) return documentAnimations;\n  documentAnimations = document2.getAnimations();\n  animations.set(document2, documentAnimations);\n  scheduler3.schedule(clear2);\n  const elementAnimations = documentAnimations.filter(\n    (animation) => isKeyframeEffect(animation.effect) && animation.effect.target === element\n  );\n  animations.set(element, elementAnimations);\n  return documentAnimations;\n}\nfunction forceFinishAnimations(element, options) {\n  const animations2 = getDocumentAnimations(element).filter((animation) => {\n    var _a, _b;\n    if (isKeyframeEffect(animation.effect)) {\n      const { target } = animation.effect;\n      const isValidTarget = (_b = target && ((_a = options.isValidTarget) == null ? void 0 : _a.call(options, target))) != null ? _b : true;\n      if (isValidTarget) {\n        return animation.effect.getKeyframes().some((keyframe) => {\n          for (const property of options.properties) {\n            if (keyframe[property]) return true;\n          }\n        });\n      }\n    }\n  }).map((animation) => {\n    const { effect, currentTime } = animation;\n    const duration = effect == null ? void 0 : effect.getComputedTiming().duration;\n    if (animation.pending || animation.playState === \"finished\") return;\n    if (typeof duration == \"number\" && typeof currentTime == \"number\" && currentTime < duration) {\n      animation.currentTime = duration;\n      return () => {\n        animation.currentTime = currentTime;\n      };\n    }\n  });\n  if (animations2.length > 0) {\n    return () => animations2.forEach((reset) => reset == null ? void 0 : reset());\n  }\n}\n\n// src/utilities/shapes/DOMRectangle.ts\nvar DOMRectangle = class extends _dnd_kit_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle {\n  constructor(element, options = {}) {\n    var _a, _b, _c, _d;\n    const {\n      frameTransform = getFrameTransform(element),\n      ignoreTransforms,\n      getBoundingClientRect = getBoundingRectangle\n    } = options;\n    const resetAnimations = forceFinishAnimations(element, {\n      properties: [\"transform\", \"translate\", \"scale\", \"width\", \"height\"],\n      isValidTarget: (target) => (target !== element || isSafari()) && target.contains(element)\n    });\n    const boundingRectangle = getBoundingClientRect(element);\n    let { top, left, width, height } = boundingRectangle;\n    let updated;\n    const computedStyles = getComputedStyles(element);\n    const parsedTransform = parseTransform(computedStyles);\n    const scale = {\n      x: (_a = parsedTransform == null ? void 0 : parsedTransform.scaleX) != null ? _a : 1,\n      y: (_b = parsedTransform == null ? void 0 : parsedTransform.scaleY) != null ? _b : 1\n    };\n    const projectedTransform = getProjectedTransform(element, computedStyles);\n    resetAnimations == null ? void 0 : resetAnimations();\n    if (parsedTransform) {\n      updated = inverseTransform(\n        boundingRectangle,\n        parsedTransform,\n        computedStyles.transformOrigin\n      );\n      if (ignoreTransforms || projectedTransform) {\n        top = updated.top;\n        left = updated.left;\n        width = updated.width;\n        height = updated.height;\n      }\n    }\n    const intrinsic = {\n      width: (_c = updated == null ? void 0 : updated.width) != null ? _c : width,\n      height: (_d = updated == null ? void 0 : updated.height) != null ? _d : height\n    };\n    if (projectedTransform && !ignoreTransforms && updated) {\n      const projected = applyTransform(\n        updated,\n        projectedTransform,\n        computedStyles.transformOrigin\n      );\n      top = projected.top;\n      left = projected.left;\n      width = projected.width;\n      height = projected.height;\n      scale.x = projectedTransform.scaleX;\n      scale.y = projectedTransform.scaleY;\n    }\n    if (frameTransform) {\n      if (!ignoreTransforms) {\n        left *= frameTransform.scaleX;\n        width *= frameTransform.scaleX;\n        top *= frameTransform.scaleY;\n        height *= frameTransform.scaleY;\n      }\n      left += frameTransform.x;\n      top += frameTransform.y;\n    }\n    super(left, top, width, height);\n    this.scale = scale;\n    this.intrinsicWidth = intrinsic.width;\n    this.intrinsicHeight = intrinsic.height;\n  }\n};\nfunction getProjectedTransform(element, computedStyles) {\n  var _a;\n  const animations2 = element.getAnimations();\n  let projectedTransform = null;\n  if (!animations2.length) return null;\n  for (const animation of animations2) {\n    if (animation.playState !== \"running\") continue;\n    const keyframes = isKeyframeEffect(animation.effect) ? animation.effect.getKeyframes() : [];\n    const keyframe = keyframes[keyframes.length - 1];\n    if (!keyframe) continue;\n    const { transform, translate, scale } = keyframe;\n    if (transform || translate || scale) {\n      const parsedTransform = parseTransform({\n        transform: typeof transform === \"string\" && transform ? transform : computedStyles.transform,\n        translate: typeof translate === \"string\" && translate ? translate : computedStyles.translate,\n        scale: typeof scale === \"string\" && scale ? scale : computedStyles.scale\n      });\n      if (parsedTransform) {\n        projectedTransform = projectedTransform ? {\n          x: projectedTransform.x + parsedTransform.x,\n          y: projectedTransform.y + parsedTransform.y,\n          z: (_a = projectedTransform.z) != null ? _a : parsedTransform.z,\n          scaleX: projectedTransform.scaleX * parsedTransform.scaleX,\n          scaleY: projectedTransform.scaleY * parsedTransform.scaleY\n        } : parsedTransform;\n      }\n    }\n  }\n  return projectedTransform;\n}\n\n// src/utilities/type-guards/supportsStyle.ts\nfunction supportsStyle(element) {\n  return \"style\" in element && typeof element.style === \"object\" && element.style !== null && \"setProperty\" in element.style && \"removeProperty\" in element.style && typeof element.style.setProperty === \"function\" && typeof element.style.removeProperty === \"function\";\n}\n\n// src/utilities/styles/Styles.ts\nvar Styles = class {\n  constructor(element) {\n    this.element = element;\n    this.initial = /* @__PURE__ */ new Map();\n  }\n  set(properties, prefix = \"\") {\n    const { element } = this;\n    if (!supportsStyle(element)) {\n      return;\n    }\n    for (const [key, value] of Object.entries(properties)) {\n      const property = `${prefix}${key}`;\n      if (!this.initial.has(property)) {\n        this.initial.set(property, element.style.getPropertyValue(property));\n      }\n      element.style.setProperty(\n        property,\n        typeof value === \"string\" ? value : `${value}px`\n      );\n    }\n  }\n  remove(properties, prefix = \"\") {\n    const { element } = this;\n    if (!supportsStyle(element)) {\n      return;\n    }\n    for (const key of properties) {\n      const property = `${prefix}${key}`;\n      element.style.removeProperty(property);\n    }\n  }\n  reset() {\n    const { element } = this;\n    if (!supportsStyle(element)) {\n      return;\n    }\n    for (const [key, value] of this.initial) {\n      element.style.setProperty(key, value);\n    }\n    if (element.getAttribute(\"style\") === \"\") {\n      element.removeAttribute(\"style\");\n    }\n  }\n};\n\n// src/utilities/type-guards/isElement.ts\nfunction isElement(target) {\n  if (!target) return false;\n  return target instanceof getWindow(target).Element || isNode(target) && target.nodeType === Node.ELEMENT_NODE;\n}\n\n// src/utilities/type-guards/isKeyboardEvent.ts\nfunction isKeyboardEvent(event) {\n  if (!event) return false;\n  const { KeyboardEvent } = getWindow(event.target);\n  return event instanceof KeyboardEvent;\n}\n\n// src/utilities/type-guards/isPointerEvent.ts\nfunction isPointerEvent(event) {\n  if (!event) return false;\n  const { PointerEvent } = getWindow(event.target);\n  return event instanceof PointerEvent;\n}\n\n// src/utilities/type-guards/supportsViewTransition.ts\nfunction supportsViewTransition(document2) {\n  return \"startViewTransition\" in document2;\n}\n\n// src/utilities/type-guards/isTextInput.ts\nfunction isTextInput(target) {\n  if (!isElement(target)) return false;\n  const { tagName } = target;\n  return tagName === \"INPUT\" || tagName === \"TEXTAREA\" || isContentEditable(target);\n}\nfunction isContentEditable(element) {\n  return element.hasAttribute(\"contenteditable\") && element.getAttribute(\"contenteditable\") !== \"false\";\n}\n\n// src/utilities/misc/generateUniqueId.ts\nvar ids = {};\nfunction generateUniqueId(prefix) {\n  const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n  ids[prefix] = id;\n  return `${prefix}-${id}`;\n}\n\n\n//# sourceMappingURL=utilities.js.map\n//# sourceMappingURL=utilities.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGRuZC1raXQrZG9tQDAuMS4yMS9ub2RlX21vZHVsZXMvQGRuZC1raXQvZG9tL3V0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdC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QUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSx5Q0FBeUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBK0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHdEQUFTO0FBQzFDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTyxFQUFFLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU8sRUFBRSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sR0FBRyxHQUFHO0FBQ3pCOztBQUVveUI7QUFDcHlCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mZWRlcmljb2pvcmdlYm9uZWx0b3p6aS9EZXNrdG9wL1dvcmsvcHVjay9jb2RlL2Vjb3N5c3RlbS9wdWNrLWNvbmZpZ3Mvc2hhZGNuLXR3YmxvY2tzL25vZGVfbW9kdWxlcy8ucG5wbS9AZG5kLWtpdCtkb21AMC4xLjIxL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9kb20vdXRpbGl0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJ0BkbmQta2l0L2dlb21ldHJ5JztcblxudmFyIF9fdHlwZUVycm9yID0gKG1zZykgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbn07XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiBtZW1iZXIuaGFzKG9iaikgfHwgX190eXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLCBtZXRob2QpO1xuXG4vLyBzcmMvdXRpbGl0aWVzL3R5cGUtZ3VhcmRzL2lzS2V5ZnJhbWVFZmZlY3QudHNcbmZ1bmN0aW9uIGlzS2V5ZnJhbWVFZmZlY3QoZWZmZWN0KSB7XG4gIGlmICghZWZmZWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBLZXlmcmFtZUVmZmVjdCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBcImdldEtleWZyYW1lc1wiIGluIGVmZmVjdCAmJiB0eXBlb2YgZWZmZWN0LmdldEtleWZyYW1lcyA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2FuaW1hdGlvbnMvZ2V0RmluYWxLZXlmcmFtZS50c1xuZnVuY3Rpb24gZ2V0RmluYWxLZXlmcmFtZShlbGVtZW50LCBtYXRjaCkge1xuICBjb25zdCBhbmltYXRpb25zMiA9IGVsZW1lbnQuZ2V0QW5pbWF0aW9ucygpO1xuICBpZiAoYW5pbWF0aW9uczIubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIGFuaW1hdGlvbnMyKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gXCJydW5uaW5nXCIpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgeyBlZmZlY3QgfSA9IGFuaW1hdGlvbjtcbiAgICAgIGNvbnN0IGtleWZyYW1lcyA9IGlzS2V5ZnJhbWVFZmZlY3QoZWZmZWN0KSA/IGVmZmVjdC5nZXRLZXlmcmFtZXMoKSA6IFtdO1xuICAgICAgY29uc3QgbWF0Y2hlZEtleWZyYW1lcyA9IGtleWZyYW1lcy5maWx0ZXIobWF0Y2gpO1xuICAgICAgaWYgKG1hdGNoZWRLZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gW21hdGNoZWRLZXlmcmFtZXNbbWF0Y2hlZEtleWZyYW1lcy5sZW5ndGggLSAxXSwgYW5pbWF0aW9uXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvYm91bmRpbmctcmVjdGFuZ2xlL2dldEJvdW5kaW5nUmVjdGFuZ2xlLnRzXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3RhbmdsZShlbGVtZW50KSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9leGVjdXRpb24tY29udGV4dC9jYW5Vc2VET00udHNcbnZhciBjYW5Vc2VET00gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vLyBzcmMvdXRpbGl0aWVzL3R5cGUtZ3VhcmRzL2lzV2luZG93LnRzXG5mdW5jdGlvbiBpc1dpbmRvdyhlbGVtZW50KSB7XG4gIGNvbnN0IGVsZW1lbnRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50U3RyaW5nID09PSBcIltvYmplY3QgV2luZG93XVwiIHx8IC8vIEluIEVsZWN0cm9uIGNvbnRleHQgdGhlIFdpbmRvdyBvYmplY3Qgc2VyaWFsaXplcyB0byBbb2JqZWN0IGdsb2JhbF1cbiAgZWxlbWVudFN0cmluZyA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIjtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy90eXBlLWd1YXJkcy9pc05vZGUudHNcbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIHJldHVybiBcIm5vZGVUeXBlXCIgaW4gbm9kZTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9leGVjdXRpb24tY29udGV4dC9nZXRXaW5kb3cudHNcbmZ1bmN0aW9uIGdldFdpbmRvdyh0YXJnZXQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAoaXNXaW5kb3codGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKCFpc05vZGUodGFyZ2V0KSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKFwiZGVmYXVsdFZpZXdcIiBpbiB0YXJnZXQpIHtcbiAgICByZXR1cm4gKF9hID0gdGFyZ2V0LmRlZmF1bHRWaWV3KSAhPSBudWxsID8gX2EgOiB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIChfYyA9IChfYiA9IHRhcmdldC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuZGVmYXVsdFZpZXcpICE9IG51bGwgPyBfYyA6IHdpbmRvdztcbn1cblxuLy8gc3JjL3V0aWxpdGllcy90eXBlLWd1YXJkcy9pc0RvY3VtZW50LnRzXG5mdW5jdGlvbiBpc0RvY3VtZW50KG5vZGUpIHtcbiAgY29uc3QgeyBEb2N1bWVudCB9ID0gZ2V0V2luZG93KG5vZGUpO1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERvY3VtZW50IHx8IFwibm9kZVR5cGVcIiBpbiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy90eXBlLWd1YXJkcy9pc0hUTUxFbGVtZW50LnRzXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgaWYgKCFub2RlIHx8IGlzV2luZG93KG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50IHx8IFwibmFtZXNwYWNlVVJJXCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS5uYW1lc3BhY2VVUkkgPT09IFwic3RyaW5nXCIgJiYgbm9kZS5uYW1lc3BhY2VVUkkuZW5kc1dpdGgoXCJodG1sXCIpO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3R5cGUtZ3VhcmRzL2lzU1ZHRWxlbWVudC50c1xuZnVuY3Rpb24gaXNTVkdFbGVtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBnZXRXaW5kb3cobm9kZSkuU1ZHRWxlbWVudCB8fCBcIm5hbWVzcGFjZVVSSVwiIGluIG5vZGUgJiYgdHlwZW9mIG5vZGUubmFtZXNwYWNlVVJJID09PSBcInN0cmluZ1wiICYmIG5vZGUubmFtZXNwYWNlVVJJLmVuZHNXaXRoKFwic3ZnXCIpO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2V4ZWN1dGlvbi1jb250ZXh0L2dldERvY3VtZW50LnRzXG5mdW5jdGlvbiBnZXREb2N1bWVudCh0YXJnZXQpIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cbiAgaWYgKGlzV2luZG93KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmRvY3VtZW50O1xuICB9XG4gIGlmICghaXNOb2RlKHRhcmdldCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cbiAgaWYgKGlzRG9jdW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSB8fCBpc1NWR0VsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQ7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvYm91bmRpbmctcmVjdGFuZ2xlL2dldFZpZXdwb3J0Qm91bmRpbmdSZWN0YW5nbGUudHNcbmZ1bmN0aW9uIGdldFZpZXdwb3J0Qm91bmRpbmdSZWN0YW5nbGUoZWxlbWVudCkge1xuICBjb25zdCB7IGRvY3VtZW50RWxlbWVudCB9ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHdpZHRoID0gZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiB3aWR0aCxcbiAgICBib3R0b206IGhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9ib3VuZGluZy1yZWN0YW5nbGUvaXNPdmVyZmxvd1Zpc2libGUudHNcbmZ1bmN0aW9uIGlzT3ZlcmZsb3dWaXNpYmxlKGVsZW1lbnQsIHN0eWxlKSB7XG4gIGlmIChpc0RldGFpbHNFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQub3BlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBvdmVyZmxvdywgb3ZlcmZsb3dYLCBvdmVyZmxvd1kgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiBvdmVyZmxvdyA9PT0gXCJ2aXNpYmxlXCIgJiYgb3ZlcmZsb3dYID09PSBcInZpc2libGVcIiAmJiBvdmVyZmxvd1kgPT09IFwidmlzaWJsZVwiO1xufVxuZnVuY3Rpb24gaXNEZXRhaWxzRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwiREVUQUlMU1wiO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2JvdW5kaW5nLXJlY3RhbmdsZS9nZXRWaXNpYmxlQm91bmRpbmdSZWN0YW5nbGUudHNcbmZ1bmN0aW9uIGdldFZpc2libGVCb3VuZGluZ1JlY3RhbmdsZShlbGVtZW50LCBib3VuZGluZ0NsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBtYXJnaW4gPSAwKSB7XG4gIHZhciBfYTtcbiAgbGV0IHJlY3QgPSBib3VuZGluZ0NsaWVudFJlY3Q7XG4gIGNvbnN0IHsgb3duZXJEb2N1bWVudCB9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3duZXJXaW5kb3cgPSAoX2EgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAhPSBudWxsID8gX2EgOiB3aW5kb3c7XG4gIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGFuY2VzdG9yICYmIGFuY2VzdG9yICE9PSBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIGlmICghaXNPdmVyZmxvd1Zpc2libGUoYW5jZXN0b3IpKSB7XG4gICAgICBjb25zdCBhbmNlc3RvclJlY3QgPSBhbmNlc3Rvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IG1hcmdpblRvcCA9IG1hcmdpbiAqIChhbmNlc3RvclJlY3QuYm90dG9tIC0gYW5jZXN0b3JSZWN0LnRvcCk7XG4gICAgICBjb25zdCBtYXJnaW5SaWdodCA9IG1hcmdpbiAqIChhbmNlc3RvclJlY3QucmlnaHQgLSBhbmNlc3RvclJlY3QubGVmdCk7XG4gICAgICBjb25zdCBtYXJnaW5Cb3R0b20gPSBtYXJnaW4gKiAoYW5jZXN0b3JSZWN0LmJvdHRvbSAtIGFuY2VzdG9yUmVjdC50b3ApO1xuICAgICAgY29uc3QgbWFyZ2luTGVmdCA9IG1hcmdpbiAqIChhbmNlc3RvclJlY3QucmlnaHQgLSBhbmNlc3RvclJlY3QubGVmdCk7XG4gICAgICByZWN0ID0ge1xuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QudG9wLCBhbmNlc3RvclJlY3QudG9wIC0gbWFyZ2luVG9wKSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QucmlnaHQsIGFuY2VzdG9yUmVjdC5yaWdodCArIG1hcmdpblJpZ2h0KSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0LmJvdHRvbSwgYW5jZXN0b3JSZWN0LmJvdHRvbSArIG1hcmdpbkJvdHRvbSksXG4gICAgICAgIGxlZnQ6IE1hdGgubWF4KHJlY3QubGVmdCwgYW5jZXN0b3JSZWN0LmxlZnQgLSBtYXJnaW5MZWZ0KSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIC8vIFdpbGwgYmUgY2FsY3VsYXRlZCBuZXh0XG4gICAgICAgIGhlaWdodDogMFxuICAgICAgICAvLyBXaWxsIGJlIGNhbGN1bGF0ZWQgbmV4dFxuICAgICAgfTtcbiAgICAgIHJlY3Qud2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgcmVjdC5oZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgIH1cbiAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IG93bmVyV2luZG93LmlubmVyV2lkdGg7XG4gIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gb3duZXJXaW5kb3cuaW5uZXJIZWlnaHQ7XG4gIGNvbnN0IHZpZXdwb3J0TWFyZ2luWSA9IG1hcmdpbiAqIHZpZXdwb3J0SGVpZ2h0O1xuICBjb25zdCB2aWV3cG9ydE1hcmdpblggPSBtYXJnaW4gKiB2aWV3cG9ydFdpZHRoO1xuICByZWN0ID0ge1xuICAgIHRvcDogTWF0aC5tYXgocmVjdC50b3AsIDAgLSB2aWV3cG9ydE1hcmdpblkpLFxuICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0LnJpZ2h0LCB2aWV3cG9ydFdpZHRoICsgdmlld3BvcnRNYXJnaW5YKSxcbiAgICBib3R0b206IE1hdGgubWluKHJlY3QuYm90dG9tLCB2aWV3cG9ydEhlaWdodCArIHZpZXdwb3J0TWFyZ2luWSksXG4gICAgbGVmdDogTWF0aC5tYXgocmVjdC5sZWZ0LCAwIC0gdmlld3BvcnRNYXJnaW5YKSxcbiAgICB3aWR0aDogMCxcbiAgICAvLyBXaWxsIGJlIGNhbGN1bGF0ZWQgbmV4dFxuICAgIGhlaWdodDogMFxuICAgIC8vIFdpbGwgYmUgY2FsY3VsYXRlZCBuZXh0XG4gIH07XG4gIHJlY3Qud2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gIGlmIChyZWN0LndpZHRoIDwgMCkge1xuICAgIHJlY3Qud2lkdGggPSAwO1xuICB9XG4gIGlmIChyZWN0LmhlaWdodCA8IDApIHtcbiAgICByZWN0LmhlaWdodCA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZXhlY3V0aW9uLWNvbnRleHQvaXNTYWZhcmkudHNcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9lbGVtZW50L2Nsb25lRWxlbWVudC50c1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBjYW52YXMsIFtjb250ZW50ZWRpdGFibGVdXCI7XG4gIGNvbnN0IGNsb25lZEVsZW1lbnQgPSBlbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgY29uc3QgZmllbGRzID0gQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgY29uc3QgY2xvbmVkRmllbGRzID0gQXJyYXkuZnJvbShjbG9uZWRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgY2xvbmVkRmllbGRzLmZvckVhY2goKGZpZWxkLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsRmllbGQgPSBmaWVsZHNbaW5kZXhdO1xuICAgIGlmIChpc0ZpZWxkKGZpZWxkKSAmJiBpc0ZpZWxkKG9yaWdpbmFsRmllbGQpKSB7XG4gICAgICBpZiAoZmllbGQudHlwZSAhPT0gXCJmaWxlXCIpIHtcbiAgICAgICAgZmllbGQudmFsdWUgPSBvcmlnaW5hbEZpZWxkLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkLnR5cGUgPT09IFwicmFkaW9cIiAmJiBmaWVsZC5uYW1lKSB7XG4gICAgICAgIGZpZWxkLm5hbWUgPSBgQ2xvbmVkX18ke2ZpZWxkLm5hbWV9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ2FudmFzRWxlbWVudChmaWVsZCkgJiYgaXNDYW52YXNFbGVtZW50KG9yaWdpbmFsRmllbGQpICYmIG9yaWdpbmFsRmllbGQud2lkdGggPiAwICYmIG9yaWdpbmFsRmllbGQuaGVpZ2h0ID4gMCkge1xuICAgICAgY29uc3QgZGVzdEN0eCA9IGZpZWxkLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGRlc3RDdHggPT0gbnVsbCA/IHZvaWQgMCA6IGRlc3RDdHguZHJhd0ltYWdlKG9yaWdpbmFsRmllbGQsIDAsIDApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9uZWRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNGaWVsZChlbGVtZW50KSB7XG4gIHJldHVybiBcInZhbHVlXCIgaW4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzQ2FudmFzRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwiQ0FOVkFTXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZWxlbWVudC9nZXRFbGVtZW50RnJvbVBvaW50LnRzXG5mdW5jdGlvbiBnZXRFbGVtZW50RnJvbVBvaW50KGRvY3VtZW50MiwgeyB4LCB5IH0pIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50Mi5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICBpZiAoaXNJRnJhbWVFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgY29uc3QgeyBjb250ZW50RG9jdW1lbnQgfSA9IGVsZW1lbnQ7XG4gICAgaWYgKGNvbnRlbnREb2N1bWVudCkge1xuICAgICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gZ2V0RWxlbWVudEZyb21Qb2ludChjb250ZW50RG9jdW1lbnQsIHtcbiAgICAgICAgeDogeCAtIGxlZnQsXG4gICAgICAgIHk6IHkgLSB0b3BcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSUZyYW1lRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC50YWdOYW1lKSA9PT0gXCJJRlJBTUVcIjtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9lbGVtZW50L3Byb3hpZWRFbGVtZW50cy50c1xudmFyIFByb3hpZWRFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuXG4vLyBzcmMvdXRpbGl0aWVzL2V2ZW50LWxpc3RlbmVycy9MaXN0ZW5lcnMudHNcbnZhciBMaXN0ZW5lcnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW50cmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5jbGVhciA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IFt0YXJnZXQsIHsgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMgfV0gPSBlbnRyeTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbnRyaWVzLmNsZWFyKCk7XG4gICAgfTtcbiAgfVxuICBiaW5kKHRhcmdldCwgaW5wdXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGxpc3RlbmVycykge1xuICAgICAgY29uc3QgeyB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyB9ID0gZGVzY3JpcHRvcjtcbiAgICAgIGNvbnN0IGVudHJ5ID0gW3RhcmdldCwgZGVzY3JpcHRvcl07XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmVudHJpZXMuYWRkKGVudHJ5KTtcbiAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgZm9yIChjb25zdCBbdGFyZ2V0MiwgeyB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyB9XSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIHRhcmdldDIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxpdGllcy9mcmFtZS9nZXRGcmFtZUVsZW1lbnQudHNcbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudChlbCkge1xuICBjb25zdCByZWZXaW5kb3cgPSBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgaWYgKHJlZldpbmRvdyAmJiByZWZXaW5kb3cuc2VsZiAhPT0gcmVmV2luZG93LnBhcmVudCkge1xuICAgIHJldHVybiByZWZXaW5kb3cuZnJhbWVFbGVtZW50O1xuICB9XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZnJhbWUvZ2V0RnJhbWVFbGVtZW50cy50c1xuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50cyhlbCkge1xuICBjb25zdCBmcmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoZWwpO1xuICB3aGlsZSAoZnJhbWUpIHtcbiAgICBmcmFtZXMuYWRkKGZyYW1lKTtcbiAgICBmcmFtZSA9IGdldEZyYW1lRWxlbWVudChmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZyYW1lcztcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9zY2hlZHVsaW5nL3RpbWVvdXQudHNcbmZ1bmN0aW9uIHRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKSB7XG4gIGNvbnN0IGlkID0gc2V0VGltZW91dChjYWxsYmFjaywgZHVyYXRpb24pO1xuICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGlkKTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9zY2hlZHVsaW5nL3Rocm90dGxlLnRzXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCBsaW1pdCkge1xuICBjb25zdCB0aW1lID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGxldCBjYW5jZWw7XG4gIGxldCBsYXN0UmFuO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuICAgIGlmICghbGFzdFJhbikge1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGxhc3RSYW4gPSB0aW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmNlbCA9PSBudWxsID8gdm9pZCAwIDogY2FuY2VsKCk7XG4gICAgICBjYW5jZWwgPSB0aW1lb3V0KFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBsYXN0UmFuID0gdGltZSgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW1pdCAtICh0aW1lKCkgLSBsYXN0UmFuKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvYm91bmRpbmctcmVjdGFuZ2xlL2lzUmVjdEVxdWFsLnRzXG5mdW5jdGlvbiBpc1JlY3RFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBhLnRvcCA9PSBiLnRvcCAmJiBhLmxlZnQgPT0gYi5sZWZ0ICYmIGEucmlnaHQgPT0gYi5yaWdodCAmJiBhLmJvdHRvbSA9PSBiLmJvdHRvbTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9ib3VuZGluZy1yZWN0YW5nbGUvaXNWaXNpYmxlLnRzXG5mdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCwgYm91bmRpbmdDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldFZpc2libGVCb3VuZGluZ1JlY3RhbmdsZShcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kaW5nQ2xpZW50UmVjdFxuICApO1xuICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDA7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvb2JzZXJ2ZXJzL1Jlc2l6ZU5vdGlmaWVyLnRzXG52YXIgT2JzZXJ2ZXIgPSBjYW5Vc2VET00gPyBSZXNpemVPYnNlcnZlciA6IGNsYXNzIE1vY2tSZXNpemVPYnNlcnZlciB7XG4gIG9ic2VydmUoKSB7XG4gIH1cbiAgdW5vYnNlcnZlKCkge1xuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gIH1cbn07XG52YXIgX2luaXRpYWxpemVkO1xudmFyIFJlc2l6ZU5vdGlmaWVyID0gY2xhc3MgZXh0ZW5kcyBPYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKGVudHJpZXMpID0+IHtcbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9pbml0aWFsaXplZCkpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9pbml0aWFsaXplZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIHRoaXMpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaW5pdGlhbGl6ZWQsIGZhbHNlKTtcbiAgfVxufTtcbl9pbml0aWFsaXplZCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIHNyYy91dGlsaXRpZXMvb2JzZXJ2ZXJzL1Bvc2l0aW9uT2JzZXJ2ZXIudHNcbnZhciB0aHJlc2hvbGQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGluZGV4KSA9PiBpbmRleCAvIDEwMCk7XG52YXIgVEhST1RUTEVfSU5URVJWQUwgPSA3NTtcbnZhciBfdmlzaWJsZSwgX3ByZXZpb3VzQm91bmRpbmdDbGllbnRSZWN0LCBfcmVzaXplT2JzZXJ2ZXIsIF9wb3NpdGlvbk9ic2VydmVyLCBfdmlzaWJpbGl0eU9ic2VydmVyLCBfZGVidWcsIF9kaXNjb25uZWN0ZWQsIF9vYnNlcnZlUG9zaXRpb24sIF9Qb3NpdGlvbk9ic2VydmVyX2luc3RhbmNlcywgbm90aWZ5X2ZuLCB1cGRhdGVEZWJ1Z19mbjtcbnZhciBQb3NpdGlvbk9ic2VydmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyA9IHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgc2tpcEluaXRpYWw6IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX1Bvc2l0aW9uT2JzZXJ2ZXJfaW5zdGFuY2VzKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZGlzY29ubmVjdGVkLCB0cnVlKTtcbiAgICAgIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVzaXplT2JzZXJ2ZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgKF9iID0gX19wcml2YXRlR2V0KHRoaXMsIF9wb3NpdGlvbk9ic2VydmVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdmlzaWJpbGl0eU9ic2VydmVyKS5kaXNjb25uZWN0KCk7XG4gICAgICAoX2MgPSBfX3ByaXZhdGVHZXQodGhpcywgX2RlYnVnKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJlbW92ZSgpO1xuICAgIH07XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF92aXNpYmxlLCB0cnVlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3ByZXZpb3VzQm91bmRpbmdDbGllbnRSZWN0KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3Jlc2l6ZU9ic2VydmVyKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3Bvc2l0aW9uT2JzZXJ2ZXIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdmlzaWJpbGl0eU9ic2VydmVyKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2RlYnVnKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Rpc2Nvbm5lY3RlZCwgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb2JzZXJ2ZVBvc2l0aW9uLCB0aHJvdHRsZSgoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9zaXRpb25PYnNlcnZlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9kaXNjb25uZWN0ZWQpIHx8ICFfX3ByaXZhdGVHZXQodGhpcywgX3Zpc2libGUpIHx8ICFlbGVtZW50LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvb3QgPSAoX2IgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpICE9IG51bGwgPyBfYiA6IGRvY3VtZW50O1xuICAgICAgY29uc3QgeyBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCB9ID0gKF9jID0gcm9vdC5kZWZhdWx0VmlldykgIT0gbnVsbCA/IF9jIDogd2luZG93O1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB2aXNpYmxlUmVjdCA9IGdldFZpc2libGVCb3VuZGluZ1JlY3RhbmdsZShlbGVtZW50LCBjbGllbnRSZWN0KTtcbiAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gPSB2aXNpYmxlUmVjdDtcbiAgICAgIGNvbnN0IGluc2V0VG9wID0gLU1hdGguZmxvb3IodG9wKTtcbiAgICAgIGNvbnN0IGluc2V0TGVmdCA9IC1NYXRoLmZsb29yKGxlZnQpO1xuICAgICAgY29uc3QgaW5zZXRSaWdodCA9IC1NYXRoLmZsb29yKGlubmVyV2lkdGggLSByaWdodCk7XG4gICAgICBjb25zdCBpbnNldEJvdHRvbSA9IC1NYXRoLmZsb29yKGlubmVySGVpZ2h0IC0gYm90dG9tKTtcbiAgICAgIGNvbnN0IHJvb3RNYXJnaW4gPSBgJHtpbnNldFRvcH1weCAke2luc2V0UmlnaHR9cHggJHtpbnNldEJvdHRvbX1weCAke2luc2V0TGVmdH1weGA7XG4gICAgICB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdCA9IGNsaWVudFJlY3Q7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Bvc2l0aW9uT2JzZXJ2ZXIsIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgKGVudHJpZXMpID0+IHtcbiAgICAgICAgICBjb25zdCBbZW50cnldID0gZW50cmllcztcbiAgICAgICAgICBjb25zdCB7IGludGVyc2VjdGlvblJlY3QgfSA9IGVudHJ5O1xuICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvblJhdGlvID0gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gIT09IDEgPyBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA6IFJlY3RhbmdsZS5pbnRlcnNlY3Rpb25SYXRpbyhcbiAgICAgICAgICAgIGludGVyc2VjdGlvblJlY3QsXG4gICAgICAgICAgICBnZXRWaXNpYmxlQm91bmRpbmdSZWN0YW5nbGUoZWxlbWVudClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb25SYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9vYnNlcnZlUG9zaXRpb24pLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgICAgcm9vdFxuICAgICAgICB9XG4gICAgICApKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9zaXRpb25PYnNlcnZlcikub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfUG9zaXRpb25PYnNlcnZlcl9pbnN0YW5jZXMsIG5vdGlmeV9mbikuY2FsbCh0aGlzKTtcbiAgICB9LCBUSFJPVFRMRV9JTlRFUlZBTCkpO1xuICAgIHRoaXMuYm91bmRpbmdDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Zpc2libGUsIGlzVmlzaWJsZShlbGVtZW50LCB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdCkpO1xuICAgIGxldCBpbml0aWFsID0gdHJ1ZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gKGJvdW5kaW5nQ2xpZW50UmVjdCkgPT4ge1xuICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5za2lwSW5pdGlhbCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soYm91bmRpbmdDbGllbnRSZWN0KTtcbiAgICB9O1xuICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVidWcpIHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZGVidWcsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9kZWJ1Zykuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgwLDAsMCwwLjE1KVwiO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9kZWJ1Zykuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2RlYnVnKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICByb290LmJvZHkuYXBwZW5kQ2hpbGQoX19wcml2YXRlR2V0KHRoaXMsIF9kZWJ1ZykpO1xuICAgIH1cbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Zpc2liaWxpdHlPYnNlcnZlciwgbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgKGVudHJpZXMpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHsgYm91bmRpbmdDbGllbnRSZWN0LCBpc0ludGVyc2VjdGluZzogdmlzaWJsZSB9ID0gZW50cnk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYm91bmRpbmdDbGllbnRSZWN0O1xuICAgICAgICBjb25zdCBwcmV2aW91c1Zpc2libGUgPSBfX3ByaXZhdGVHZXQodGhpcywgX3Zpc2libGUpO1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Zpc2libGUsIHZpc2libGUpO1xuICAgICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHJldHVybjtcbiAgICAgICAgaWYgKHByZXZpb3VzVmlzaWJsZSAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9zaXRpb25PYnNlcnZlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAoX2IgPSBfX3ByaXZhdGVHZXQodGhpcywgX3Jlc2l6ZU9ic2VydmVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Jlc2l6ZU9ic2VydmVyLCB2b2lkIDApO1xuICAgICAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2RlYnVnKSkgX19wcml2YXRlR2V0KHRoaXMsIF9kZWJ1Zykuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9vYnNlcnZlUG9zaXRpb24pLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUgJiYgIV9fcHJpdmF0ZUdldCh0aGlzLCBfcmVzaXplT2JzZXJ2ZXIpKSB7XG4gICAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9yZXNpemVPYnNlcnZlciwgbmV3IFJlc2l6ZU5vdGlmaWVyKF9fcHJpdmF0ZUdldCh0aGlzLCBfb2JzZXJ2ZVBvc2l0aW9uKSkpO1xuICAgICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVzaXplT2JzZXJ2ZXIpLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgcm9vdFxuICAgICAgfVxuICAgICkpO1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3Zpc2libGUpICYmICFvcHRpb25zLnNraXBJbml0aWFsKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMuYm91bmRpbmdDbGllbnRSZWN0KTtcbiAgICB9XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF92aXNpYmlsaXR5T2JzZXJ2ZXIpLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbn07XG5fdmlzaWJsZSA9IG5ldyBXZWFrTWFwKCk7XG5fcHJldmlvdXNCb3VuZGluZ0NsaWVudFJlY3QgPSBuZXcgV2Vha01hcCgpO1xuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFdlYWtNYXAoKTtcbl9wb3NpdGlvbk9ic2VydmVyID0gbmV3IFdlYWtNYXAoKTtcbl92aXNpYmlsaXR5T2JzZXJ2ZXIgPSBuZXcgV2Vha01hcCgpO1xuX2RlYnVnID0gbmV3IFdlYWtNYXAoKTtcbl9kaXNjb25uZWN0ZWQgPSBuZXcgV2Vha01hcCgpO1xuX29ic2VydmVQb3NpdGlvbiA9IG5ldyBXZWFrTWFwKCk7XG5fUG9zaXRpb25PYnNlcnZlcl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xubm90aWZ5X2ZuID0gZnVuY3Rpb24oKSB7XG4gIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2Rpc2Nvbm5lY3RlZCkpIHJldHVybjtcbiAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9Qb3NpdGlvbk9ic2VydmVyX2luc3RhbmNlcywgdXBkYXRlRGVidWdfZm4pLmNhbGwodGhpcyk7XG4gIGlmIChpc1JlY3RFcXVhbCh0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdCwgX19wcml2YXRlR2V0KHRoaXMsIF9wcmV2aW91c0JvdW5kaW5nQ2xpZW50UmVjdCkpKVxuICAgIHJldHVybjtcbiAgdGhpcy5jYWxsYmFjayh0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdCk7XG4gIF9fcHJpdmF0ZVNldCh0aGlzLCBfcHJldmlvdXNCb3VuZGluZ0NsaWVudFJlY3QsIHRoaXMuYm91bmRpbmdDbGllbnRSZWN0KTtcbn07XG51cGRhdGVEZWJ1Z19mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9kZWJ1ZykpIHtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gZ2V0VmlzaWJsZUJvdW5kaW5nUmVjdGFuZ2xlKFxuICAgICAgdGhpcy5lbGVtZW50XG4gICAgKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2RlYnVnKS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9kZWJ1Zykuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVidWcpLnN0eWxlLnRvcCA9IGAke01hdGguZmxvb3IodG9wKX1weGA7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9kZWJ1Zykuc3R5bGUubGVmdCA9IGAke01hdGguZmxvb3IobGVmdCl9cHhgO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVidWcpLnN0eWxlLndpZHRoID0gYCR7TWF0aC5mbG9vcih3aWR0aCl9cHhgO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVidWcpLnN0eWxlLmhlaWdodCA9IGAke01hdGguZmxvb3IoaGVpZ2h0KX1weGA7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsaXRpZXMvb2JzZXJ2ZXJzL0ZyYW1lT2JzZXJ2ZXIudHNcbnZhciBmcmFtZVBvc2l0aW9uT2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgc2Nyb2xsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhZGRGcmFtZUxpc3RlbmVyKGZyYW1lLCBjYWxsYmFjaykge1xuICBsZXQgY2FjaGVkID0gZnJhbWVQb3NpdGlvbk9ic2VydmVycy5nZXQoZnJhbWUpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFBvc2l0aW9uT2JzZXJ2ZXIoXG4gICAgICBmcmFtZSxcbiAgICAgIChib3VuZGluZ0NsaWVudFJlY3QpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVkMiA9IGZyYW1lUG9zaXRpb25PYnNlcnZlcnMuZ2V0KGZyYW1lKTtcbiAgICAgICAgaWYgKCFjYWNoZWQyKSByZXR1cm47XG4gICAgICAgIGNhY2hlZDIuY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrMikgPT4gY2FsbGJhY2syKGJvdW5kaW5nQ2xpZW50UmVjdCkpO1xuICAgICAgfSxcbiAgICAgIHsgc2tpcEluaXRpYWw6IHRydWUgfVxuICAgICk7XG4gICAgY2FjaGVkID0geyBkaXNjb25uZWN0OiBvYnNlcnZlci5kaXNjb25uZWN0LCBjYWxsYmFja3M6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkgfTtcbiAgfVxuICBjYWNoZWQuY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gIGZyYW1lUG9zaXRpb25PYnNlcnZlcnMuc2V0KGZyYW1lLCBjYWNoZWQpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNhY2hlZC5jYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICBpZiAoY2FjaGVkLmNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICBmcmFtZVBvc2l0aW9uT2JzZXJ2ZXJzLmRlbGV0ZShmcmFtZSk7XG4gICAgICBjYWNoZWQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVQYXJlbnRGcmFtZXMoZnJhbWVzLCBjYWxsYmFjaykge1xuICBjb25zdCBjbGVhbnVwID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICBjb25zdCByZW1vdmUgPSBhZGRGcmFtZUxpc3RlbmVyKGZyYW1lLCBjYWxsYmFjayk7XG4gICAgY2xlYW51cC5hZGQocmVtb3ZlKTtcbiAgfVxuICByZXR1cm4gKCkgPT4gY2xlYW51cC5mb3JFYWNoKChyZW1vdmUpID0+IHJlbW92ZSgpKTtcbn1cbmZ1bmN0aW9uIGFkZFNjcm9sbExpc3RlbmVyKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICBpZiAoIXNjcm9sbExpc3RlbmVycy5oYXMoZG9jKSkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgbGlzdGVuZXJzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwic2Nyb2xsXCIsXG4gICAgICAoZXZlbnQpID0+IGxpc3RlbmVyczIuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGV2ZW50KSksXG4gICAgICB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgIH1cbiAgICApO1xuICAgIHNjcm9sbExpc3RlbmVycy5zZXQoZG9jLCB7IGRpc2Nvbm5lY3Q6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMyIH0pO1xuICB9XG4gIGNvbnN0IHsgbGlzdGVuZXJzLCBkaXNjb25uZWN0IH0gPSAoX2EgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KGRvYykpICE9IG51bGwgPyBfYSA6IHt9O1xuICBpZiAoIWxpc3RlbmVycyB8fCAhZGlzY29ubmVjdCkgcmV0dXJuICgpID0+IHtcbiAgfTtcbiAgbGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgaWYgKGxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgICBzY3JvbGxMaXN0ZW5lcnMuZGVsZXRlKGRvYyk7XG4gICAgfVxuICB9O1xufVxudmFyIF9lbGVtZW50T2JzZXJ2ZXIsIF9kaXNjb25uZWN0ZWQyLCBfZnJhbWVzLCBfaGFuZGxlU2Nyb2xsO1xudmFyIEZyYW1lT2JzZXJ2ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZWxlbWVudE9ic2VydmVyKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Rpc2Nvbm5lY3RlZDIsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2ZyYW1lcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTY3JvbGwsIHRocm90dGxlKChldmVudCkgPT4ge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZGlzY29ubmVjdGVkMikpIHJldHVybjtcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0KSByZXR1cm47XG4gICAgICBpZiAoXCJjb250YWluc1wiIGluIGV2ZW50LnRhcmdldCAmJiB0eXBlb2YgZXZlbnQudGFyZ2V0LmNvbnRhaW5zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBfX3ByaXZhdGVHZXQodGhpcywgX2ZyYW1lcykpIHtcbiAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmNvbnRhaW5zKGZyYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhfX3ByaXZhdGVHZXQodGhpcywgX2VsZW1lbnRPYnNlcnZlcikuYm91bmRpbmdDbGllbnRSZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFRIUk9UVExFX0lOVEVSVkFMKSk7XG4gICAgY29uc3QgZnJhbWVzID0gZ2V0RnJhbWVFbGVtZW50cyhlbGVtZW50KTtcbiAgICBjb25zdCB1bm9ic2VydmVQYXJlbnRGcmFtZXMgPSBvYnNlcnZlUGFyZW50RnJhbWVzKGZyYW1lcywgY2FsbGJhY2spO1xuICAgIGNvbnN0IHJlbW92ZVNjcm9sbExpc3RlbmVyID0gYWRkU2Nyb2xsTGlzdGVuZXIoZWxlbWVudCwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTY3JvbGwpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2ZyYW1lcywgZnJhbWVzKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2VsZW1lbnRPYnNlcnZlciwgbmV3IFBvc2l0aW9uT2JzZXJ2ZXIoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9kaXNjb25uZWN0ZWQyKSkgcmV0dXJuO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9kaXNjb25uZWN0ZWQyLCB0cnVlKTtcbiAgICAgIHVub2JzZXJ2ZVBhcmVudEZyYW1lcygpO1xuICAgICAgcmVtb3ZlU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZWxlbWVudE9ic2VydmVyKS5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfVxufTtcbl9lbGVtZW50T2JzZXJ2ZXIgPSBuZXcgV2Vha01hcCgpO1xuX2Rpc2Nvbm5lY3RlZDIgPSBuZXcgV2Vha01hcCgpO1xuX2ZyYW1lcyA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU2Nyb2xsID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gc3JjL3V0aWxpdGllcy9wb3BvdmVyL3N1cHBvcnRzUG9wb3Zlci50c1xuZnVuY3Rpb24gc3VwcG9ydHNQb3BvdmVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwic2hvd1BvcG92ZXJcIiBpbiBlbGVtZW50ICYmIFwiaGlkZVBvcG92ZXJcIiBpbiBlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LnNob3dQb3BvdmVyID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGVsZW1lbnQuaGlkZVBvcG92ZXIgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9wb3BvdmVyL3Nob3dQb3BvdmVyLnRzXG5mdW5jdGlvbiBzaG93UG9wb3ZlcihlbGVtZW50KSB7XG4gIHRyeSB7XG4gICAgaWYgKHN1cHBvcnRzUG9wb3ZlcihlbGVtZW50KSAmJiBlbGVtZW50LmlzQ29ubmVjdGVkICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwicG9wb3ZlclwiKSAmJiAvLyBUaGlzIHNlbGVjdG9yIGNhbiB0aHJvdyBhbiBlcnJvciBpbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXRcbiAgICAhZWxlbWVudC5tYXRjaGVzKFwiOnBvcG92ZXItb3BlblwiKSkge1xuICAgICAgZWxlbWVudC5zaG93UG9wb3ZlcigpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3BvcG92ZXIvaGlkZVBvcG92ZXIudHNcbmZ1bmN0aW9uIGhpZGVQb3BvdmVyKGVsZW1lbnQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoc3VwcG9ydHNQb3BvdmVyKGVsZW1lbnQpICYmIGVsZW1lbnQuaXNDb25uZWN0ZWQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJwb3BvdmVyXCIpICYmIC8vIFRoaXMgc2VsZWN0b3IgY2FuIHRocm93IGFuIGVycm9yIGluIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgIGVsZW1lbnQubWF0Y2hlcyhcIjpwb3BvdmVyLW9wZW5cIikpIHtcbiAgICAgIGVsZW1lbnQuaGlkZVBvcG92ZXIoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxpdGllcy9zY3JvbGwvZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnRzXG5mdW5jdGlvbiBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICghY2FuVXNlRE9NIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBlbGVtZW50ID09PSBnZXREb2N1bWVudChlbGVtZW50KS5zY3JvbGxpbmdFbGVtZW50O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3Njcm9sbC9nZXRTY3JvbGxQb3NpdGlvbi50c1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgY29uc3Qgd2luZG93MiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlRWxlbWVudCk7XG4gIGNvbnN0IHJlY3QgPSBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChzY3JvbGxhYmxlRWxlbWVudCkgPyBnZXRWaWV3cG9ydEJvdW5kaW5nUmVjdGFuZ2xlKHNjcm9sbGFibGVFbGVtZW50KSA6IGdldEJvdW5kaW5nUmVjdGFuZ2xlKHNjcm9sbGFibGVFbGVtZW50KTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KHNjcm9sbGFibGVFbGVtZW50KSA/IHtcbiAgICBoZWlnaHQ6IHdpbmRvdzIuaW5uZXJIZWlnaHQsXG4gICAgd2lkdGg6IHdpbmRvdzIuaW5uZXJXaWR0aFxuICB9IDoge1xuICAgIGhlaWdodDogc2Nyb2xsYWJsZUVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgIHdpZHRoOiBzY3JvbGxhYmxlRWxlbWVudC5jbGllbnRXaWR0aFxuICB9O1xuICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICBjdXJyZW50OiB7XG4gICAgICB4OiBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfSxcbiAgICBtYXg6IHtcbiAgICAgIHg6IHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFdpZHRoIC0gZGltZW5zaW9ucy53aWR0aCxcbiAgICAgIHk6IHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbEhlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1RvcCA9IHBvc2l0aW9uLmN1cnJlbnQueSA8PSAwO1xuICBjb25zdCBpc0xlZnQgPSBwb3NpdGlvbi5jdXJyZW50LnggPD0gMDtcbiAgY29uc3QgaXNCb3R0b20gPSBwb3NpdGlvbi5jdXJyZW50LnkgPj0gcG9zaXRpb24ubWF4Lnk7XG4gIGNvbnN0IGlzUmlnaHQgPSBwb3NpdGlvbi5jdXJyZW50LnggPj0gcG9zaXRpb24ubWF4Lng7XG4gIHJldHVybiB7XG4gICAgcmVjdCxcbiAgICBwb3NpdGlvbixcbiAgICBpc1RvcCxcbiAgICBpc0xlZnQsXG4gICAgaXNCb3R0b20sXG4gICAgaXNSaWdodFxuICB9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3Njcm9sbC9jYW5TY3JvbGwudHNcbmZ1bmN0aW9uIGNhblNjcm9sbChzY3JvbGxhYmxlRWxlbWVudCwgYnkpIHtcbiAgY29uc3QgeyBpc1RvcCwgaXNCb3R0b20sIGlzTGVmdCwgaXNSaWdodCwgcG9zaXRpb24gfSA9IGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50KTtcbiAgY29uc3QgeyB4LCB5IH0gPSBieSAhPSBudWxsID8gYnkgOiB7IHg6IDAsIHk6IDAgfTtcbiAgY29uc3QgdG9wID0gIWlzVG9wICYmIHBvc2l0aW9uLmN1cnJlbnQueSArIHkgPiAwO1xuICBjb25zdCBib3R0b20gPSAhaXNCb3R0b20gJiYgcG9zaXRpb24uY3VycmVudC55ICsgeSA8IHBvc2l0aW9uLm1heC55O1xuICBjb25zdCBsZWZ0ID0gIWlzTGVmdCAmJiBwb3NpdGlvbi5jdXJyZW50LnggKyB4ID4gMDtcbiAgY29uc3QgcmlnaHQgPSAhaXNSaWdodCAmJiBwb3NpdGlvbi5jdXJyZW50LnggKyB4IDwgcG9zaXRpb24ubWF4Lng7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHg6IGxlZnQgfHwgcmlnaHQsXG4gICAgeTogdG9wIHx8IGJvdHRvbVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3NjaGVkdWxpbmcvc2NoZWR1bGVyLnRzXG52YXIgU2NoZWR1bGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY2hlZHVsZXI0KSB7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI0O1xuICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMudGFza3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMucmVzb2x2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmZsdXNoID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyB0YXNrcywgcmVzb2x2ZXJzIH0gPSB0aGlzO1xuICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRhc2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMucmVzb2x2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgICB0YXNrKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHJlc29sdmUgb2YgcmVzb2x2ZXJzKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHNjaGVkdWxlKHRhc2spIHtcbiAgICB0aGlzLnRhc2tzLmFkZCh0YXNrKTtcbiAgICBpZiAoIXRoaXMucGVuZGluZykge1xuICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyKHRoaXMuZmx1c2gpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHRoaXMucmVzb2x2ZXJzLmFkZChyZXNvbHZlKSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcigoY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy91dGlsaXRpZXMvc3R5bGVzL2dldENvbXB1dGVkU3R5bGVzLnRzXG52YXIgc2NoZWR1bGVyMiA9IG5ldyBTY2hlZHVsZXIoKGNhbGxiYWNrKSA9PiBzZXRUaW1lb3V0KGNhbGxiYWNrLCA1MCkpO1xudmFyIGNhY2hlZFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgY2xlYXIgPSBjYWNoZWRTdHlsZXMuY2xlYXIuYmluZChjYWNoZWRTdHlsZXMpO1xuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZXMoZWxlbWVudCwgY2FjaGVkID0gZmFsc2UpIHtcbiAgaWYgKCFjYWNoZWQpIHJldHVybiBjb21wdXRlU3R5bGVzKGVsZW1lbnQpO1xuICBsZXQgc3R5bGVzID0gY2FjaGVkU3R5bGVzLmdldChlbGVtZW50KTtcbiAgaWYgKHN0eWxlcykgcmV0dXJuIHN0eWxlcztcbiAgc3R5bGVzID0gY29tcHV0ZVN0eWxlcyhlbGVtZW50KTtcbiAgY2FjaGVkU3R5bGVzLnNldChlbGVtZW50LCBzdHlsZXMpO1xuICBzY2hlZHVsZXIyLnNjaGVkdWxlKGNsZWFyKTtcbiAgcmV0dXJuIHN0eWxlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvc2Nyb2xsL2lzRml4ZWQudHNcbmZ1bmN0aW9uIGlzRml4ZWQobm9kZSwgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVzKG5vZGUsIHRydWUpKSB7XG4gIHJldHVybiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIgfHwgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJzdGlja3lcIjtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9zY3JvbGwvaXNTY3JvbGxhYmxlLnRzXG5mdW5jdGlvbiBpc1Njcm9sbGFibGUoZWxlbWVudCwgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVzKGVsZW1lbnQsIHRydWUpKSB7XG4gIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLztcbiAgY29uc3QgcHJvcGVydGllcyA9IFtcIm92ZXJmbG93XCIsIFwib3ZlcmZsb3dYXCIsIFwib3ZlcmZsb3dZXCJdO1xuICByZXR1cm4gcHJvcGVydGllcy5zb21lKChwcm9wZXJ0eSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IG92ZXJmbG93UmVnZXgudGVzdCh2YWx1ZSkgOiBmYWxzZTtcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvc2Nyb2xsL2dldFNjcm9sbGFibGVBbmNlc3RvcnMudHNcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZXhjbHVkZUVsZW1lbnQ6IHRydWVcbn07XG5mdW5jdGlvbiBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKGVsZW1lbnQsIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICBjb25zdCB7IGxpbWl0LCBleGNsdWRlRWxlbWVudCB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2Nyb2xsUGFyZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIGZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUpIHtcbiAgICBpZiAobGltaXQgIT0gbnVsbCAmJiBzY3JvbGxQYXJlbnRzLnNpemUgPj0gbGltaXQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cbiAgICBpZiAoaXNEb2N1bWVudChub2RlKSAmJiBub2RlLnNjcm9sbGluZ0VsZW1lbnQgIT0gbnVsbCAmJiAhc2Nyb2xsUGFyZW50cy5oYXMobm9kZS5zY3JvbGxpbmdFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5hZGQobm9kZS5zY3JvbGxpbmdFbGVtZW50KTtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmIChpc1NWR0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUucGFyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG4gICAgaWYgKHNjcm9sbFBhcmVudHMuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVzKG5vZGUsIHRydWUpO1xuICAgIGlmIChleGNsdWRlRWxlbWVudCAmJiBub2RlID09PSBlbGVtZW50KSA7IGVsc2UgaWYgKGlzU2Nyb2xsYWJsZShub2RlLCBjb21wdXRlZFN0eWxlKSkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5hZGQobm9kZSk7XG4gICAgfVxuICAgIGlmIChpc0ZpeGVkKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSB7XG4gICAgICBjb25zdCB7IHNjcm9sbGluZ0VsZW1lbnQgfSA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChzY3JvbGxpbmdFbGVtZW50KSBzY3JvbGxQYXJlbnRzLmFkZChzY3JvbGxpbmdFbGVtZW50KTtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cbiAgICByZXR1cm4gZmluZFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgfVxuICByZXR1cm4gZmluZFNjcm9sbGFibGVBbmNlc3RvcnMoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXRGaXJzdFNjcm9sbGFibGVBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IFtmaXJzdFNjcm9sbGFibGVBbmNlc3Rvcl0gPSBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUsIHsgbGltaXQ6IDEgfSk7XG4gIHJldHVybiBmaXJzdFNjcm9sbGFibGVBbmNlc3RvciAhPSBudWxsID8gZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgOiBudWxsO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2ZyYW1lL2dldEZyYW1lVHJhbnNmb3JtLnRzXG5mdW5jdGlvbiBnZXRGcmFtZVRyYW5zZm9ybShlbCwgYm91bmRhcnkgPSB3aW5kb3cuZnJhbWVFbGVtZW50KSB7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc2NhbGVYOiAxLFxuICAgIHNjYWxlWTogMVxuICB9O1xuICBpZiAoIWVsKSByZXR1cm4gdHJhbnNmb3JtO1xuICBsZXQgZnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoZWwpO1xuICB3aGlsZSAoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUgPT09IGJvdW5kYXJ5KSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0YW5nbGUoZnJhbWUpO1xuICAgIGNvbnN0IHsgeDogc2NhbGVYLCB5OiBzY2FsZVkgfSA9IGdldFNjYWxlKGZyYW1lLCByZWN0KTtcbiAgICB0cmFuc2Zvcm0ueCA9IHRyYW5zZm9ybS54ICsgcmVjdC5sZWZ0O1xuICAgIHRyYW5zZm9ybS55ID0gdHJhbnNmb3JtLnkgKyByZWN0LnRvcDtcbiAgICB0cmFuc2Zvcm0uc2NhbGVYID0gdHJhbnNmb3JtLnNjYWxlWCAqIHNjYWxlWDtcbiAgICB0cmFuc2Zvcm0uc2NhbGVZID0gdHJhbnNmb3JtLnNjYWxlWSAqIHNjYWxlWTtcbiAgICBmcmFtZSA9IGdldEZyYW1lRWxlbWVudChmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cbmZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQsIGJvdW5kaW5nUmVjdGFuZ2xlID0gZ2V0Qm91bmRpbmdSZWN0YW5nbGUoZWxlbWVudCkpIHtcbiAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGJvdW5kaW5nUmVjdGFuZ2xlLndpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChib3VuZGluZ1JlY3RhbmdsZS5oZWlnaHQpO1xuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB3aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICB5OiBoZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodFxuICAgIH07XG4gIH1cbiAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZXMoZWxlbWVudCwgdHJ1ZSk7XG4gIHJldHVybiB7XG4gICAgeDogKHBhcnNlRmxvYXQoc3R5bGVzLndpZHRoKSB8fCB3aWR0aCkgLyB3aWR0aCxcbiAgICB5OiAocGFyc2VGbG9hdChzdHlsZXMuaGVpZ2h0KSB8fCBoZWlnaHQpIC8gaGVpZ2h0XG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvdHJhbnNmb3JtL3BhcnNlU2NhbGUudHNcbmZ1bmN0aW9uIHBhcnNlU2NhbGUoc2NhbGUpIHtcbiAgaWYgKHNjYWxlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IHNjYWxlLnNwbGl0KFwiIFwiKTtcbiAgY29uc3QgeCA9IHBhcnNlRmxvYXQodmFsdWVzWzBdKTtcbiAgY29uc3QgeSA9IHBhcnNlRmxvYXQodmFsdWVzWzFdKTtcbiAgaWYgKGlzTmFOKHgpICYmIGlzTmFOKHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBpc05hTih4KSA/IHkgOiB4LFxuICAgIHk6IGlzTmFOKHkpID8geCA6IHlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy90cmFuc2Zvcm0vcGFyc2VUcmFuc2xhdGUudHNcbmZ1bmN0aW9uIHBhcnNlVHJhbnNsYXRlKHRyYW5zbGF0ZSkge1xuICBpZiAodHJhbnNsYXRlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFt4LCB5LCB6ID0gXCIwXCJdID0gdHJhbnNsYXRlLnNwbGl0KFwiIFwiKTtcbiAgY29uc3Qgb3V0cHV0ID0geyB4OiBwYXJzZUZsb2F0KHgpLCB5OiBwYXJzZUZsb2F0KHkpLCB6OiBwYXJzZUludCh6LCAxMCkgfTtcbiAgaWYgKGlzTmFOKG91dHB1dC54KSAmJiBpc05hTihvdXRwdXQueSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGlzTmFOKG91dHB1dC54KSA/IDAgOiBvdXRwdXQueCxcbiAgICB5OiBpc05hTihvdXRwdXQueSkgPyAwIDogb3V0cHV0LnksXG4gICAgejogaXNOYU4ob3V0cHV0LnopID8gMCA6IG91dHB1dC56XG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvdHJhbnNmb3JtL3BhcnNlVHJhbnNmb3JtLnRzXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybShjb21wdXRlZFN0eWxlcykge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaTtcbiAgY29uc3QgeyBzY2FsZSwgdHJhbnNmb3JtLCB0cmFuc2xhdGUgfSA9IGNvbXB1dGVkU3R5bGVzO1xuICBjb25zdCBwYXJzZWRTY2FsZSA9IHBhcnNlU2NhbGUoc2NhbGUpO1xuICBjb25zdCBwYXJzZWRUcmFuc2xhdGUgPSBwYXJzZVRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xuICBjb25zdCBwYXJzZWRNYXRyaXggPSBwYXJzZVRyYW5zZm9ybU1hdHJpeCh0cmFuc2Zvcm0pO1xuICBpZiAoIXBhcnNlZE1hdHJpeCAmJiAhcGFyc2VkU2NhbGUgJiYgIXBhcnNlZFRyYW5zbGF0ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRTY2FsZSA9IHtcbiAgICB4OiAoX2EgPSBwYXJzZWRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkU2NhbGUueCkgIT0gbnVsbCA/IF9hIDogMSxcbiAgICB5OiAoX2IgPSBwYXJzZWRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkU2NhbGUueSkgIT0gbnVsbCA/IF9iIDogMVxuICB9O1xuICBjb25zdCBub3JtYWxpemVkVHJhbnNsYXRlID0ge1xuICAgIHg6IChfYyA9IHBhcnNlZFRyYW5zbGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkVHJhbnNsYXRlLngpICE9IG51bGwgPyBfYyA6IDAsXG4gICAgeTogKF9kID0gcGFyc2VkVHJhbnNsYXRlID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRUcmFuc2xhdGUueSkgIT0gbnVsbCA/IF9kIDogMFxuICB9O1xuICBjb25zdCBub3JtYWxpemVkTWF0cml4ID0ge1xuICAgIHg6IChfZSA9IHBhcnNlZE1hdHJpeCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkTWF0cml4LngpICE9IG51bGwgPyBfZSA6IDAsXG4gICAgeTogKF9mID0gcGFyc2VkTWF0cml4ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRNYXRyaXgueSkgIT0gbnVsbCA/IF9mIDogMCxcbiAgICBzY2FsZVg6IChfZyA9IHBhcnNlZE1hdHJpeCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkTWF0cml4LnNjYWxlWCkgIT0gbnVsbCA/IF9nIDogMSxcbiAgICBzY2FsZVk6IChfaCA9IHBhcnNlZE1hdHJpeCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkTWF0cml4LnNjYWxlWSkgIT0gbnVsbCA/IF9oIDogMVxuICB9O1xuICByZXR1cm4ge1xuICAgIHg6IG5vcm1hbGl6ZWRUcmFuc2xhdGUueCArIG5vcm1hbGl6ZWRNYXRyaXgueCxcbiAgICB5OiBub3JtYWxpemVkVHJhbnNsYXRlLnkgKyBub3JtYWxpemVkTWF0cml4LnksXG4gICAgejogKF9pID0gcGFyc2VkVHJhbnNsYXRlID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRUcmFuc2xhdGUueikgIT0gbnVsbCA/IF9pIDogMCxcbiAgICBzY2FsZVg6IG5vcm1hbGl6ZWRTY2FsZS54ICogbm9ybWFsaXplZE1hdHJpeC5zY2FsZVgsXG4gICAgc2NhbGVZOiBub3JtYWxpemVkU2NhbGUueSAqIG5vcm1hbGl6ZWRNYXRyaXguc2NhbGVZXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybU1hdHJpeCh0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybS5zdGFydHNXaXRoKFwibWF0cml4M2QoXCIpKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtQXJyYXkgPSB0cmFuc2Zvcm0uc2xpY2UoOSwgLTEpLnNwbGl0KC8sIC8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiArdHJhbnNmb3JtQXJyYXlbMTJdLFxuICAgICAgeTogK3RyYW5zZm9ybUFycmF5WzEzXSxcbiAgICAgIHNjYWxlWDogK3RyYW5zZm9ybUFycmF5WzBdLFxuICAgICAgc2NhbGVZOiArdHJhbnNmb3JtQXJyYXlbNV1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHRyYW5zZm9ybS5zdGFydHNXaXRoKFwibWF0cml4KFwiKSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybUFycmF5ID0gdHJhbnNmb3JtLnNsaWNlKDcsIC0xKS5zcGxpdCgvLCAvKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogK3RyYW5zZm9ybUFycmF5WzRdLFxuICAgICAgeTogK3RyYW5zZm9ybUFycmF5WzVdLFxuICAgICAgc2NhbGVYOiArdHJhbnNmb3JtQXJyYXlbMF0sXG4gICAgICBzY2FsZVk6ICt0cmFuc2Zvcm1BcnJheVszXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvc2Nyb2xsL2RldGVjdFNjcm9sbEludGVudC50c1xudmFyIFNjcm9sbERpcmVjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKFNjcm9sbERpcmVjdGlvbjIpID0+IHtcbiAgU2Nyb2xsRGlyZWN0aW9uMltTY3JvbGxEaXJlY3Rpb24yW1wiSWRsZVwiXSA9IDBdID0gXCJJZGxlXCI7XG4gIFNjcm9sbERpcmVjdGlvbjJbU2Nyb2xsRGlyZWN0aW9uMltcIkZvcndhcmRcIl0gPSAxXSA9IFwiRm9yd2FyZFwiO1xuICBTY3JvbGxEaXJlY3Rpb24yW1Njcm9sbERpcmVjdGlvbjJbXCJSZXZlcnNlXCJdID0gLTFdID0gXCJSZXZlcnNlXCI7XG4gIHJldHVybiBTY3JvbGxEaXJlY3Rpb24yO1xufSkoU2Nyb2xsRGlyZWN0aW9uIHx8IHt9KTtcbnZhciBkZWZhdWx0VGhyZXNob2xkID0ge1xuICB4OiAwLjIsXG4gIHk6IDAuMlxufTtcbnZhciBkZWZhdWx0VG9sZXJhbmNlID0ge1xuICB4OiAxMCxcbiAgeTogMTBcbn07XG5mdW5jdGlvbiBkZXRlY3RTY3JvbGxJbnRlbnQoc2Nyb2xsYWJsZUVsZW1lbnQsIGNvb3JkaW5hdGVzLCBpbnRlbnQsIGFjY2VsZXJhdGlvbiA9IDI1LCB0aHJlc2hvbGRQZXJjZW50YWdlID0gZGVmYXVsdFRocmVzaG9sZCwgdG9sZXJhbmNlID0gZGVmYXVsdFRvbGVyYW5jZSkge1xuICBjb25zdCB7IHgsIHkgfSA9IGNvb3JkaW5hdGVzO1xuICBjb25zdCB7IHJlY3QsIGlzVG9wLCBpc0JvdHRvbSwgaXNMZWZ0LCBpc1JpZ2h0IH0gPSBnZXRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlRWxlbWVudCk7XG4gIGNvbnN0IGZyYW1lVHJhbnNmb3JtID0gZ2V0RnJhbWVUcmFuc2Zvcm0oc2Nyb2xsYWJsZUVsZW1lbnQpO1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGVzKHNjcm9sbGFibGVFbGVtZW50LCB0cnVlKTtcbiAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0oY29tcHV0ZWRTdHlsZXMpO1xuICBjb25zdCBpc1hBeGlzSW52ZXJ0ZWQgPSBwYXJzZWRUcmFuc2Zvcm0gIT09IG51bGwgPyAocGFyc2VkVHJhbnNmb3JtID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRUcmFuc2Zvcm0uc2NhbGVYKSA8IDAgOiBmYWxzZTtcbiAgY29uc3QgaXNZQXhpc0ludmVydGVkID0gcGFyc2VkVHJhbnNmb3JtICE9PSBudWxsID8gKHBhcnNlZFRyYW5zZm9ybSA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkVHJhbnNmb3JtLnNjYWxlWSkgPCAwIDogZmFsc2U7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5lclJlY3QgPSBuZXcgUmVjdGFuZ2xlKFxuICAgIHJlY3QubGVmdCAqIGZyYW1lVHJhbnNmb3JtLnNjYWxlWCArIGZyYW1lVHJhbnNmb3JtLngsXG4gICAgcmVjdC50b3AgKiBmcmFtZVRyYW5zZm9ybS5zY2FsZVkgKyBmcmFtZVRyYW5zZm9ybS55LFxuICAgIHJlY3Qud2lkdGggKiBmcmFtZVRyYW5zZm9ybS5zY2FsZVgsXG4gICAgcmVjdC5oZWlnaHQgKiBmcmFtZVRyYW5zZm9ybS5zY2FsZVlcbiAgKTtcbiAgY29uc3QgZGlyZWN0aW9uID0ge1xuICAgIHg6IDAgLyogSWRsZSAqLyxcbiAgICB5OiAwIC8qIElkbGUgKi9cbiAgfTtcbiAgY29uc3Qgc3BlZWQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGNvbnN0IHRocmVzaG9sZDIgPSB7XG4gICAgaGVpZ2h0OiBzY3JvbGxDb250YWluZXJSZWN0LmhlaWdodCAqIHRocmVzaG9sZFBlcmNlbnRhZ2UueSxcbiAgICB3aWR0aDogc2Nyb2xsQ29udGFpbmVyUmVjdC53aWR0aCAqIHRocmVzaG9sZFBlcmNlbnRhZ2UueFxuICB9O1xuICBpZiAoKCFpc1RvcCB8fCBpc1lBeGlzSW52ZXJ0ZWQgJiYgIWlzQm90dG9tKSAmJiB5IDw9IHNjcm9sbENvbnRhaW5lclJlY3QudG9wICsgdGhyZXNob2xkMi5oZWlnaHQgJiYgKGludGVudCA9PSBudWxsID8gdm9pZCAwIDogaW50ZW50LnkpICE9PSAxIC8qIEZvcndhcmQgKi8gJiYgeCA+PSBzY3JvbGxDb250YWluZXJSZWN0LmxlZnQgLSB0b2xlcmFuY2UueCAmJiB4IDw9IHNjcm9sbENvbnRhaW5lclJlY3QucmlnaHQgKyB0b2xlcmFuY2UueCkge1xuICAgIGRpcmVjdGlvbi55ID0gaXNZQXhpc0ludmVydGVkID8gMSAvKiBGb3J3YXJkICovIDogLTEgLyogUmV2ZXJzZSAqLztcbiAgICBzcGVlZC55ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoXG4gICAgICAoc2Nyb2xsQ29udGFpbmVyUmVjdC50b3AgKyB0aHJlc2hvbGQyLmhlaWdodCAtIHkpIC8gdGhyZXNob2xkMi5oZWlnaHRcbiAgICApO1xuICB9IGVsc2UgaWYgKCghaXNCb3R0b20gfHwgaXNZQXhpc0ludmVydGVkICYmICFpc1RvcCkgJiYgeSA+PSBzY3JvbGxDb250YWluZXJSZWN0LmJvdHRvbSAtIHRocmVzaG9sZDIuaGVpZ2h0ICYmIChpbnRlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGludGVudC55KSAhPT0gLTEgLyogUmV2ZXJzZSAqLyAmJiB4ID49IHNjcm9sbENvbnRhaW5lclJlY3QubGVmdCAtIHRvbGVyYW5jZS54ICYmIHggPD0gc2Nyb2xsQ29udGFpbmVyUmVjdC5yaWdodCArIHRvbGVyYW5jZS54KSB7XG4gICAgZGlyZWN0aW9uLnkgPSBpc1lBeGlzSW52ZXJ0ZWQgPyAtMSAvKiBSZXZlcnNlICovIDogMSAvKiBGb3J3YXJkICovO1xuICAgIHNwZWVkLnkgPSBhY2NlbGVyYXRpb24gKiBNYXRoLmFicyhcbiAgICAgIChzY3JvbGxDb250YWluZXJSZWN0LmJvdHRvbSAtIHRocmVzaG9sZDIuaGVpZ2h0IC0geSkgLyB0aHJlc2hvbGQyLmhlaWdodFxuICAgICk7XG4gIH1cbiAgaWYgKCghaXNSaWdodCB8fCBpc1hBeGlzSW52ZXJ0ZWQgJiYgIWlzTGVmdCkgJiYgeCA+PSBzY3JvbGxDb250YWluZXJSZWN0LnJpZ2h0IC0gdGhyZXNob2xkMi53aWR0aCAmJiAoaW50ZW50ID09IG51bGwgPyB2b2lkIDAgOiBpbnRlbnQueCkgIT09IC0xIC8qIFJldmVyc2UgKi8gJiYgeSA+PSBzY3JvbGxDb250YWluZXJSZWN0LnRvcCAtIHRvbGVyYW5jZS55ICYmIHkgPD0gc2Nyb2xsQ29udGFpbmVyUmVjdC5ib3R0b20gKyB0b2xlcmFuY2UueSkge1xuICAgIGRpcmVjdGlvbi54ID0gaXNYQXhpc0ludmVydGVkID8gLTEgLyogUmV2ZXJzZSAqLyA6IDEgLyogRm9yd2FyZCAqLztcbiAgICBzcGVlZC54ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoXG4gICAgICAoc2Nyb2xsQ29udGFpbmVyUmVjdC5yaWdodCAtIHRocmVzaG9sZDIud2lkdGggLSB4KSAvIHRocmVzaG9sZDIud2lkdGhcbiAgICApO1xuICB9IGVsc2UgaWYgKCghaXNMZWZ0IHx8IGlzWEF4aXNJbnZlcnRlZCAmJiAhaXNSaWdodCkgJiYgeCA8PSBzY3JvbGxDb250YWluZXJSZWN0LmxlZnQgKyB0aHJlc2hvbGQyLndpZHRoICYmIChpbnRlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGludGVudC54KSAhPT0gMSAvKiBGb3J3YXJkICovICYmIHkgPj0gc2Nyb2xsQ29udGFpbmVyUmVjdC50b3AgLSB0b2xlcmFuY2UueSAmJiB5IDw9IHNjcm9sbENvbnRhaW5lclJlY3QuYm90dG9tICsgdG9sZXJhbmNlLnkpIHtcbiAgICBkaXJlY3Rpb24ueCA9IGlzWEF4aXNJbnZlcnRlZCA/IDEgLyogRm9yd2FyZCAqLyA6IC0xIC8qIFJldmVyc2UgKi87XG4gICAgc3BlZWQueCA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKFxuICAgICAgKHNjcm9sbENvbnRhaW5lclJlY3QubGVmdCArIHRocmVzaG9sZDIud2lkdGggLSB4KSAvIHRocmVzaG9sZDIud2lkdGhcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGlyZWN0aW9uLFxuICAgIHNwZWVkXG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvc2Nyb2xsL3Njcm9sbEludG9WaWV3SWZOZWVkZWQudHNcbmZ1bmN0aW9uIHN1cHBvcnRzU2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlbGVtZW50KSB7XG4gIHJldHVybiBcInNjcm9sbEludG9WaWV3SWZOZWVkZWRcIiBpbiBlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LnNjcm9sbEludG9WaWV3SWZOZWVkZWQgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWwsIGNlbnRlcklmTmVlZGVkID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzU2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlbCkpIHtcbiAgICBlbC5zY3JvbGxJbnRvVmlld0lmTmVlZGVkKGNlbnRlcklmTmVlZGVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsKSkge1xuICAgIHJldHVybiBlbC5zY3JvbGxJbnRvVmlldygpO1xuICB9XG4gIHZhciBwYXJlbnQgPSBnZXRGaXJzdFNjcm9sbGFibGVBbmNlc3RvcihlbCk7XG4gIGlmICghaXNIVE1MRWxlbWVudChwYXJlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcmVudENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlcyhwYXJlbnQsIHRydWUpLCBwYXJlbnRCb3JkZXJUb3BXaWR0aCA9IHBhcnNlSW50KFxuICAgIHBhcmVudENvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci10b3Atd2lkdGhcIilcbiAgKSwgcGFyZW50Qm9yZGVyTGVmdFdpZHRoID0gcGFyc2VJbnQoXG4gICAgcGFyZW50Q29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLWxlZnQtd2lkdGhcIilcbiAgKSwgb3ZlclRvcCA9IGVsLm9mZnNldFRvcCAtIHBhcmVudC5vZmZzZXRUb3AgPCBwYXJlbnQuc2Nyb2xsVG9wLCBvdmVyQm90dG9tID0gZWwub2Zmc2V0VG9wIC0gcGFyZW50Lm9mZnNldFRvcCArIGVsLmNsaWVudEhlaWdodCAtIHBhcmVudEJvcmRlclRvcFdpZHRoID4gcGFyZW50LnNjcm9sbFRvcCArIHBhcmVudC5jbGllbnRIZWlnaHQsIG92ZXJMZWZ0ID0gZWwub2Zmc2V0TGVmdCAtIHBhcmVudC5vZmZzZXRMZWZ0IDwgcGFyZW50LnNjcm9sbExlZnQsIG92ZXJSaWdodCA9IGVsLm9mZnNldExlZnQgLSBwYXJlbnQub2Zmc2V0TGVmdCArIGVsLmNsaWVudFdpZHRoIC0gcGFyZW50Qm9yZGVyTGVmdFdpZHRoID4gcGFyZW50LnNjcm9sbExlZnQgKyBwYXJlbnQuY2xpZW50V2lkdGgsIGFsaWduV2l0aFRvcCA9IG92ZXJUb3AgJiYgIW92ZXJCb3R0b207XG4gIGlmICgob3ZlclRvcCB8fCBvdmVyQm90dG9tKSAmJiBjZW50ZXJJZk5lZWRlZCkge1xuICAgIHBhcmVudC5zY3JvbGxUb3AgPSBlbC5vZmZzZXRUb3AgLSBwYXJlbnQub2Zmc2V0VG9wIC0gcGFyZW50LmNsaWVudEhlaWdodCAvIDIgLSBwYXJlbnRCb3JkZXJUb3BXaWR0aCArIGVsLmNsaWVudEhlaWdodCAvIDI7XG4gIH1cbiAgaWYgKChvdmVyTGVmdCB8fCBvdmVyUmlnaHQpICYmIGNlbnRlcklmTmVlZGVkKSB7XG4gICAgcGFyZW50LnNjcm9sbExlZnQgPSBlbC5vZmZzZXRMZWZ0IC0gcGFyZW50Lm9mZnNldExlZnQgLSBwYXJlbnQuY2xpZW50V2lkdGggLyAyIC0gcGFyZW50Qm9yZGVyTGVmdFdpZHRoICsgZWwuY2xpZW50V2lkdGggLyAyO1xuICB9XG4gIGlmICgob3ZlclRvcCB8fCBvdmVyQm90dG9tIHx8IG92ZXJMZWZ0IHx8IG92ZXJSaWdodCkgJiYgIWNlbnRlcklmTmVlZGVkKSB7XG4gICAgZWwuc2Nyb2xsSW50b1ZpZXcoYWxpZ25XaXRoVG9wKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3RyYW5zZm9ybS9hcHBseVRyYW5zZm9ybS50c1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0ocmVjdCwgcGFyc2VkVHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgY29uc3QgeyBzY2FsZVgsIHNjYWxlWSwgeDogdHJhbnNsYXRlWCwgeTogdHJhbnNsYXRlWSB9ID0gcGFyc2VkVHJhbnNmb3JtO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0ICsgdHJhbnNsYXRlWCArICgxIC0gc2NhbGVYKSAqIHBhcnNlRmxvYXQodHJhbnNmb3JtT3JpZ2luKTtcbiAgY29uc3QgeSA9IHJlY3QudG9wICsgdHJhbnNsYXRlWSArICgxIC0gc2NhbGVZKSAqIHBhcnNlRmxvYXQodHJhbnNmb3JtT3JpZ2luLnNsaWNlKHRyYW5zZm9ybU9yaWdpbi5pbmRleE9mKFwiIFwiKSArIDEpKTtcbiAgY29uc3QgdyA9IHNjYWxlWCA/IHJlY3Qud2lkdGggKiBzY2FsZVggOiByZWN0LndpZHRoO1xuICBjb25zdCBoID0gc2NhbGVZID8gcmVjdC5oZWlnaHQgKiBzY2FsZVkgOiByZWN0LmhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgdyxcbiAgICBib3R0b206IHkgKyBoLFxuICAgIGxlZnQ6IHhcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy90cmFuc2Zvcm0vaW52ZXJzZVRyYW5zZm9ybS50c1xuZnVuY3Rpb24gaW52ZXJzZVRyYW5zZm9ybShyZWN0LCBwYXJzZWRUcmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbikge1xuICBjb25zdCB7IHNjYWxlWCwgc2NhbGVZLCB4OiB0cmFuc2xhdGVYLCB5OiB0cmFuc2xhdGVZIH0gPSBwYXJzZWRUcmFuc2Zvcm07XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgLSB0cmFuc2xhdGVYIC0gKDEgLSBzY2FsZVgpICogcGFyc2VGbG9hdCh0cmFuc2Zvcm1PcmlnaW4pO1xuICBjb25zdCB5ID0gcmVjdC50b3AgLSB0cmFuc2xhdGVZIC0gKDEgLSBzY2FsZVkpICogcGFyc2VGbG9hdCh0cmFuc2Zvcm1PcmlnaW4uc2xpY2UodHJhbnNmb3JtT3JpZ2luLmluZGV4T2YoXCIgXCIpICsgMSkpO1xuICBjb25zdCB3ID0gc2NhbGVYID8gcmVjdC53aWR0aCAvIHNjYWxlWCA6IHJlY3Qud2lkdGg7XG4gIGNvbnN0IGggPSBzY2FsZVkgPyByZWN0LmhlaWdodCAvIHNjYWxlWSA6IHJlY3QuaGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3LFxuICAgIGJvdHRvbTogeSArIGgsXG4gICAgbGVmdDogeFxuICB9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3RyYW5zZm9ybS9hbmltYXRlVHJhbnNmb3JtLnRzXG5mdW5jdGlvbiBhbmltYXRlVHJhbnNmb3JtKHsgZWxlbWVudCwga2V5ZnJhbWVzLCBvcHRpb25zIH0pIHtcbiAgcmV0dXJuIGVsZW1lbnQuYW5pbWF0ZShrZXlmcmFtZXMsIG9wdGlvbnMpLmZpbmlzaGVkO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3RyYW5zZm9ybS9jb21wdXRlVHJhbnNsYXRlLnRzXG5mdW5jdGlvbiBjb21wdXRlVHJhbnNsYXRlKGVsZW1lbnQsIHRyYW5zbGF0ZSA9IGdldENvbXB1dGVkU3R5bGVzKGVsZW1lbnQpLnRyYW5zbGF0ZSwgcHJvamVjdGVkID0gdHJ1ZSkge1xuICBpZiAocHJvamVjdGVkKSB7XG4gICAgY29uc3Qga2V5ZnJhbWUgPSBnZXRGaW5hbEtleWZyYW1lKFxuICAgICAgZWxlbWVudCxcbiAgICAgIChrZXlmcmFtZTIpID0+IFwidHJhbnNsYXRlXCIgaW4ga2V5ZnJhbWUyXG4gICAgKTtcbiAgICBpZiAoa2V5ZnJhbWUpIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNsYXRlOiB0cmFuc2xhdGUyID0gXCJcIiB9ID0ga2V5ZnJhbWVbMF07XG4gICAgICBpZiAodHlwZW9mIHRyYW5zbGF0ZTIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgZmluYWxUcmFuc2xhdGUgPSBwYXJzZVRyYW5zbGF0ZSh0cmFuc2xhdGUyKTtcbiAgICAgICAgaWYgKGZpbmFsVHJhbnNsYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmFsVHJhbnNsYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0cmFuc2xhdGUpIHtcbiAgICBjb25zdCBmaW5hbFRyYW5zbGF0ZSA9IHBhcnNlVHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gICAgaWYgKGZpbmFsVHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm4gZmluYWxUcmFuc2xhdGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9hbmltYXRpb25zL2ZvcmNlRmluaXNoQW5pbWF0aW9ucy50c1xudmFyIHNjaGVkdWxlcjMgPSBuZXcgU2NoZWR1bGVyKChjYWxsYmFjaykgPT4gc2V0VGltZW91dChjYWxsYmFjaywgMCkpO1xudmFyIGFuaW1hdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIGNsZWFyMiA9IGFuaW1hdGlvbnMuY2xlYXIuYmluZChhbmltYXRpb25zKTtcbmZ1bmN0aW9uIGdldERvY3VtZW50QW5pbWF0aW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGRvY3VtZW50MiA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGV0IGRvY3VtZW50QW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMuZ2V0KGRvY3VtZW50Mik7XG4gIGlmIChkb2N1bWVudEFuaW1hdGlvbnMpIHJldHVybiBkb2N1bWVudEFuaW1hdGlvbnM7XG4gIGRvY3VtZW50QW5pbWF0aW9ucyA9IGRvY3VtZW50Mi5nZXRBbmltYXRpb25zKCk7XG4gIGFuaW1hdGlvbnMuc2V0KGRvY3VtZW50MiwgZG9jdW1lbnRBbmltYXRpb25zKTtcbiAgc2NoZWR1bGVyMy5zY2hlZHVsZShjbGVhcjIpO1xuICBjb25zdCBlbGVtZW50QW5pbWF0aW9ucyA9IGRvY3VtZW50QW5pbWF0aW9ucy5maWx0ZXIoXG4gICAgKGFuaW1hdGlvbikgPT4gaXNLZXlmcmFtZUVmZmVjdChhbmltYXRpb24uZWZmZWN0KSAmJiBhbmltYXRpb24uZWZmZWN0LnRhcmdldCA9PT0gZWxlbWVudFxuICApO1xuICBhbmltYXRpb25zLnNldChlbGVtZW50LCBlbGVtZW50QW5pbWF0aW9ucyk7XG4gIHJldHVybiBkb2N1bWVudEFuaW1hdGlvbnM7XG59XG5mdW5jdGlvbiBmb3JjZUZpbmlzaEFuaW1hdGlvbnMoZWxlbWVudCwgb3B0aW9ucykge1xuICBjb25zdCBhbmltYXRpb25zMiA9IGdldERvY3VtZW50QW5pbWF0aW9ucyhlbGVtZW50KS5maWx0ZXIoKGFuaW1hdGlvbikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGlzS2V5ZnJhbWVFZmZlY3QoYW5pbWF0aW9uLmVmZmVjdCkpIHtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBhbmltYXRpb24uZWZmZWN0O1xuICAgICAgY29uc3QgaXNWYWxpZFRhcmdldCA9IChfYiA9IHRhcmdldCAmJiAoKF9hID0gb3B0aW9ucy5pc1ZhbGlkVGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB0YXJnZXQpKSkgIT0gbnVsbCA/IF9iIDogdHJ1ZTtcbiAgICAgIGlmIChpc1ZhbGlkVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24uZWZmZWN0LmdldEtleWZyYW1lcygpLnNvbWUoKGtleWZyYW1lKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBvcHRpb25zLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChrZXlmcmFtZVtwcm9wZXJ0eV0pIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KS5tYXAoKGFuaW1hdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgZWZmZWN0LCBjdXJyZW50VGltZSB9ID0gYW5pbWF0aW9uO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZWZmZWN0ID09IG51bGwgPyB2b2lkIDAgOiBlZmZlY3QuZ2V0Q29tcHV0ZWRUaW1pbmcoKS5kdXJhdGlvbjtcbiAgICBpZiAoYW5pbWF0aW9uLnBlbmRpbmcgfHwgYW5pbWF0aW9uLnBsYXlTdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PSBcIm51bWJlclwiICYmIHR5cGVvZiBjdXJyZW50VGltZSA9PSBcIm51bWJlclwiICYmIGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgIGFuaW1hdGlvbi5jdXJyZW50VGltZSA9IGR1cmF0aW9uO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgYW5pbWF0aW9uLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGlmIChhbmltYXRpb25zMi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICgpID0+IGFuaW1hdGlvbnMyLmZvckVhY2goKHJlc2V0KSA9PiByZXNldCA9PSBudWxsID8gdm9pZCAwIDogcmVzZXQoKSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxpdGllcy9zaGFwZXMvRE9NUmVjdGFuZ2xlLnRzXG52YXIgRE9NUmVjdGFuZ2xlID0gY2xhc3MgZXh0ZW5kcyBSZWN0YW5nbGUge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVUcmFuc2Zvcm0gPSBnZXRGcmFtZVRyYW5zZm9ybShlbGVtZW50KSxcbiAgICAgIGlnbm9yZVRyYW5zZm9ybXMsXG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBnZXRCb3VuZGluZ1JlY3RhbmdsZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlc2V0QW5pbWF0aW9ucyA9IGZvcmNlRmluaXNoQW5pbWF0aW9ucyhlbGVtZW50LCB7XG4gICAgICBwcm9wZXJ0aWVzOiBbXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGVcIiwgXCJzY2FsZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICAgICAgaXNWYWxpZFRhcmdldDogKHRhcmdldCkgPT4gKHRhcmdldCAhPT0gZWxlbWVudCB8fCBpc1NhZmFyaSgpKSAmJiB0YXJnZXQuY29udGFpbnMoZWxlbWVudClcbiAgICB9KTtcbiAgICBjb25zdCBib3VuZGluZ1JlY3RhbmdsZSA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgICBsZXQgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IGJvdW5kaW5nUmVjdGFuZ2xlO1xuICAgIGxldCB1cGRhdGVkO1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZXMoZWxlbWVudCk7XG4gICAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0oY29tcHV0ZWRTdHlsZXMpO1xuICAgIGNvbnN0IHNjYWxlID0ge1xuICAgICAgeDogKF9hID0gcGFyc2VkVHJhbnNmb3JtID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRUcmFuc2Zvcm0uc2NhbGVYKSAhPSBudWxsID8gX2EgOiAxLFxuICAgICAgeTogKF9iID0gcGFyc2VkVHJhbnNmb3JtID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRUcmFuc2Zvcm0uc2NhbGVZKSAhPSBudWxsID8gX2IgOiAxXG4gICAgfTtcbiAgICBjb25zdCBwcm9qZWN0ZWRUcmFuc2Zvcm0gPSBnZXRQcm9qZWN0ZWRUcmFuc2Zvcm0oZWxlbWVudCwgY29tcHV0ZWRTdHlsZXMpO1xuICAgIHJlc2V0QW5pbWF0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcmVzZXRBbmltYXRpb25zKCk7XG4gICAgaWYgKHBhcnNlZFRyYW5zZm9ybSkge1xuICAgICAgdXBkYXRlZCA9IGludmVyc2VUcmFuc2Zvcm0oXG4gICAgICAgIGJvdW5kaW5nUmVjdGFuZ2xlLFxuICAgICAgICBwYXJzZWRUcmFuc2Zvcm0sXG4gICAgICAgIGNvbXB1dGVkU3R5bGVzLnRyYW5zZm9ybU9yaWdpblxuICAgICAgKTtcbiAgICAgIGlmIChpZ25vcmVUcmFuc2Zvcm1zIHx8IHByb2plY3RlZFRyYW5zZm9ybSkge1xuICAgICAgICB0b3AgPSB1cGRhdGVkLnRvcDtcbiAgICAgICAgbGVmdCA9IHVwZGF0ZWQubGVmdDtcbiAgICAgICAgd2lkdGggPSB1cGRhdGVkLndpZHRoO1xuICAgICAgICBoZWlnaHQgPSB1cGRhdGVkLmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50cmluc2ljID0ge1xuICAgICAgd2lkdGg6IChfYyA9IHVwZGF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IHVwZGF0ZWQud2lkdGgpICE9IG51bGwgPyBfYyA6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiAoX2QgPSB1cGRhdGVkID09IG51bGwgPyB2b2lkIDAgOiB1cGRhdGVkLmhlaWdodCkgIT0gbnVsbCA/IF9kIDogaGVpZ2h0XG4gICAgfTtcbiAgICBpZiAocHJvamVjdGVkVHJhbnNmb3JtICYmICFpZ25vcmVUcmFuc2Zvcm1zICYmIHVwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IHByb2plY3RlZCA9IGFwcGx5VHJhbnNmb3JtKFxuICAgICAgICB1cGRhdGVkLFxuICAgICAgICBwcm9qZWN0ZWRUcmFuc2Zvcm0sXG4gICAgICAgIGNvbXB1dGVkU3R5bGVzLnRyYW5zZm9ybU9yaWdpblxuICAgICAgKTtcbiAgICAgIHRvcCA9IHByb2plY3RlZC50b3A7XG4gICAgICBsZWZ0ID0gcHJvamVjdGVkLmxlZnQ7XG4gICAgICB3aWR0aCA9IHByb2plY3RlZC53aWR0aDtcbiAgICAgIGhlaWdodCA9IHByb2plY3RlZC5oZWlnaHQ7XG4gICAgICBzY2FsZS54ID0gcHJvamVjdGVkVHJhbnNmb3JtLnNjYWxlWDtcbiAgICAgIHNjYWxlLnkgPSBwcm9qZWN0ZWRUcmFuc2Zvcm0uc2NhbGVZO1xuICAgIH1cbiAgICBpZiAoZnJhbWVUcmFuc2Zvcm0pIHtcbiAgICAgIGlmICghaWdub3JlVHJhbnNmb3Jtcykge1xuICAgICAgICBsZWZ0ICo9IGZyYW1lVHJhbnNmb3JtLnNjYWxlWDtcbiAgICAgICAgd2lkdGggKj0gZnJhbWVUcmFuc2Zvcm0uc2NhbGVYO1xuICAgICAgICB0b3AgKj0gZnJhbWVUcmFuc2Zvcm0uc2NhbGVZO1xuICAgICAgICBoZWlnaHQgKj0gZnJhbWVUcmFuc2Zvcm0uc2NhbGVZO1xuICAgICAgfVxuICAgICAgbGVmdCArPSBmcmFtZVRyYW5zZm9ybS54O1xuICAgICAgdG9wICs9IGZyYW1lVHJhbnNmb3JtLnk7XG4gICAgfVxuICAgIHN1cGVyKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMuaW50cmluc2ljV2lkdGggPSBpbnRyaW5zaWMud2lkdGg7XG4gICAgdGhpcy5pbnRyaW5zaWNIZWlnaHQgPSBpbnRyaW5zaWMuaGVpZ2h0O1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0UHJvamVjdGVkVHJhbnNmb3JtKGVsZW1lbnQsIGNvbXB1dGVkU3R5bGVzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgYW5pbWF0aW9uczIgPSBlbGVtZW50LmdldEFuaW1hdGlvbnMoKTtcbiAgbGV0IHByb2plY3RlZFRyYW5zZm9ybSA9IG51bGw7XG4gIGlmICghYW5pbWF0aW9uczIubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgZm9yIChjb25zdCBhbmltYXRpb24gb2YgYW5pbWF0aW9uczIpIHtcbiAgICBpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gXCJydW5uaW5nXCIpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGtleWZyYW1lcyA9IGlzS2V5ZnJhbWVFZmZlY3QoYW5pbWF0aW9uLmVmZmVjdCkgPyBhbmltYXRpb24uZWZmZWN0LmdldEtleWZyYW1lcygpIDogW107XG4gICAgY29uc3Qga2V5ZnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICgha2V5ZnJhbWUpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtLCB0cmFuc2xhdGUsIHNjYWxlIH0gPSBrZXlmcmFtZTtcbiAgICBpZiAodHJhbnNmb3JtIHx8IHRyYW5zbGF0ZSB8fCBzY2FsZSkge1xuICAgICAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0oe1xuICAgICAgICB0cmFuc2Zvcm06IHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwic3RyaW5nXCIgJiYgdHJhbnNmb3JtID8gdHJhbnNmb3JtIDogY29tcHV0ZWRTdHlsZXMudHJhbnNmb3JtLFxuICAgICAgICB0cmFuc2xhdGU6IHR5cGVvZiB0cmFuc2xhdGUgPT09IFwic3RyaW5nXCIgJiYgdHJhbnNsYXRlID8gdHJhbnNsYXRlIDogY29tcHV0ZWRTdHlsZXMudHJhbnNsYXRlLFxuICAgICAgICBzY2FsZTogdHlwZW9mIHNjYWxlID09PSBcInN0cmluZ1wiICYmIHNjYWxlID8gc2NhbGUgOiBjb21wdXRlZFN0eWxlcy5zY2FsZVxuICAgICAgfSk7XG4gICAgICBpZiAocGFyc2VkVHJhbnNmb3JtKSB7XG4gICAgICAgIHByb2plY3RlZFRyYW5zZm9ybSA9IHByb2plY3RlZFRyYW5zZm9ybSA/IHtcbiAgICAgICAgICB4OiBwcm9qZWN0ZWRUcmFuc2Zvcm0ueCArIHBhcnNlZFRyYW5zZm9ybS54LFxuICAgICAgICAgIHk6IHByb2plY3RlZFRyYW5zZm9ybS55ICsgcGFyc2VkVHJhbnNmb3JtLnksXG4gICAgICAgICAgejogKF9hID0gcHJvamVjdGVkVHJhbnNmb3JtLnopICE9IG51bGwgPyBfYSA6IHBhcnNlZFRyYW5zZm9ybS56LFxuICAgICAgICAgIHNjYWxlWDogcHJvamVjdGVkVHJhbnNmb3JtLnNjYWxlWCAqIHBhcnNlZFRyYW5zZm9ybS5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZOiBwcm9qZWN0ZWRUcmFuc2Zvcm0uc2NhbGVZICogcGFyc2VkVHJhbnNmb3JtLnNjYWxlWVxuICAgICAgICB9IDogcGFyc2VkVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvamVjdGVkVHJhbnNmb3JtO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3R5cGUtZ3VhcmRzL3N1cHBvcnRzU3R5bGUudHNcbmZ1bmN0aW9uIHN1cHBvcnRzU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gXCJzdHlsZVwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuc3R5bGUgPT09IFwib2JqZWN0XCIgJiYgZWxlbWVudC5zdHlsZSAhPT0gbnVsbCAmJiBcInNldFByb3BlcnR5XCIgaW4gZWxlbWVudC5zdHlsZSAmJiBcInJlbW92ZVByb3BlcnR5XCIgaW4gZWxlbWVudC5zdHlsZSAmJiB0eXBlb2YgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5ID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvc3R5bGVzL1N0eWxlcy50c1xudmFyIFN0eWxlcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbml0aWFsID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBzZXQocHJvcGVydGllcywgcHJlZml4ID0gXCJcIikge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcztcbiAgICBpZiAoIXN1cHBvcnRzU3R5bGUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gYCR7cHJlZml4fSR7a2V5fWA7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbC5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbC5zZXQocHJvcGVydHksIGVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogYCR7dmFsdWV9cHhgXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZW1vdmUocHJvcGVydGllcywgcHJlZml4ID0gXCJcIikge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcztcbiAgICBpZiAoIXN1cHBvcnRzU3R5bGUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcHJvcGVydGllcykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBgJHtwcmVmaXh9JHtrZXl9YDtcbiAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXM7XG4gICAgaWYgKCFzdXBwb3J0c1N0eWxlKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuaW5pdGlhbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgPT09IFwiXCIpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdXRpbGl0aWVzL3R5cGUtZ3VhcmRzL2lzRWxlbWVudC50c1xuZnVuY3Rpb24gaXNFbGVtZW50KHRhcmdldCkge1xuICBpZiAoIXRhcmdldCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93KHRhcmdldCkuRWxlbWVudCB8fCBpc05vZGUodGFyZ2V0KSAmJiB0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3R5cGUtZ3VhcmRzL2lzS2V5Ym9hcmRFdmVudC50c1xuZnVuY3Rpb24gaXNLZXlib2FyZEV2ZW50KGV2ZW50KSB7XG4gIGlmICghZXZlbnQpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgeyBLZXlib2FyZEV2ZW50IH0gPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KTtcbiAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudDtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy90eXBlLWd1YXJkcy9pc1BvaW50ZXJFdmVudC50c1xuZnVuY3Rpb24gaXNQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFldmVudCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7IFBvaW50ZXJFdmVudCB9ID0gZ2V0V2luZG93KGV2ZW50LnRhcmdldCk7XG4gIHJldHVybiBldmVudCBpbnN0YW5jZW9mIFBvaW50ZXJFdmVudDtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy90eXBlLWd1YXJkcy9zdXBwb3J0c1ZpZXdUcmFuc2l0aW9uLnRzXG5mdW5jdGlvbiBzdXBwb3J0c1ZpZXdUcmFuc2l0aW9uKGRvY3VtZW50Mikge1xuICByZXR1cm4gXCJzdGFydFZpZXdUcmFuc2l0aW9uXCIgaW4gZG9jdW1lbnQyO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3R5cGUtZ3VhcmRzL2lzVGV4dElucHV0LnRzXG5mdW5jdGlvbiBpc1RleHRJbnB1dCh0YXJnZXQpIHtcbiAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7IHRhZ05hbWUgfSA9IHRhcmdldDtcbiAgcmV0dXJuIHRhZ05hbWUgPT09IFwiSU5QVVRcIiB8fCB0YWdOYW1lID09PSBcIlRFWFRBUkVBXCIgfHwgaXNDb250ZW50RWRpdGFibGUodGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9PSBcImZhbHNlXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWlzYy9nZW5lcmF0ZVVuaXF1ZUlkLnRzXG52YXIgaWRzID0ge307XG5mdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZUlkKHByZWZpeCkge1xuICBjb25zdCBpZCA9IGlkc1twcmVmaXhdID09IG51bGwgPyAwIDogaWRzW3ByZWZpeF0gKyAxO1xuICBpZHNbcHJlZml4XSA9IGlkO1xuICByZXR1cm4gYCR7cHJlZml4fS0ke2lkfWA7XG59XG5cbmV4cG9ydCB7IERPTVJlY3RhbmdsZSwgTGlzdGVuZXJzLCBGcmFtZU9ic2VydmVyIGFzIFBvc2l0aW9uT2JzZXJ2ZXIsIFByb3hpZWRFbGVtZW50cywgUmVzaXplTm90aWZpZXIsIFNjaGVkdWxlciwgU2Nyb2xsRGlyZWN0aW9uLCBTdHlsZXMsIGFuaW1hdGVUcmFuc2Zvcm0sIGNhblNjcm9sbCwgY2FuVXNlRE9NLCBjbG9uZUVsZW1lbnQsIGNvbXB1dGVUcmFuc2xhdGUsIGRldGVjdFNjcm9sbEludGVudCwgZ2VuZXJhdGVVbmlxdWVJZCwgZ2V0Qm91bmRpbmdSZWN0YW5nbGUsIGdldENvbXB1dGVkU3R5bGVzLCBnZXREb2N1bWVudCwgZ2V0RWxlbWVudEZyb21Qb2ludCwgZ2V0RmluYWxLZXlmcmFtZSwgZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IsIGdldEZyYW1lRWxlbWVudCwgZ2V0RnJhbWVUcmFuc2Zvcm0sIGdldFNjcm9sbGFibGVBbmNlc3RvcnMsIGdldFZpZXdwb3J0Qm91bmRpbmdSZWN0YW5nbGUsIGdldFZpc2libGVCb3VuZGluZ1JlY3RhbmdsZSwgZ2V0V2luZG93LCBoaWRlUG9wb3ZlciwgaW52ZXJzZVRyYW5zZm9ybSwgaXNEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQsIGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNLZXlib2FyZEV2ZW50LCBpc0tleWZyYW1lRWZmZWN0LCBpc1BvaW50ZXJFdmVudCwgaXNTYWZhcmksIGlzVGV4dElucHV0LCBwYXJzZVRyYW5zZm9ybSwgcGFyc2VUcmFuc2xhdGUsIHNjaGVkdWxlciwgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCwgc2hvd1BvcG92ZXIsIHN1cHBvcnRzUG9wb3Zlciwgc3VwcG9ydHNTdHlsZSwgc3VwcG9ydHNWaWV3VHJhbnNpdGlvbiwgdGltZW91dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@dnd-kit+dom@0.1.21/node_modules/@dnd-kit/dom/utilities.js\n");

/***/ })

};
;